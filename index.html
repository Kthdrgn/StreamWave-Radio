<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Stream radio stations with live metadata and album art">
    <meta name="theme-color" content="#667eea">
    <title>StreamWave Radio</title>
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    
    <!-- iOS specific tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Radio Player">
    <link rel="apple-touch-icon" href="icons/icon-192x192.png">
    
    <!-- Favicon -->
    <link rel="icon" type="image/png" sizes="32x32" href="icons/icon-192x192.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/icon-192x192.png">
    
    <!-- CACHE CONTROL: Prevent aggressive caching of API data -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    
    <!-- Load the icecast-metadata-player library from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/icecast-metadata-player@1.17.13/build/icecast-metadata-player-1.17.13.main.min.js"></script>
    
    <!-- Google Cast SDK -->
    <script src="https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1"></script>
    
    <!-- Load HLS.js for m3u8 stream support -->
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    
    <!-- Load Supabase client library -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <!-- Load authentication module -->
    <script src="radio-auth.js"></script>

    <!-- Modular CSS -->
    <link rel="stylesheet" href="css/styles.css">
    
</head>
<body>
    <div class="player-container">
        <!-- LEFT COLUMN: Artwork (only visible in landscape mode) -->
        <div class="tv-left-column">
            <div class="artwork-container" id="artworkContainer">
                <img src="icons/icon-512x512.png" alt="StreamWave Radio" class="album-art" style="padding: 40px; opacity: 0.5;">
            </div>
        </div>

        <!-- RIGHT COLUMN: Everything else -->
        <div class="tv-right-column">
            <!-- Hamburger Menu Icon (above artwork) -->
            <div class="hamburger-menu-wrapper">
                <div class="hamburger-menu-container">
                    <button id="overviewBtn" class="hamburger-btn overview-btn" title="Overview">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <rect x="3" y="3" width="8" height="8" rx="1.5" stroke-width="2" fill="none"/>
                            <rect x="13" y="3" width="8" height="8" rx="1.5" stroke-width="2" fill="none"/>
                            <rect x="3" y="13" width="8" height="8" rx="1.5" stroke-width="2" fill="none"/>
                            <rect x="13" y="13" width="8" height="8" rx="1.5" stroke-width="2" fill="none"/>
                        </svg>
                    </button>
                    <button id="hamburgerMenuBtn" class="hamburger-btn" title="Menu">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M4 6H20M4 12H20M4 18H20" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                    </button>
                </div>
            </div>

            <!-- Currently playing station display -->
            <div id="stationDisplay" class="station-display disabled" style="display: flex;">
                <img id="stationDisplayIcon" class="station-display-icon" src="icons/icon-512x512.png" alt="StreamWave Radio" style="display: block;">
                <div class="station-display-info">
                    <div id="stationDisplayName" class="station-display-name">StreamWave Radio</div>
                    <div id="stationDisplayDetails" class="station-display-details" style="display: block;">Select a station to begin</div>
                </div>
                <!-- Chromecast button in station display -->
                <google-cast-launcher id="castButton" class="station-cast-btn" title="Cast to Chromecast" style="display: none;"></google-cast-launcher>
            </div>

            <!-- Album artwork (visible in portrait mode) -->
            <div class="artwork-container portrait-artwork" id="artworkContainerPortrait">
                <img src="icons/icon-512x512.png" alt="StreamWave Radio" class="album-art" style="padding: 40px; opacity: 0.5;">
            </div>

            <!-- Metadata display -->
            <div class="metadata-section" id="metadataSection">
                <div class="lyrics-indicator" id="lyricsIndicator" style="display: none;" title="Lyrics available">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path d="M9 18V5L21 3V16M9 18C9 19.66 7.66 21 6 21C4.34 21 3 19.66 3 18C3 16.34 4.34 15 6 15C7.66 15 9 16.34 9 18ZM21 16C21 17.66 19.66 19 18 19C16.34 19 15 17.66 15 16C15 14.34 16.34 13 18 13C19.66 13 21 14.34 21 16ZM9 10V7L21 5V8L9 10Z" fill="currentColor"/>
                    </svg>
                </div>
                <div class="now-playing-label">NOW PLAYING</div>
                <div class="no-metadata">Select a station to start streaming</div>
            </div>

            <!-- Player controls -->
            <div class="controls">
                <div class="controls-buttons">
                    <button id="backBtn" class="control-icon-btn btn-back" disabled title="Go back">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M15 19L8 12L15 5" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
                        </svg>
                    </button>
                    <button id="playPauseBtn" class="control-icon-btn btn-play" disabled>
                        <svg class="play-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M16.6582 9.28638C18.098 10.1862 18.8178 10.6361 19.0647 11.2122C19.2803 11.7152 19.2803 12.2847 19.0647 12.7878C18.8178 13.3638 18.098 13.8137 16.6582 14.7136L9.896 18.94C8.29805 19.9387 7.49907 20.4381 6.83973 20.385C6.26501 20.3388 5.73818 20.0469 5.3944 19.584C5 19.053 5 18.1108 5 16.2264V7.77357C5 5.88919 5 4.94701 5.3944 4.41598C5.73818 3.9531 6.26501 3.66111 6.83973 3.6149C7.49907 3.5619 8.29805 4.06126 9.896 5.05998L16.6582 9.28638Z" stroke-width="2" stroke-linejoin="round"/>
                        </svg>
                        <svg class="pause-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="display: none;">
                            <path d="M2 12C2 7.28595 2 4.92893 3.46447 3.46447C4.92893 2 7.28595 2 12 2C16.714 2 19.0711 2 20.5355 3.46447C22 4.92893 22 7.28595 22 12C22 16.714 22 19.0711 20.5355 20.5355C19.0711 22 16.714 22 12 22C7.28595 22 4.92893 22 3.46447 20.5355C2 19.0711 2 16.714 2 12Z" stroke-width="1.5"/>
                        </svg>
                    </button>
                </div>
                <!-- Playback mode button commented out - handled automatically -->
                <!-- <button id="playbackModeBtn" class="quality-btn" title="Toggle playback mode">
                    <span id="currentMode">Live</span>
                    <span style="font-size: 10px;">‚ñº</span>
                </button> -->
                <!-- Quality button removed - now accessible via Station Info modal -->
            </div>

            <!-- Status indicator -->
            <div class="status-indicator">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">Not connected</span>
            </div>
        </div><!-- Close tv-right-column -->
    </div><!-- Close player-container -->
    
    <!-- Settings Modal -->
    <div id="settingsModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Settings</h2>
                <button class="modal-close" id="closeSettingsModal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="settings-content">
                    <div class="setting-item">
                        <label class="setting-label">Theme Color</label>
                        <div class="color-theme-grid">
                            <button class="color-theme-btn" data-color="default">
                                <span class="color-preview" style="background: linear-gradient(135deg, #1e1e1e, #f5f7fa);"></span>
                                <span class="color-name">Default</span>
                            </button>
                            <button class="color-theme-btn" data-color="ocean-blue">
                                <span class="color-preview" style="background: linear-gradient(135deg, #0a1929, #e3f2fd);"></span>
                                <span class="color-name">Ocean Blue</span>
                            </button>
                            <button class="color-theme-btn" data-color="emerald-forest">
                                <span class="color-preview" style="background: linear-gradient(135deg, #0d1f12, #e8f5e9);"></span>
                                <span class="color-name">Emerald Forest</span>
                            </button>
                            <button class="color-theme-btn" data-color="slate-gray">
                                <span class="color-preview" style="background: linear-gradient(135deg, #1a1d23, #eceff1);"></span>
                                <span class="color-name">Slate Gray</span>
                            </button>
                            <button class="color-theme-btn" data-color="royal-purple">
                                <span class="color-preview" style="background: linear-gradient(135deg, #1a0d2e, #f3e5f5);"></span>
                                <span class="color-name">Royal Purple</span>
                            </button>
                            <button class="color-theme-btn" data-color="golden-sunset">
                                <span class="color-preview" style="background: linear-gradient(135deg, #2e1a0a, #fff3e0);"></span>
                                <span class="color-name">Golden Sunset</span>
                            </button>
                            <button class="color-theme-btn" data-color="fire-red">
                                <span class="color-preview" style="background: linear-gradient(135deg, #2e0d0d, #ffebee);"></span>
                                <span class="color-name">Fire Red</span>
                            </button>
                        </div>
                        <div class="setting-description">
                            Choose your preferred color theme.
                        </div>
                    </div>

                    <div class="setting-item">
                        <label class="setting-label">Brightness</label>
                        <div class="theme-toggle-container">
                            <button class="theme-toggle-btn" id="themeToggle">
                                <span class="theme-option" data-theme="dark">
                                    <span class="theme-icon">üåô</span>
                                    <span class="theme-name">Dark</span>
                                </span>
                                <span class="theme-option" data-theme="light">
                                    <span class="theme-icon">‚òÄÔ∏è</span>
                                    <span class="theme-name">Light</span>
                                </span>
                                <span class="theme-slider"></span>
                            </button>
                        </div>
                        <div class="setting-description">
                            Switch between dark and light mode.
                        </div>
                        <button class="reset-theme-btn" id="resetThemeBtn" style="display: none;">
                            üîÑ Reset to System Brightness
                        </button>
                    </div>

                    <div class="setting-item">
                        <label class="setting-label">Layout</label>
                        <div class="layout-toggle-container">
                            <button class="layout-toggle-btn" id="layoutToggle">
                                <span class="layout-option" data-layout="portrait">
                                    <span class="layout-icon">üì±</span>
                                    <span class="layout-name">Portrait</span>
                                </span>
                                <span class="layout-option" data-layout="landscape">
                                    <span class="layout-icon">üñ•Ô∏è</span>
                                    <span class="layout-name">Landscape</span>
                                </span>
                                <span class="layout-slider"></span>
                            </button>
                        </div>
                        <div class="setting-description">
                            Switch between portrait and landscape layout (large artwork on left).
                        </div>
                    </div>

                    <div class="setting-item">
                        <label class="setting-label">CORS Proxy</label>
                        <div class="form-checkbox">
                            <input type="checkbox" id="globalCorsProxy" checked>
                            <label for="globalCorsProxy" style="cursor: pointer;">Use CORS Proxy</label>
                        </div>
                        <div class="setting-description">
                            Enable this if streams fail to load. Uses a proxy to bypass CORS restrictions.
                        </div>
                    </div>

                    <div class="setting-item">
                        <label class="setting-label">Auto-Fallback Mode</label>
                        <div class="form-checkbox">
                            <input type="checkbox" id="autoFallback" checked>
                            <label for="autoFallback" style="cursor: pointer;">Auto-switch to Simple Mode if Live fails</label>
                        </div>
                        <div class="setting-description">
                            Automatically try Simple Mode (without metadata) if Live Mode fails to connect.
                        </div>
                    </div>

                    <div class="setting-item">
                        <label class="setting-label">Album Artwork</label>
                        <div class="form-checkbox">
                            <input type="checkbox" id="useItunesApi" checked>
                            <label for="useItunesApi" style="cursor: pointer;">Use iTunes API for Artwork</label>
                        </div>
                        <div class="setting-description">
                            Automatically fetch album artwork from iTunes when available.
                        </div>
                    </div>

                    <div class="setting-item">
                        <label class="setting-label">Keep Screen Awake</label>
                        <div class="form-checkbox">
                            <input type="checkbox" id="keepScreenAwake">
                            <label for="keepScreenAwake" style="cursor: pointer;">Prevent screen from sleeping</label>
                        </div>
                        <div class="setting-description">
                            Keep your screen on while listening to music. Useful for viewing now playing info.
                        </div>
                    </div>

                    <div class="setting-item">
                        <label class="setting-label">Fullscreen Mode</label>
                        <div class="form-checkbox">
                            <input type="checkbox" id="fullscreenMode">
                            <label for="fullscreenMode" style="cursor: pointer;">Enable fullscreen mode</label>
                        </div>
                        <div class="setting-description">
                            Toggle fullscreen mode for an immersive listening experience.
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Overview/Home Modal -->
    <div id="overviewModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 900px;">
            <div class="modal-header">
                <h2 class="modal-title">StreamWave Radio</h2>
                <button class="modal-close" id="closeOverviewModal">&times;</button>
            </div>

            <!-- Auth Button at Top of Overview -->
            <div style="padding: 0 20px 12px 20px; border-bottom: 1px solid var(--border-color);">
                <button class="menu-option-btn" id="authBtn" style="width: 100%;">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="authIcon">
                        <path d="M16 7C16 9.20914 14.2091 11 12 11C9.79086 11 8 9.20914 8 7C8 4.79086 9.79086 3 12 3C14.2091 3 16 4.79086 16 7Z" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        <path d="M12 14C8.13401 14 5 17.134 5 21H19C19 17.134 15.866 14 12 14Z" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    <span id="authBtnText">Sign In</span>
                </button>
            </div>

            <div class="modal-body">
                <!-- Playlists Carousel -->
                <div class="carousel-section">
                    <h3 class="carousel-title">Your Playlists</h3>
                    <div class="carousel-container">
                        <button class="carousel-btn carousel-prev" id="playlistsPrev">‚Äπ</button>
                        <div class="carousel-track" id="playlistsTrack"></div>
                        <button class="carousel-btn carousel-next" id="playlistsNext">‚Ä∫</button>
                    </div>
                </div>

                <!-- Most Recent Stations Carousel -->
                <div class="carousel-section">
                    <h3 class="carousel-title">Most Recent Stations</h3>
                    <div class="carousel-container">
                        <button class="carousel-btn carousel-prev" id="recentPrev">‚Äπ</button>
                        <div class="carousel-track" id="recentTrack"></div>
                        <button class="carousel-btn carousel-next" id="recentNext">‚Ä∫</button>
                    </div>
                </div>

                <!-- Most Played Stations List -->
                <div class="carousel-section">
                    <h3 class="carousel-title">Most Played Stations</h3>
                    <div class="stations-list" id="playedStationsList"></div>
                </div>

                <!-- Track Actions Buttons at Bottom -->
                <div class="menu-options" style="margin-top: 24px; display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                    <button class="menu-option-btn" id="overviewViewLikedTracksBtn">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M20.84 4.61C20.3292 4.099 19.7228 3.69365 19.0554 3.41708C18.3879 3.14052 17.6725 2.99817 16.95 2.99817C16.2275 2.99817 15.5121 3.14052 14.8446 3.41708C14.1772 3.69365 13.5708 4.099 13.06 4.61L12 5.67L10.94 4.61C9.9083 3.57831 8.50903 2.99871 7.05 2.99871C5.59096 2.99871 4.19169 3.57831 3.16 4.61C2.1283 5.64169 1.54871 7.04096 1.54871 8.5C1.54871 9.95903 2.1283 11.3583 3.16 12.39L4.22 13.45L12 21.23L19.78 13.45L20.84 12.39C21.351 11.8792 21.7563 11.2728 22.0329 10.6054C22.3095 9.93789 22.4518 9.22248 22.4518 8.5C22.4518 7.77752 22.3095 7.0621 22.0329 6.39464C21.7563 5.72718 21.351 5.12075 20.84 4.61Z" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="currentColor"/>
                        </svg>
                        <span>View Liked Songs</span>
                    </button>
                    <button class="menu-option-btn" id="overviewViewRecentTracksBtn">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22Z" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M12 6V12L16 14" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                        <span>Recent Songs</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Discover Modal -->
    <div id="discoverModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 900px;">
            <div class="modal-header">
                <h2 class="modal-title">Discover</h2>
                <button class="modal-close" id="closeDiscoverModal">&times;</button>
            </div>
            <div class="modal-body">
                <!-- Search Buttons -->
                <div class="menu-options" style="margin-bottom: 12px; display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                    <button id="searchCuratedBtn" class="menu-option-btn">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M11 6C13.7614 6 16 8.23858 16 11M16.6588 16.6549L21 21M19 11C19 15.4183 15.4183 19 11 19C6.58172 19 3 15.4183 3 11C3 6.58172 6.58172 3 11 3C15.4183 3 19 6.58172 19 11Z" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                        <span>Search Curated Stations</span>
                    </button>
                    <button id="searchDatabaseBtn" class="menu-option-btn">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22Z" stroke-width="2"/>
                            <path d="M8 12C8 9.79086 9.79086 8 12 8C14.2091 8 16 9.79086 16 12C16 14.2091 14.2091 16 12 16C9.79086 16 8 14.2091 8 12Z" stroke-width="2"/>
                            <path d="M12 15L12 19" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                        <span>Search Radio Database</span>
                    </button>
                </div>

                <!-- Curated Playlists Carousel -->
                <div class="carousel-section" id="discoverCuratedPlaylistsSection" style="display: none;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                        <h3 class="carousel-title" style="margin: 0;">Curated Playlists</h3>
                        <a id="viewAllCuratedPlaylistsLink" href="#" style="color: #4a90e2; font-size: 14px; text-decoration: none; font-weight: 500; display: none;">View All ‚Üí</a>
                    </div>
                    <div class="carousel-container">
                        <button class="carousel-btn carousel-prev" id="discoverCuratedPlaylistsPrev">‚Äπ</button>
                        <div class="carousel-track" id="discoverCuratedPlaylistsTrack"></div>
                        <button class="carousel-btn carousel-next" id="discoverCuratedPlaylistsNext">‚Ä∫</button>
                    </div>
                </div>

                <!-- Tag-Based Preset Searches Carousel -->
                <div class="carousel-section" id="discoverTagPresetsSection" style="display: none;">
                    <h3 class="carousel-title">Discover by Genre & Tags</h3>
                    <div class="carousel-container">
                        <button class="carousel-btn carousel-prev" id="discoverTagPresetsPrev">‚Äπ</button>
                        <div class="carousel-track" id="discoverTagPresetsTrack"></div>
                        <button class="carousel-btn carousel-next" id="discoverTagPresetsNext">‚Ä∫</button>
                    </div>
                </div>

                <!-- Multi-Channel Radio Stations Carousel -->
                <div class="carousel-section" id="discoverMultiChannelRadioSection" style="display: none;">
                    <h3 class="carousel-title">Multi-Channel Internet Radio Stations</h3>
                    <div class="carousel-container">
                        <button class="carousel-btn carousel-prev" id="discoverMultiChannelRadioPrev">‚Äπ</button>
                        <div class="carousel-track" id="discoverMultiChannelRadioTrack"></div>
                        <button class="carousel-btn carousel-next" id="discoverMultiChannelRadioNext">‚Ä∫</button>
                    </div>
                </div>

                <!-- Preset Searches Carousel -->
                <div class="carousel-section" id="discoverPresetSearchesSection" style="display: none;">
                    <h3 class="carousel-title">Quick Search Presets</h3>
                    <div class="carousel-container">
                        <button class="carousel-btn carousel-prev" id="discoverPresetSearchesPrev">‚Äπ</button>
                        <div class="carousel-track" id="discoverPresetSearchesTrack"></div>
                        <button class="carousel-btn carousel-next" id="discoverPresetSearchesNext">‚Ä∫</button>
                    </div>
                </div>

                <!-- Explore Section -->
                <div id="discoverExploreSection" style="display: none;">
                    <!-- Explore Header -->
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px; margin-top: 10px;">
                        <h2 style="font-size: 24px; font-weight: 700; color: var(--text-primary); margin: 0;">Explore new stations</h2>
                        <button id="discoverPlayRandomStationBtn" class="btn" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 10px 20px; font-size: 14px; font-weight: 600; border: none; border-radius: 8px; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);">
                            üé≤ Play Random Station
                        </button>
                    </div>

                    <!-- Because You Listened Carousel -->
                    <div class="carousel-section" id="discoverBecauseListenedSection" style="display: none;">
                        <h3 class="carousel-title" id="discoverBecauseListenedTitle">Because you listened to...</h3>
                        <div class="carousel-container">
                            <button class="carousel-btn carousel-prev" id="discoverBecauseListenedPrev">‚Äπ</button>
                            <div class="carousel-track" id="discoverBecauseListenedTrack"></div>
                            <button class="carousel-btn carousel-next" id="discoverBecauseListenedNext">‚Ä∫</button>
                        </div>
                    </div>

                    <!-- Because You Like Carousel -->
                    <div class="carousel-section" id="discoverBecauseLikeSection" style="display: none;">
                        <h3 class="carousel-title" id="discoverBecauseLikeTitle">Because you like...</h3>
                        <div class="carousel-container">
                            <button class="carousel-btn carousel-prev" id="discoverBecauseLikePrev">‚Äπ</button>
                            <div class="carousel-track" id="discoverBecauseLikeTrack"></div>
                            <button class="carousel-btn carousel-next" id="discoverBecauseLikeNext">‚Ä∫</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- All Curated Playlists Modal -->
    <div id="allCuratedPlaylistsModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 1000px;">
            <div class="modal-header">
                <h2 class="modal-title">All Curated Playlists</h2>
                <button class="modal-close" id="closeAllCuratedPlaylistsModal">&times;</button>
            </div>
            <div class="modal-body">
                <div id="allCuratedPlaylistsGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 20px; padding: 10px;">
                    <!-- Playlists will be inserted here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Quality Modal -->
    <div id="qualityModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 350px;">
            <div class="modal-header">
                <h2 class="modal-title">Stream Quality</h2>
                <button class="modal-close" id="closeQualityModal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="quality-options-modal">
                    <div class="quality-option-modal" data-quality="low">
                        <div class="quality-option-main">
                            <span class="quality-option-icon">üîâ</span>
                            <span class="quality-option-name">Low Quality</span>
                        </div>
                        <div class="quality-option-desc">Best for slower connections</div>
                    </div>
                    <div class="quality-option-modal selected" data-quality="standard">
                        <div class="quality-option-main">
                            <span class="quality-option-icon">üîä</span>
                            <span class="quality-option-name">Standard Quality</span>
                        </div>
                        <div class="quality-option-desc">Balanced quality and bandwidth</div>
                    </div>
                    <div class="quality-option-modal" data-quality="high">
                        <div class="quality-option-main">
                            <span class="quality-option-icon">üìª</span>
                            <span class="quality-option-name">High Quality</span>
                        </div>
                        <div class="quality-option-desc">Best audio quality (requires fast connection)</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Playback Mode Modal -->
    <div id="playbackModeModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <h2 class="modal-title">Playback Mode</h2>
                <button class="modal-close" id="closePlaybackModeModal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="quality-options-modal">
                    <div class="quality-option-modal selected" data-mode="live">
                        <div class="quality-option-main">
                            <span class="quality-option-icon">üì°</span>
                            <span class="quality-option-name">Live Mode</span>
                        </div>
                        <div class="quality-option-desc">Real-time metadata & album art. No pause/resume.</div>
                    </div>
                    <div class="quality-option-modal" data-mode="simple">
                        <div class="quality-option-main">
                            <span class="quality-option-icon">‚ñ∂Ô∏è</span>
                            <span class="quality-option-name">Simple Mode</span>
                        </div>
                        <div class="quality-option-desc">Stop/restart playback (live stream). No metadata updates. Works with more streams.</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Hamburger Menu Modal -->
    <div id="hamburgerMenuModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 350px;">
            <div class="modal-header">
                <h2 class="modal-title">Menu</h2>
                <button class="modal-close" id="closeHamburgerMenuModal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="menu-options">
                    <!-- My Playlists Button -->
                    <button class="menu-option-btn" id="viewPlaylistsBtn">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M8 6H21M8 12H21M8 18H21M3 6H3.01M3 12H3.01M3 18H3.01" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                        <span>My Playlists</span>
                    </button>

                    <!-- Create Playlist Button -->
                    <button class="menu-option-btn" id="createPlaylistMenuBtn">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 5V19M5 12H19" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                        <span>Create Playlist</span>
                    </button>

                    <!-- Divider -->
                    <div class="menu-divider"></div>

                    <button class="menu-option-btn" id="settingsMenuBtn">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="12" cy="12" r="3" stroke-width="1.5"/>
                            <path opacity="0.5" d="M13.7654 2.15224C13.3978 2 12.9319 2 12 2C11.0681 2 10.6022 2 10.2346 2.15224C9.74457 2.35523 9.35522 2.74458 9.15223 3.23463C9.05957 3.45834 9.0233 3.7185 9.00911 4.09799C8.98826 4.65568 8.70226 5.17189 8.21894 5.45093C7.73564 5.72996 7.14559 5.71954 6.65219 5.45876C6.31645 5.2813 6.07301 5.18262 5.83294 5.15102C5.30704 5.08178 4.77518 5.22429 4.35436 5.5472C4.03874 5.78938 3.80577 6.1929 3.33983 6.99993C2.87389 7.80697 2.64092 8.21048 2.58899 8.60491C2.51976 9.1308 2.66227 9.66266 2.98518 10.0835C3.13256 10.2756 3.3397 10.437 3.66119 10.639C4.1338 10.936 4.43789 11.4419 4.43786 12C4.43783 12.5581 4.13375 13.0639 3.66118 13.3608C3.33965 13.5629 3.13248 13.7244 2.98508 13.9165C2.66217 14.3373 2.51966 14.8691 2.5889 15.395C2.64082 15.7894 2.87379 16.193 3.33973 17C3.80568 17.807 4.03865 18.2106 4.35426 18.4527C4.77508 18.7756 5.30694 18.9181 5.83284 18.8489C6.07289 18.8173 6.31632 18.7186 6.65204 18.5412C7.14547 18.2804 7.73556 18.27 8.2189 18.549C8.70224 18.8281 8.98826 19.3443 9.00911 19.9021C9.02331 20.2815 9.05957 20.5417 9.15223 20.7654C9.35522 21.2554 9.74457 21.6448 10.2346 21.8478C10.6022 22 11.0681 22 12 22C12.9319 22 13.3978 22 13.7654 21.8478C14.2554 21.6448 14.6448 21.2554 14.8477 20.7654C14.9404 20.5417 14.9767 20.2815 14.9909 19.902C15.0117 19.3443 15.2977 18.8281 15.781 18.549C16.2643 18.2699 16.8544 18.2804 17.3479 18.5412C17.6836 18.7186 17.927 18.8172 18.167 18.8488C18.6929 18.9181 19.2248 18.7756 19.6456 18.4527C19.9612 18.2105 20.1942 17.807 20.6601 16.9999C21.1261 16.1929 21.3591 15.7894 21.411 15.395C21.4802 14.8691 21.3377 14.3372 21.0148 13.9164C20.8674 13.7243 20.6602 13.5628 20.3387 13.3608C19.8662 13.0639 19.5621 12.558 19.5621 11.9999C19.5621 11.4418 19.8662 10.9361 20.3387 10.6392C20.6603 10.4371 20.8675 10.2757 21.0149 10.0835C21.3378 9.66273 21.4803 9.13087 21.4111 8.60497C21.3592 8.21055 21.1262 7.80703 20.6602 7C20.1943 6.19297 19.9613 5.78945 19.6457 5.54727C19.2249 5.22436 18.693 5.08185 18.1671 5.15109C17.9271 5.18269 17.6837 5.28136 17.3479 5.4588C16.8545 5.71959 16.2644 5.73002 15.7811 5.45096C15.2977 5.17191 15.0117 4.65566 14.9909 4.09794C14.9767 3.71848 14.9404 3.45833 14.8477 3.23463C14.6448 2.74458 14.2554 2.35523 13.7654 2.15224Z" stroke-width="1.5"/>
                        </svg>
                        <span>Settings</span>
                    </button>

                    <!-- Add Station Button -->
                    <button class="menu-option-btn" id="addStationBtn">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 5V19M5 12H19" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                        <span>Add Station</span>
                    </button>

                    <!-- Manage Preset Searches Button (Admin Only) -->
                    <button class="menu-option-btn" id="managePresetSearchesBtn" style="display: none;">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M21 21L15 15M17 10C17 13.866 13.866 17 10 17C6.13401 17 3 13.866 3 10C3 6.13401 6.13401 3 10 3C13.866 3 17 6.13401 17 10Z" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M10 7V13M7 10H13" stroke-width="1.5" stroke-linecap="round"/>
                        </svg>
                        <span>Manage Preset Searches</span>
                    </button>

                    <!-- Manage Curated Playlists Button (Admin Only) -->
                    <button class="menu-option-btn" id="manageCuratedPlaylistsBtn" style="display: none;">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M9 11L12 14L22 4" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M21 12V19C21 19.5304 20.7893 20.0391 20.4142 20.4142C20.0391 20.7893 19.5304 21 19 21H5C4.46957 21 3.96086 20.7893 3.58579 20.4142C3.21071 20.0391 3 19.5304 3 19V5C3 4.46957 3.21071 3.96086 3.58579 3.58579C3.96086 3.21071 4.46957 3 5 3H16" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                        <span>Manage Curated Playlists</span>
                    </button>

                    <!-- Chromecast button temporarily disabled - needs styling work -->
                    <!-- <google-cast-launcher id="castButton" class="menu-option-btn cast-menu-btn" title="Cast to Chromecast">
                        <span>Chromecast</span>
                    </google-cast-launcher> -->
                </div>
            </div>
        </div>
    </div>

    <!-- Liked Tracks Modal -->
    <div id="likedTracksModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Liked Tracks</h2>
                <button class="modal-close" id="closeLikedTracksModal">&times;</button>
            </div>
            <div class="modal-body">
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button class="clear-all-likes-btn" id="clearAllLikesBtn" style="display: none;">
                        Clear All
                    </button>
                    <button class="copy-all-btn" id="copyAllLikedBtn" style="display: none;">
                        <svg width="16" height="16" viewBox="0 0 256 256" style="vertical-align: middle; margin-right: 6px;">
                            <path fill="currentColor" d="M216 32H88a16 16 0 0 0-16 16v40H40a16 16 0 0 0-16 16v120a16 16 0 0 0 16 16h128a16 16 0 0 0 16-16v-40h32a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16zm-48 192H40V104h128zm48-48h-32V104a16 16 0 0 0-16-16H88V48h128z"/>
                        </svg>
                        Copy
                    </button>
                    <button class="copy-all-btn" id="downloadLikedBtn" style="display: none;">
                        <svg width="16" height="16" viewBox="0 0 256 256" style="vertical-align: middle; margin-right: 6px;">
                            <path fill="currentColor" d="M208 144a15.78 15.78 0 0 1 10.42 4L234 163.6a16 16 0 0 1 0 24.79l-15.58 15.59A15.78 15.78 0 0 1 208 208h-48v16a8 8 0 0 1-8 8H40a8 8 0 0 1-8-8v-16H8a8 8 0 0 1 0-16h24v-64H8a8 8 0 0 1 0-16h24V48a8 8 0 0 1 8-8h112a8 8 0 0 1 8 8v64h48zm-16 48h16v-32h-16zm-16-112a8 8 0 0 0-8-8h-64a8 8 0 0 0 0 16h64a8 8 0 0 0 8-8zm0 48v-32H48v32zm0 16H48v32h128zm0 48v-16H48v16zm32-32h16l-16-16z"/>
                        </svg>
                        Download
                    </button>
                </div>
                <div class="liked-tracks-list" id="likedTracksList">
                    <div class="empty-state">
                        <div class="empty-state-icon">‚ô°</div>
                        <div class="empty-state-text">No liked tracks yet. Like a track while listening to save it here!</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Recent Tracks Modal -->
    <div id="recentTracksModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Recent Songs</h2>
                <button class="modal-close" id="closeRecentTracksModal">&times;</button>
            </div>
            <div class="modal-body">
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button class="clear-all-likes-btn" id="clearRecentTracksBtn" style="display: none;">
                        Clear All
                    </button>
                    <button class="copy-all-btn" id="copyAllRecentBtn" style="display: none;">
                        <svg width="16" height="16" viewBox="0 0 256 256" style="vertical-align: middle; margin-right: 6px;">
                            <path fill="currentColor" d="M216 32H88a16 16 0 0 0-16 16v40H40a16 16 0 0 0-16 16v120a16 16 0 0 0 16 16h128a16 16 0 0 0 16-16v-40h32a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16zm-48 192H40V104h128zm48-48h-32V104a16 16 0 0 0-16-16H88V48h128z"/>
                        </svg>
                        Copy
                    </button>
                    <button class="copy-all-btn" id="downloadRecentBtn" style="display: none;">
                        <svg width="16" height="16" viewBox="0 0 256 256" style="vertical-align: middle; margin-right: 6px;">
                            <path fill="currentColor" d="M208 144a15.78 15.78 0 0 1 10.42 4L234 163.6a16 16 0 0 1 0 24.79l-15.58 15.59A15.78 15.78 0 0 1 208 208h-48v16a8 8 0 0 1-8 8H40a8 8 0 0 1-8-8v-16H8a8 8 0 0 1 0-16h24v-64H8a8 8 0 0 1 0-16h24V48a8 8 0 0 1 8-8h112a8 8 0 0 1 8 8v64h48zm-16 48h16v-32h-16zm-16-112a8 8 0 0 0-8-8h-64a8 8 0 0 0 0 16h64a8 8 0 0 0 8-8zm0 48v-32H48v32zm0 16H48v32h128zm0 48v-16H48v16zm32-32h16l-16-16z"/>
                        </svg>
                        Download
                    </button>
                </div>
                <div class="liked-tracks-list" id="recentTracksList">
                    <div class="empty-state">
                        <div class="empty-state-icon">üïê</div>
                        <div class="empty-state-text">No recent tracks yet. Start listening to see your recently played tracks here!</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Lyrics Modal -->
    <div id="lyricsModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title" id="lyricsModalTitle">Lyrics</h2>
                <button class="modal-close" id="closeLyricsModal">&times;</button>
            </div>
            <div class="modal-body">
                <div id="lyricsContent" class="lyrics-content">
                    <div class="lyrics-loading">Loading lyrics...</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Now Playing Details Modal -->
    <div id="nowPlayingModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Now Playing</h2>
                <button class="modal-close" id="closeNowPlayingModal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="now-playing-details">
                    <!-- Track Info -->
                    <div class="modal-track-info">
                        <div class="modal-song-title" id="modalSongTitle"></div>
                        <div class="modal-artist-name" id="modalArtistName"></div>
                        <div class="modal-album-name" id="modalAlbumName"></div>
                    </div>

                    <!-- Action Buttons -->
                    <div class="track-actions">
                        <button class="menu-option-btn" id="modalLyricsBtn" onclick="showLyricsModal()">
                            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <path d="M9 18V5L21 3V16M9 18C9 19.66 7.66 21 6 21C4.34 21 3 19.66 3 18C3 16.34 4.34 15 6 15C7.66 15 9 16.34 9 18ZM21 16C21 17.66 19.66 19 18 19C16.34 19 15 17.66 15 16C15 14.34 16.34 13 18 13C19.66 13 21 14.34 21 16ZM9 10V7L21 5V8L9 10Z" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                            <span>Lyrics</span>
                        </button>

                        <button class="menu-option-btn" id="modalLikeBtn" onclick="toggleLikeTrack()">
                            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <path d="M20.84 4.61C20.3292 4.099 19.7228 3.69365 19.0554 3.41708C18.3879 3.14052 17.6725 2.99817 16.95 2.99817C16.2275 2.99817 15.5121 3.14052 14.8446 3.41708C14.1772 3.69365 13.5708 4.099 13.06 4.61L12 5.67L10.94 4.61C9.9083 3.57831 8.50903 2.99871 7.05 2.99871C5.59096 2.99871 4.19169 3.57831 3.16 4.61C2.1283 5.64169 1.54871 7.04096 1.54871 8.5C1.54871 9.95903 2.1283 11.3583 3.16 12.39L4.22 13.45L12 21.23L19.78 13.45L20.84 12.39C21.351 11.8792 21.7563 11.2728 22.0329 10.6054C22.3095 9.93789 22.4518 9.22248 22.4518 8.5C22.4518 7.77752 22.3095 7.0621 22.0329 6.39464C21.7563 5.72718 21.351 5.12075 20.84 4.61Z" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                            <span>Like This Song</span>
                        </button>
                    </div>

                    <!-- Loading Indicator -->
                    <div id="audioDbLoadingIndicator" class="audiodb-loading" style="display: none;">
                        <div class="loading-spinner"></div>
                        <span>Loading additional info...</span>
                    </div>

                    <!-- Enhanced Track Details -->
                    <div id="trackDetailsSection" class="track-details-section" style="display: none;">
                        <h3 class="section-header">Track Information</h3>
                        <div id="trackDetailsContent" class="details-content">
                            <!-- Will be populated dynamically -->
                        </div>
                    </div>

                    <!-- Artist Information -->
                    <div id="artistInfoSection" class="artist-info-section" style="display: none;">
                        <h3 class="section-header">About the Artist</h3>
                        <div class="artist-info-container">
                            <img id="artistThumbnail" class="artist-thumbnail" alt="Artist" style="display: none;">
                            <div id="artistInfoContent" class="details-content">
                                <!-- Will be populated dynamically -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Station Info Modal -->
    <div id="stationInfoModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Station Information</h2>
                <button class="modal-close" id="closeStationInfoModal">&times;</button>
            </div>
            <div class="modal-body">
                <!-- Add to Playlist Button -->
                <button id="addCurrentStationToPlaylistBtn" class="menu-option-btn" style="margin-bottom: 12px;">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path d="M12 5V19M5 12H19" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    <span>Add station to playlist</span>
                </button>

                <!-- Select Quality Button -->
                <button id="selectQualityBtn" class="menu-option-btn" style="margin-bottom: 12px;">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path d="M3 7V17M7 4V20M11 9V15M15 6V18M19 10V14" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    <span>Select Quality</span>
                </button>

                <!-- Curate Station Button (Admin Only) -->
                <button id="curateStationBtn" class="menu-option-btn" style="margin-bottom: 12px; display: none;">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path d="M12 2L15.09 8.26L22 9.27L17 14.14L18.18 21.02L12 17.77L5.82 21.02L7 14.14L2 9.27L8.91 8.26L12 2Z" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    <span>Curate Station</span>
                </button>

                <!-- Add to Curated Playlist Button (Admin Only) -->
                <button id="addToCuratedPlaylistBtn" class="menu-option-btn" style="margin-bottom: 12px; display: none;">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path d="M9 5H7C5.89543 5 5 5.89543 5 7V19C5 20.1046 5.89543 21 7 21H17C18.1046 21 19 20.1046 19 19V7C19 5.89543 18.1046 5 17 5H15M9 5C9 6.10457 9.89543 7 11 7H13C14.1046 7 15 6.10457 15 5M9 5C9 3.89543 9.89543 3 11 3H13C14.1046 3 15 3.89543 15 5M12 12V17M9.5 14.5L12 12L14.5 14.5" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    <span>Add to Curated Playlist</span>
                </button>

                <!-- Station Overview Section -->
                <div id="stationOverviewSection" style="margin-top: 20px;">
                    <h3 style="color: var(--text-primary); margin-bottom: 16px; font-size: 18px; font-weight: 600;">Station Overview</h3>

                    <!-- Station Logo -->
                    <div id="stationLogoContainer" style="text-align: center; margin-bottom: 20px; display: none;">
                        <img id="stationLogo" src="" alt="Station Logo" style="max-width: 120px; max-height: 120px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.2);">
                    </div>

                    <!-- Station Info Grid -->
                    <div id="stationInfoGrid" style="display: grid; gap: 12px;">
                        <!-- Info items will be dynamically added here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Playlists Modal -->
    <div id="playlistsModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">My Playlists</h2>
                <button class="modal-close" id="closePlaylistsModal">&times;</button>
            </div>
            <div class="modal-body">
                <!-- Playlists Section -->
                <div class="playlists-section" id="playlistsSection">
                    <div class="section-header">
                        <h3 class="section-title">Playlists</h3>
                        <div style="display: flex; gap: 10px;">
                            <button class="view-toggle-btn" id="playlistViewToggle">
                                <span id="playlistViewIcon">‚äû</span>
                                <span id="playlistViewText">Grid</span>
                            </button>
                            <button class="create-playlist-btn" id="createPlaylistBtn">
                                + New Playlist
                            </button>
                        </div>
                    </div>
                    <div class="playlists-list" id="playlistsList"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Browse Stations Modal -->
    <div id="browseStationsModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header">
                <h2 class="modal-title">Curated Stations</h2>
                <button class="modal-close" id="closeBrowseStationsModal">&times;</button>
            </div>
            <div class="modal-body">
                <!-- Search -->
                <div class="search-controls">
                    <div class="search-input-container">
                        <input 
                            type="text" 
                            id="stationSearch" 
                            class="search-input" 
                            placeholder="Search stations..."
                        >
                        <button class="clear-search-btn" id="clearSearchBtn" style="display: none;" title="Clear search and filters">
                            ‚úï
                        </button>
                    </div>
                </div>
                
                <!-- Filter Controls -->
                <div class="filter-controls">
                    <div class="filter-container">
                        <button class="filter-btn" id="genreBtn">
                            <span class="filter-btn-label" id="genreLabel">All Genres</span>
                            <span>‚ñº</span>
                        </button>
                        <div class="filter-dropdown" id="genreDropdown">
                            <div class="filter-option active" data-genre="">
                                <span class="filter-option-icon">üéµ</span>
                                <span>All Genres</span>
                            </div>
                        </div>
                    </div>
                    <div class="filter-container">
                        <button class="filter-btn" id="sortBtn">
                            <span class="filter-btn-label" id="sortLabel">Name (A-Z)</span>
                            <span>‚ñº</span>
                        </button>
                        <div class="filter-dropdown" id="sortDropdown">
                            <div class="filter-option active" data-sort="name-asc">
                                <span class="filter-option-icon">üî§</span>
                                <span>Name (A-Z)</span>
                            </div>
                            <div class="filter-option" data-sort="name-desc">
                                <span class="filter-option-icon">üî§</span>
                                <span>Name (Z-A)</span>
                            </div>
                            <div class="filter-option" data-sort="most-played">
                                <span class="filter-option-icon">üî•</span>
                                <span>Most Played</span>
                            </div>
                            <div class="filter-option" data-sort="recent">
                                <span class="filter-option-icon">üïê</span>
                                <span>Recent Songs</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Stations Section -->
                <div class="section-header">
                    <h3 class="section-title">All Stations</h3>
                    <div style="display: flex; gap: 10px;">
                        <button class="view-toggle-btn" id="stationViewToggle">
                            <span id="stationViewIcon">‚äû</span>
                            <span id="stationViewText">Grid</span>
                        </button>
                    </div>
                </div>
                <div class="station-list" id="stationList"></div>

                <!-- Pagination Controls -->
                <div id="curatedStationsPagination" style="display: none; margin-top: 20px; padding-top: 20px; border-top: 1px solid var(--border-color); justify-content: space-between; align-items: center;">
                    <button id="curatedStationsPrevBtn" class="form-btn form-btn-secondary" style="padding: 8px 16px;" disabled>
                        ‚Üê Previous
                    </button>
                    <div id="curatedStationsPageInfo" style="color: var(--text-secondary); font-size: 14px;">
                        Page 1
                    </div>
                    <button id="curatedStationsNextBtn" class="form-btn form-btn-secondary" style="padding: 8px 16px;">
                        Next ‚Üí
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Playlist Detail Modal -->
    <div id="playlistModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title" id="playlistModalTitle">Playlist</h2>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <button class="view-toggle-btn" id="playlistStationViewToggle">
                        <span id="playlistStationViewIcon">‚äû</span>
                        <span id="playlistStationViewText">Grid</span>
                    </button>
                    <button class="modal-close" id="closePlaylistModal">&times;</button>
                </div>
            </div>
            <div id="playlistModalDescription" style="padding: 0 24px 16px 24px; color: var(--text-secondary); font-size: 14px; display: none;"></div>
            <div class="modal-body">
                <div class="station-list" id="playlistStationList"></div>
            </div>
        </div>
    </div>
    
    <!-- Create/Edit Playlist Modal -->
    <div id="playlistFormModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title" id="playlistFormTitle">Create Playlist</h2>
                <button class="modal-close" id="closePlaylistFormModal">&times;</button>
            </div>
            <div class="modal-body">
                <form id="playlistForm">
                    <div class="form-group">
                        <label class="form-label" for="playlistName">Playlist Name</label>
                        <input 
                            type="text" 
                            id="playlistName" 
                            class="form-input" 
                            placeholder="My Favorite Stations"
                            required
                        >
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="playlistDescription">Description (Optional)</label>
                        <textarea 
                            id="playlistDescription" 
                            class="form-textarea" 
                            placeholder="A collection of my favorite stations..."
                        ></textarea>
                    </div>
                    <div class="form-actions">
                        <button type="button" class="form-btn form-btn-secondary" id="cancelPlaylistForm">
                            Cancel
                        </button>
                        <button type="submit" class="form-btn form-btn-primary">
                            Save Playlist
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>
    
    <!-- Station Form Modal (for add/edit station) -->
    <div id="stationFormModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title" id="stationFormTitle">Add Station</h2>
                <button class="modal-close" id="closeStationFormModal">&times;</button>
            </div>
            <div class="modal-body">
                <form id="stationForm">
                    <div class="form-group">
                        <label class="form-label" for="stationName">Station Name</label>
                        <input 
                            type="text" 
                            id="stationFormName" 
                            class="form-input" 
                            placeholder="Station Name"
                            required
                        >
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="stationUrl">Stream URL</label>
                        <input 
                            type="url" 
                            id="stationFormUrl" 
                            class="form-input" 
                            placeholder="https://stream.example.com/radio"
                            required
                        >
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="stationUrlLow">Low Quality URL (Optional)</label>
                        <input 
                            type="url" 
                            id="stationFormUrlLow" 
                            class="form-input" 
                            placeholder="https://stream.example.com/radio-low"
                        >
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="stationUrlHigh">High Quality URL (Optional)</label>
                        <input 
                            type="url" 
                            id="stationFormUrlHigh" 
                            class="form-input" 
                            placeholder="https://stream.example.com/radio-high"
                        >
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="stationCallLetters">Call Letters (Optional)</label>
                        <input 
                            type="text" 
                            id="stationFormCallLetters" 
                            class="form-input" 
                            placeholder="WXYZ"
                        >
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="stationFrequency">Frequency (Optional)</label>
                        <input 
                            type="text" 
                            id="stationFormFrequency" 
                            class="form-input" 
                            placeholder="95.5 FM"
                        >
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="stationWebsiteUrl">Website URL (Optional)</label>
                        <input 
                            type="url" 
                            id="stationFormWebsiteUrl" 
                            class="form-input" 
                            placeholder="https://station.example.com"
                        >
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="stationGenres">Genres</label>
                        <input 
                            type="text" 
                            id="stationFormGenres" 
                            class="form-input" 
                            placeholder="Rock, Pop, Jazz"
                        >
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="stationDescription">Description (Optional)</label>
                        <textarea 
                            id="stationFormDescription" 
                            class="form-input" 
                            placeholder="A brief description of the station..."
                            rows="3"
                            style="resize: vertical; font-family: inherit;"
                        ></textarea>
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="stationIconUpload">Station Artwork</label>
                        <div style="display: flex; flex-direction: column; gap: 10px;">
                            <div id="iconPreview" style="display: none; align-items: center; gap: 10px; padding: 10px; background: var(--input-bg); border-radius: 8px;">
                                <img id="iconPreviewImg" src="" alt="Preview" style="width: 60px; height: 60px; border-radius: 8px; object-fit: cover;">
                                <div style="flex: 1;">
                                    <div id="iconPreviewName" style="font-size: 14px; color: var(--text-primary); font-weight: 500;"></div>
                                    <div id="iconPreviewSize" style="font-size: 12px; color: var(--text-secondary);"></div>
                                </div>
                                <button type="button" id="removeIcon" class="form-btn form-btn-secondary" style="padding: 6px 12px; font-size: 12px;">Remove</button>
                            </div>
                            <input 
                                type="file" 
                                id="stationFormIconUpload" 
                                accept="image/*"
                                style="display: none;"
                            >
                            <button type="button" id="uploadIconBtn" class="form-btn form-btn-secondary" style="width: 100%;">
                                üì∑ Choose Image
                            </button>
                            <input 
                                type="url" 
                                id="stationFormIconUrl" 
                                class="form-input" 
                                placeholder="Or paste image URL"
                            >
                        </div>
                    </div>
                    <div class="form-actions">
                        <button type="button" class="form-btn form-btn-secondary" id="cancelStationForm">
                            Cancel
                        </button>
                        <button type="submit" class="form-btn form-btn-primary">
                            Save Station
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Radio Database Modal -->
    <div id="radioDatabaseModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header">
                <h2 class="modal-title">Radio Database Search</h2>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <button class="view-toggle-btn" id="radioDatabaseViewToggle">
                        <span id="radioDatabaseViewIcon">‚äû</span>
                        <span id="radioDatabaseViewText">Grid</span>
                    </button>
                    <button class="modal-close" id="closeRadioDatabaseModal">&times;</button>
                </div>
            </div>
            <div class="modal-body">
                <!-- Search Interface -->
                <div style="margin-bottom: 20px;">
                    <div class="search-controls">
                        <div class="search-input-container">
                            <input
                                type="text"
                                id="radioDatabaseSearchInput"
                                class="search-input"
                                placeholder="Search by station name, country, language, or tag..."
                            >
                            <button class="clear-search-btn" id="radioDatabaseClearBtn" style="display: none;" title="Clear search and filters">
                                ‚úï
                            </button>
                        </div>
                    </div>
                    <div class="filter-controls" style="margin-top: 10px;">
                        <select id="radioDatabaseCountry" class="form-input">
                            <option value="">All Countries</option>
                        </select>

                        <select id="radioDatabaseLanguage" class="form-input">
                            <option value="">All Languages</option>
                        </select>

                        <select id="radioDatabaseTag" class="form-input">
                            <option value="">All Tags</option>
                        </select>

                        <select id="radioDatabaseSort" class="form-input">
                            <option value="votes">Most Popular</option>
                            <option value="name">Name (A-Z)</option>
                            <option value="clickcount">Most Clicked</option>
                            <option value="bitrate">Highest Bitrate</option>
                            <option value="changetimestamp">Recently Updated</option>
                        </select>
                    </div>

                    <!-- Advanced Filters (Collapsible) -->
                    <div style="margin-top: 15px;">
                        <button id="toggleAdvancedFilters" class="form-btn form-btn-secondary" style="width: 100%; padding: 8px; font-size: 13px;">
                            ‚ñº Advanced Filters
                        </button>
                        <div id="advancedFiltersPanel" style="display: none; margin-top: 10px; padding: 15px; background: var(--modal-bg); border-radius: 8px; border: 1px solid var(--border-color);">
                            <!-- Bitrate Dropdown -->
                            <div style="margin-bottom: 15px;">
                                <label for="bitrateDropdown" style="font-weight: 600; margin-bottom: 8px; color: var(--text-primary); font-size: 14px; display: block;">
                                    Minimum Bitrate
                                </label>
                                <select id="bitrateDropdown" class="form-input" style="width: 100%; padding: 8px; font-size: 14px;" onchange="handleBitrateChange()">
                                    <option value="0">All bitrates</option>
                                    <option value="96">96 kbps+</option>
                                    <option value="128">128 kbps+</option>
                                    <option value="192">192 kbps+</option>
                                    <option value="256">256 kbps+</option>
                                    <option value="320">320 kbps+</option>
                                    <option value="1411">1411 kbps+</option>
                                </select>
                            </div>

                            <!-- Include Unknown Bitrates Checkbox -->
                            <div style="margin-bottom: 15px;">
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 14px;">
                                    <input type="checkbox" id="includeUnknownBitrates" checked onchange="handleIncludeUnknownChange()" style="cursor: pointer;">
                                    <span>Include Unknown bitrates</span>
                                </label>
                            </div>

                            <!-- Filter out HLS Streams Checkbox -->
                            <div>
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 14px;">
                                    <input type="checkbox" id="filterOutHLS" onchange="handleFilterHLSChange()" style="cursor: pointer;">
                                    <span>Filter out HLS streams</span>
                                </label>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Loading Indicator -->
                <div id="radioDatabaseLoading" style="display: none; text-align: center; padding: 40px;">
                    <div style="font-size: 18px; color: var(--text-secondary);">Searching...</div>
                </div>

                <!-- Error Message -->
                <div id="radioDatabaseError" style="display: none; padding: 20px; background: var(--error-bg, #fee); border-radius: 12px; color: var(--error-text, #c00); margin-bottom: 20px;">
                </div>

                <!-- Results Container -->
                <div id="radioDatabaseResults" class="station-list">
                    <div style="text-align: center; padding: 40px; color: var(--text-secondary);">
                        Loading radio stations...
                    </div>
                </div>

                <!-- Pagination Controls -->
                <div id="radioDatabasePagination" style="display: none; margin-top: 20px; padding-top: 20px; border-top: 1px solid var(--border-color); justify-content: space-between; align-items: center;">
                    <button id="radioDatabasePrevBtn" class="form-btn form-btn-secondary" style="padding: 8px 16px;" disabled>
                        ‚Üê Previous
                    </button>
                    <div id="radioDatabasePageInfo" style="color: var(--text-secondary); font-size: 14px;">
                        Page 1
                    </div>
                    <button id="radioDatabaseNextBtn" class="form-btn form-btn-secondary" style="padding: 8px 16px;">
                        Next ‚Üí
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Playlist Selector Modal for Radio Browser -->
    <div id="playlistSelectorModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h2 class="modal-title" id="playlistSelectorTitle">Add to Playlist</h2>
                <button class="modal-close" id="closePlaylistSelectorModal">&times;</button>
            </div>
            <div class="modal-body">
                <div id="playlistSelectorList" style="max-height: 400px; overflow-y: auto;">
                    <!-- Playlists will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Curated Playlist Selector Modal -->
    <div id="curatedPlaylistSelectorModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h2 class="modal-title">Add to Curated Playlist</h2>
                <button class="modal-close" id="closeCuratedPlaylistSelectorModal">&times;</button>
            </div>
            <div class="modal-body">
                <div id="curatedPlaylistSelectorList" style="max-height: 400px; overflow-y: auto;">
                    <!-- Curated playlists will be populated here -->
                </div>
                <button id="createNewCuratedPlaylistBtn" class="form-btn form-btn-primary" style="width: 100%; margin-top: 16px;">
                    ‚ûï Create New Curated Playlist
                </button>
            </div>
        </div>
    </div>

    <!-- Curated Playlist Form Modal -->
    <div id="curatedPlaylistFormModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h2 class="modal-title" id="curatedPlaylistFormTitle">Create Curated Playlist</h2>
                <button class="modal-close" id="closeCuratedPlaylistFormModal">&times;</button>
            </div>
            <div class="modal-body">
                <form id="curatedPlaylistForm">
                    <div class="form-group">
                        <label for="curatedPlaylistName">Playlist Name *</label>
                        <input type="text" id="curatedPlaylistName" class="form-input" required>
                    </div>
                    <div class="form-group">
                        <label for="curatedPlaylistType">Type *</label>
                        <select id="curatedPlaylistType" class="form-input" required>
                            <option value="curated_playlist">Curated Playlist (shows collage)</option>
                            <option value="multi_channel_radio">Multi-Channel Radio (shows single icon)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="curatedPlaylistDescription">Description</label>
                        <textarea id="curatedPlaylistDescription" class="form-input" rows="3"></textarea>
                    </div>
                    <div class="form-actions">
                        <button type="button" class="form-btn form-btn-secondary" id="cancelCuratedPlaylistFormBtn">Cancel</button>
                        <button type="submit" class="form-btn form-btn-primary">Save</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Admin Preset Searches Modal -->
    <div id="adminPresetSearchesModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 900px;">
            <div class="modal-header">
                <h2 class="modal-title">Manage Preset Searches</h2>
                <button class="modal-close" id="closeAdminPresetSearchesModal">&times;</button>
            </div>
            <div class="modal-body">
                <div style="margin-bottom: 20px;">
                    <button id="addNewPresetSearchBtn" class="btn" style="background: var(--accent-color); color: var(--accent-button-text); padding: 10px 20px; border: none; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 600;">
                        + Add New Preset Search
                    </button>
                </div>
                <div id="presetSearchesList"></div>
            </div>
        </div>
    </div>

    <!-- Admin Curated Playlists Modal -->
    <div id="adminCuratedPlaylistsModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 900px;">
            <div class="modal-header">
                <h2 class="modal-title">Manage Curated Playlists</h2>
                <button class="modal-close" id="closeAdminCuratedPlaylistsModal">&times;</button>
            </div>
            <div class="modal-body">
                <div style="margin-bottom: 20px;">
                    <button id="addNewCuratedPlaylistBtn" class="btn" style="background: var(--accent-color); color: var(--accent-button-text); padding: 10px 20px; border: none; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 600;">
                        + Add New Curated Playlist
                    </button>
                </div>
                <div id="curatedPlaylistsList"></div>
            </div>
        </div>
    </div>

    <!-- Preset Search Form Modal -->
    <div id="presetSearchFormModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <h2 class="modal-title" id="presetSearchFormTitle">Create Preset Search</h2>
                <button class="modal-close" id="closePresetSearchFormModal">&times;</button>
            </div>
            <div class="modal-body">
                <form id="presetSearchForm">
                    <div class="form-group">
                        <label for="presetSearchName">Name *</label>
                        <input type="text" id="presetSearchName" class="form-input" placeholder="e.g., Rock Music, Jazz Stations, USA Radio" required>
                    </div>
                    <div class="form-group">
                        <label for="presetSearchStationName">Station Name</label>
                        <input type="text" id="presetSearchStationName" class="form-input" placeholder="e.g., BBC Radio, NPR (optional)">
                        <small style="color: var(--text-secondary); font-size: 12px;">Search for stations with this name</small>
                    </div>
                    <div class="form-group">
                        <label for="presetSearchCountry">Country</label>
                        <input type="text" id="presetSearchCountry" class="form-input" placeholder="e.g., United States, United Kingdom (optional)">
                        <small style="color: var(--text-secondary); font-size: 12px;">Leave blank to search all countries</small>
                    </div>
                    <div class="form-group">
                        <label for="presetSearchLanguage">Language</label>
                        <input type="text" id="presetSearchLanguage" class="form-input" placeholder="e.g., english, spanish (optional)">
                        <small style="color: var(--text-secondary); font-size: 12px;">Leave blank to search all languages</small>
                    </div>
                    <div class="form-group">
                        <label for="presetSearchTags">Tags</label>
                        <input type="text" id="presetSearchTags" class="form-input" placeholder="e.g., rock, jazz, news (optional)">
                        <small style="color: var(--text-secondary); font-size: 12px;">Comma-separated tags</small>
                    </div>
                    <div class="form-group">
                        <label for="presetSearchImageUrl">Image URL</label>
                        <input type="url" id="presetSearchImageUrl" class="form-input" placeholder="https://example.com/image.jpg (optional)">
                    </div>
                    <div class="form-group">
                        <label for="presetSearchDescription">Description</label>
                        <textarea id="presetSearchDescription" class="form-input" rows="3" placeholder="Brief description of this preset search (optional)"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="presetSearchDisplayOrder">Display Order</label>
                        <input type="number" id="presetSearchDisplayOrder" class="form-input" value="0" min="0">
                        <small style="color: var(--text-secondary); font-size: 12px;">Lower numbers appear first</small>
                    </div>
                    <div class="form-actions">
                        <button type="button" class="form-btn form-btn-secondary" id="cancelPresetSearchFormBtn">Cancel</button>
                        <button type="submit" class="form-btn form-btn-primary">Save</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Bottom Navigation Bar -->
    <nav class="bottom-nav">
        <button id="bottomNavOverview" class="bottom-nav-btn" title="Home">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M3 9L12 2L21 9V20C21 20.5304 20.7893 21.0391 20.4142 21.4142C20.0391 21.7893 19.5304 22 19 22H5C4.46957 22 3.96086 21.7893 3.58579 21.4142C3.21071 21.0391 3 20.5304 3 20V9Z" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
                <path d="M9 22V12H15V22" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            <span>Home</span>
        </button>
        <button id="bottomNavDiscover" class="bottom-nav-btn" title="Discover">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="none" stroke="currentColor">
                <circle cx="12" cy="12" r="10" stroke-width="2"/>
                <circle cx="12" cy="12" r="3" fill="currentColor"/>
                <path d="M12 2v3M12 19v3M2 12h3M19 12h3" stroke-width="2" stroke-linecap="round"/>
                <path d="M17 7l-5 5" stroke-width="2" stroke-linecap="round"/>
            </svg>
            <span>Discover</span>
        </button>
        <button id="bottomNavMenu" class="bottom-nav-btn" title="Menu">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M4 6H20M4 12H20M4 18H20" stroke-width="2" stroke-linecap="round"/>
            </svg>
            <span>Menu</span>
        </button>
    </nav>

    <script>
        (function() {
        // ======================
        // GLOBAL VARIABLES
        // ======================

        // Musical note icon SVG for stations without icons
        const MUSIC_NOTE_ICON = `<svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg" style="width: 100%; height: 100%;">
            <path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/>
        </svg>`;

        // Musical note icon as data URI for use in img src attributes (onerror fallback)
        const MUSIC_NOTE_DATA_URI = 'data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIGZpbGw9IiM2NjdlZWEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDN2MTAuNTVjLS41OS0uMzQtMS4yNy0uNTUtMi0uNTUtMi4yMSAwLTQgMS43OS00IDRzMS43OSA0IDQgNCA0LTEuNzkgNC00VjdoNFYzaC02eiIvPjwvc3ZnPg==';

        // Verified checkmark icon for curated stations
        const VERIFIED_ICON = `<svg viewBox="0 0 24 24" fill="#667eea" xmlns="http://www.w3.org/2000/svg" style="width: 14px; height: 14px; vertical-align: text-top; margin-right: 4px;">
            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
        </svg>`;

        // LrcLib API - No access token needed

        let player = null;
        let hlsPlayer = null;
        let audioElement = null;
        let simpleAudioPlayer = null;
        let metadataOnlyPlayer = null; // Silent player for metadata during Chromecast
        let metadataOnlyPlayerUrl = null; // Track the URL currently being used by metadata-only player
        let metadataOnlyPlayerIntentionalStop = false; // Track if stop was intentional
        let metadataOnlyPlayerRetryCount = 0; // Track consecutive restart attempts
        let metadataOnlyPlayerMaxRetries = 5; // Maximum number of restart attempts
        let metadataOnlyPlayerRetryTimeoutId = null; // Track pending retry timeout
        let metadataOnlyPlayerErrorCount = 0; // Track consecutive errors from onError handler
        let metadataOnlyPlayerMaxErrors = 3; // Maximum errors before giving up
        let metadataOnlyPlayerWaitingTimeoutId = null; // Track timeout for stuck 'waiting' state
        let metadataOnlyPlayerWaitingTimeout = 30000; // 30 seconds timeout for waiting state
        let metadataOnlyPlayerRefreshIntervalId = null; // Track periodic refresh interval
        let metadataOnlyPlayerRefreshInterval = 10000; // Refresh metadata player every 10 seconds to keep in sync
        let currentPlaybackAbortController = null; // For cancelling ongoing connection attempts

        // CORS proxy configuration (shared between audio player and metadata player)
        const corsProxies = [
            // Self-hosted CORS proxies (highest priority):
            { name: 'cloudflare-worker', url: (streamUrl) => `https://streamwave-cors-proxy.keith-e-dragon.workers.dev/${streamUrl}` },
            { name: 'streamwave-render', url: (streamUrl) => `https://streamwave-radio.onrender.com/${streamUrl}` },

            // Public fallback proxies (may be unreliable or rate-limited)
            { name: 'corsproxy.io', url: (streamUrl) => `https://corsproxy.io/?${encodeURIComponent(streamUrl)}` },
            { name: 'api.allorigins.win', url: (streamUrl) => `https://api.allorigins.win/raw?url=${encodeURIComponent(streamUrl)}` },
            { name: 'cors-anywhere (public)', url: (streamUrl) => `https://cors-anywhere.herokuapp.com/${streamUrl}` }
        ];
        let isPlaying = false;
        let isPaused = false;
        let simplePlayerReloading = false; // Flag to suppress errors during stream switching
        let currentStation = null;
        let stations = [];
        let filteredStations = [];
        let playlists = [];
        let curatedPlaylists = []; // Admin-curated playlists
        let currentPlaylist = null;
        let lastOpenedModal = null;
        let navigationHistory = []; // Stack to track modal navigation history
        let pendingPlaylistSelectorContext = null; // Track context when creating playlist from selector
        let pendingCuratedPlaylistStation = null; // Track station to be added to curated playlist
        let pendingCuratedPlaylistIsExternal = false; // Track if pending station is external
        let editingCuratedPlaylistId = null; // Track ID of curated playlist being edited

        // Radio Database pagination
        let radioDatabaseCurrentPage = 1;
        let radioDatabaseItemsPerPage = 50;
        let radioDatabaseTotalResults = 0;
        let radioDatabaseRawResults = []; // Store unfiltered results
        let radioDatabaseMinBitrate = 0; // Minimum bitrate filter (0 = all)
        let radioDatabaseIncludeUnknown = true; // Include stations with unknown/0 bitrate
        let radioDatabaseFilterOutHLS = false; // Filter out HLS streams

        // Curated Stations pagination
        let curatedStationsCurrentPage = 1;
        let curatedStationsItemsPerPage = 20;
        let curatedStationsTotalResults = 0;
        let currentTrack = {
            title: null,
            artist: null,
            album: null,
            artworkUrl: null,
            lyrics: null,
            lyricsUrl: null,
            hasLyrics: false
        };
        let likedTracks = [];
        let recentTracks = [];
        let autoFallbackEnabled = true;
        let hasFallbackAttempted = false;
        let editingStationId = null;
        let editingPlaylistId = null;
        let currentSortMethod = 'name-asc';
        let currentGenreFilter = '';
        let stationViewMode = 'list';
        let playlistViewMode = 'list';
        let playlistStationViewMode = 'list';
        let radioDatabaseViewMode = 'list';
        
        // Settings
        let playbackMode = 'live'; // 'live' or 'simple'
        let quality = 'standard'; // 'high' or 'standard'
        let selectedQuality = 'standard'; // Current quality selection for streams

        // ======================
        // Radio Database State Persistence
        // ======================

        // Save radio database state to sessionStorage
        function saveRadioDatabaseState() {
            const state = {
                searchTerm: radioDatabaseSearchInput.value,
                country: radioDatabaseCountry.value,
                language: radioDatabaseLanguage.value,
                tag: radioDatabaseTag.value,
                sortBy: radioDatabaseSort.value,
                currentPage: radioDatabaseCurrentPage,
                viewMode: radioDatabaseViewMode,
                minBitrate: radioDatabaseMinBitrate,
                includeUnknown: radioDatabaseIncludeUnknown,
                filterOutHLS: radioDatabaseFilterOutHLS
            };
            sessionStorage.setItem('radioDatabaseState', JSON.stringify(state));
        }

        // Load radio database state from sessionStorage
        function loadRadioDatabaseState() {
            const stateJson = sessionStorage.getItem('radioDatabaseState');
            if (stateJson) {
                try {
                    return JSON.parse(stateJson);
                } catch (error) {
                    console.error('Error parsing radio database state:', error);
                    return null;
                }
            }
            return null;
        }

        // Clear radio database state from sessionStorage
        function clearRadioDatabaseState() {
            sessionStorage.removeItem('radioDatabaseState');
        }

        // ======================
        // DOM Elements
        // ======================

        // Hamburger Menu
        const overviewBtn = document.getElementById('overviewBtn');
        const hamburgerMenuBtn = document.getElementById('hamburgerMenuBtn');
        const hamburgerMenuModal = document.getElementById('hamburgerMenuModal');
        const closeHamburgerMenuModal = document.getElementById('closeHamburgerMenuModal');
        const settingsMenuBtn = document.getElementById('settingsMenuBtn');

        // Station Display
        const stationDisplay = document.getElementById('stationDisplay');
        const stationDisplayIcon = document.getElementById('stationDisplayIcon');
        const stationDisplayName = document.getElementById('stationDisplayName');

        // Modals
        const playlistsModal = document.getElementById('playlistsModal');
        const closePlaylistsModal = document.getElementById('closePlaylistsModal');
        const browseStationsModal = document.getElementById('browseStationsModal');
        const closeBrowseStationsModal = document.getElementById('closeBrowseStationsModal');
        const settingsModal = document.getElementById('settingsModal');
        const closeSettingsModal = document.getElementById('closeSettingsModal');
        const authBtn = document.getElementById('authBtn');
        const overviewModal = document.getElementById('overviewModal');
        const closeOverviewModal = document.getElementById('closeOverviewModal');
        const discoverModal = document.getElementById('discoverModal');
        const closeDiscoverModal = document.getElementById('closeDiscoverModal');
        const stationInfoModal = document.getElementById('stationInfoModal');
        const closeStationInfoModal = document.getElementById('closeStationInfoModal');

        const stationList = document.getElementById('stationList');
        const stationSearch = document.getElementById('stationSearch');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const playIcon = playPauseBtn.querySelector('.play-icon');
        const pauseIcon = playPauseBtn.querySelector('.pause-icon');
        const artworkContainer = document.getElementById('artworkContainer');
        const artworkContainerPortrait = document.getElementById('artworkContainerPortrait');

        // Helper function to update both artwork containers
        function updateArtwork(html) {
            // Update artwork content
            artworkContainer.innerHTML = html;
            artworkContainerPortrait.innerHTML = html;
        }
        const metadataDiv = document.getElementById('metadataSection');
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        
        // Playlist elements
        const playlistsSection = document.getElementById('playlistsSection');
        const playlistsList = document.getElementById('playlistsList');
        const createPlaylistBtn = document.getElementById('createPlaylistBtn');
        const playlistModal = document.getElementById('playlistModal');
        const closePlaylistModal = document.getElementById('closePlaylistModal');
        const playlistModalTitle = document.getElementById('playlistModalTitle');
        const playlistModalDescription = document.getElementById('playlistModalDescription');
        const playlistStationList = document.getElementById('playlistStationList');
        
        // Sort and genre filter elements
        const genreBtn = document.getElementById('genreBtn');
        const genreDropdown = document.getElementById('genreDropdown');
        const genreLabel = document.getElementById('genreLabel');
        const sortBtn = document.getElementById('sortBtn');
        const sortDropdown = document.getElementById('sortDropdown');
        const sortLabel = document.getElementById('sortLabel');
        
        // View toggle elements
        const stationViewToggle = document.getElementById('stationViewToggle');
        const stationViewIcon = document.getElementById('stationViewIcon');
        const stationViewText = document.getElementById('stationViewText');
        const playlistViewToggle = document.getElementById('playlistViewToggle');
        const playlistViewIcon = document.getElementById('playlistViewIcon');
        const playlistViewText = document.getElementById('playlistViewText');
        const playlistStationViewToggle = document.getElementById('playlistStationViewToggle');
        const playlistStationViewIcon = document.getElementById('playlistStationViewIcon');
        const playlistStationViewText = document.getElementById('playlistStationViewText');
        
        // Playlist form elements
        const playlistFormModal = document.getElementById('playlistFormModal');
        const closePlaylistFormModal = document.getElementById('closePlaylistFormModal');
        const playlistFormTitle = document.getElementById('playlistFormTitle');
        const playlistForm = document.getElementById('playlistForm');
        const playlistName = document.getElementById('playlistName');
        const playlistDescription = document.getElementById('playlistDescription');
        const cancelPlaylistForm = document.getElementById('cancelPlaylistForm');
        
        // Liked tracks elements
        const likedTracksModal = document.getElementById('likedTracksModal');
        const closeLikedTracksModal = document.getElementById('closeLikedTracksModal');
        const likedTracksList = document.getElementById('likedTracksList');
        const clearAllLikesBtn = document.getElementById('clearAllLikesBtn');

        // Radio Database elements
        const radioDatabaseModal = document.getElementById('radioDatabaseModal');
        const closeRadioDatabaseModal = document.getElementById('closeRadioDatabaseModal');
        const radioDatabaseSearchInput = document.getElementById('radioDatabaseSearchInput');
        const radioDatabaseCountry = document.getElementById('radioDatabaseCountry');
        const radioDatabaseLanguage = document.getElementById('radioDatabaseLanguage');
        const radioDatabaseTag = document.getElementById('radioDatabaseTag');
        const radioDatabaseSort = document.getElementById('radioDatabaseSort');
        const radioDatabaseSearchBtn = document.getElementById('radioDatabaseSearchBtn');
        const radioDatabaseLoading = document.getElementById('radioDatabaseLoading');
        const radioDatabaseError = document.getElementById('radioDatabaseError');
        const radioDatabaseResults = document.getElementById('radioDatabaseResults');
        const radioDatabasePagination = document.getElementById('radioDatabasePagination');
        const radioDatabasePrevBtn = document.getElementById('radioDatabasePrevBtn');
        const radioDatabaseNextBtn = document.getElementById('radioDatabaseNextBtn');
        const radioDatabasePageInfo = document.getElementById('radioDatabasePageInfo');
        const toggleAdvancedFilters = document.getElementById('toggleAdvancedFilters');
        const advancedFiltersPanel = document.getElementById('advancedFiltersPanel');
        const bitrateDropdown = document.getElementById('bitrateDropdown');
        const includeUnknownBitrates = document.getElementById('includeUnknownBitrates');
        const filterOutHLS = document.getElementById('filterOutHLS');

        // Playlist Selector Modal elements
        const playlistSelectorModal = document.getElementById('playlistSelectorModal');
        const closePlaylistSelectorModal = document.getElementById('closePlaylistSelectorModal');
        const playlistSelectorTitle = document.getElementById('playlistSelectorTitle');
        const playlistSelectorList = document.getElementById('playlistSelectorList');

        // Curated Playlist Selector Modal elements
        const curatedPlaylistSelectorModal = document.getElementById('curatedPlaylistSelectorModal');
        const closeCuratedPlaylistSelectorModal = document.getElementById('closeCuratedPlaylistSelectorModal');
        const curatedPlaylistSelectorList = document.getElementById('curatedPlaylistSelectorList');
        const createNewCuratedPlaylistBtn = document.getElementById('createNewCuratedPlaylistBtn');

        // Curated Playlist Form Modal elements
        const curatedPlaylistFormModal = document.getElementById('curatedPlaylistFormModal');
        const closeCuratedPlaylistFormModal = document.getElementById('closeCuratedPlaylistFormModal');
        const curatedPlaylistFormTitle = document.getElementById('curatedPlaylistFormTitle');
        const curatedPlaylistForm = document.getElementById('curatedPlaylistForm');
        const curatedPlaylistName = document.getElementById('curatedPlaylistName');
        const curatedPlaylistType = document.getElementById('curatedPlaylistType');
        const curatedPlaylistDescription = document.getElementById('curatedPlaylistDescription');
        const cancelCuratedPlaylistFormBtn = document.getElementById('cancelCuratedPlaylistFormBtn');

        // ======================
        // LIKED TRACKS FUNCTIONS
        // ======================

        // Note: loadLikedTracks, saveLikedTracks, addLikedTrack, removeLikedTrack
        // are now provided by radio-auth.js and available as window functions
        // They automatically handle both guest (localStorage) and authenticated (Supabase) modes
        
        // Check if current track is liked
        async function isCurrentTrackLiked() {
            if (!currentTrack.title || !currentTrack.artist) return false;
            return await window.isTrackLiked(currentTrack.title, currentTrack.artist);
        }
        
        // Toggle like for current track
        async function toggleLikeTrack() {
            if (!currentTrack.title || !currentTrack.artist) return;

            const isLiked = await window.isTrackLiked(currentTrack.title, currentTrack.artist);

            if (isLiked) {
                // Unlike - need to find the track object first
                const likedTracks = await window.loadLikedTracks();
                const track = likedTracks.find(t =>
                    t.title === currentTrack.title && t.artist === currentTrack.artist
                );
                if (track) {
                    await window.removeLikedTrack(track);
                }
            } else {
                // Like - use addLikedTrack from radio-auth.js
                await window.addLikedTrack({
                    title: currentTrack.title,
                    artist: currentTrack.artist,
                    album: currentTrack.album || '',
                    artworkUrl: currentTrack.artworkUrl || '',
                    station: currentStation ? currentStation.name : 'Unknown Station'
                });
            }

            await updateLikeButton();

            // Close the Now Playing modal after liking/unliking
            closeNowPlayingModal();
        }

        // Expose to global scope for onclick handlers
        window.toggleLikeTrack = toggleLikeTrack;

        // Update like button state
        async function updateLikeButton() {
            // Update modal like button if it exists
            const modalLikeBtn = document.getElementById('modalLikeBtn');

            if (!currentTrack.title || !currentTrack.artist) {
                if (modalLikeBtn) {
                    modalLikeBtn.classList.add('disabled');
                    modalLikeBtn.querySelector('span').textContent = 'Like This Song';
                }
                return;
            }

            if (modalLikeBtn) {
                modalLikeBtn.classList.remove('disabled');
            }

            const isLiked = await isCurrentTrackLiked();
            if (modalLikeBtn) {
                if (isLiked) {
                    modalLikeBtn.classList.add('liked');
                    modalLikeBtn.querySelector('span').textContent = 'Unlike This Song';
                } else {
                    modalLikeBtn.classList.remove('liked');
                    modalLikeBtn.querySelector('span').textContent = 'Like This Song';
                }
            }
        }

        // ======================
        // RECENT TRACKS MANAGEMENT
        // ======================

        // Note: loadRecentTracks, saveRecentTracks, addToRecentTracks, clearAllRecentTracks
        // are now provided by radio-auth.js and available as window functions
        // They automatically handle both guest (localStorage) and authenticated (Supabase) modes

        const MAX_RECENT_TRACKS = 15;
        
        // Display recent tracks in modal
        async function displayRecentTracks() {
            const rawTracks = await window.loadRecentTracks();
            const recentTracks = rawTracks.map(t => window.normalizeTrack(t));
            const recentTracksList = document.getElementById('recentTracksList');
            const clearRecentTracksBtn = document.getElementById('clearRecentTracksBtn');
            const copyAllRecentBtn = document.getElementById('copyAllRecentBtn');
            const downloadRecentBtn = document.getElementById('downloadRecentBtn');

            if (recentTracks.length === 0) {
                recentTracksList.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üïê</div>
                        <div class="empty-state-text">No recent tracks yet. Start listening to see your recently played tracks here!</div>
                    </div>
                `;
                clearRecentTracksBtn.style.display = 'none';
                copyAllRecentBtn.style.display = 'none';
                downloadRecentBtn.style.display = 'none';
            } else {
                clearRecentTracksBtn.style.display = 'block';
                copyAllRecentBtn.style.display = 'block';
                downloadRecentBtn.style.display = 'block';
                recentTracksList.innerHTML = rawTracks.map((track, index) => {
                    const normalizedTrack = window.normalizeTrack(track);
                    const date = new Date(normalizedTrack.timestamp);
                    const timeAgo = getTimeAgo(date);

                    return `
                        <div class="liked-track-item">
                            ${normalizedTrack.artworkUrl ?
                                `<img class="liked-track-art" src="${normalizedTrack.artworkUrl}" alt="${escapeHtml(normalizedTrack.title)}">` :
                                `<div class="liked-track-art">‚ô™</div>`
                            }
                            <div class="liked-track-info">
                                <div class="liked-track-title">${escapeHtml(normalizedTrack.title)}</div>
                                <div class="liked-track-artist">${escapeHtml(normalizedTrack.artist)}</div>
                                <div class="liked-track-meta">
                                    ${escapeHtml(normalizedTrack.station)} ‚Ä¢ ${timeAgo}
                                </div>
                            </div>
                            <button class="copy-track-btn" onclick="copySingleTrack('${escapeHtml(normalizedTrack.artist)}', '${escapeHtml(normalizedTrack.title)}', this)">
                                <svg width="14" height="14" viewBox="0 0 256 256" style="vertical-align: middle;">
                                    <path fill="currentColor" d="M216 32H88a16 16 0 0 0-16 16v40H40a16 16 0 0 0-16 16v120a16 16 0 0 0 16 16h128a16 16 0 0 0 16-16v-40h32a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16zm-48 192H40V104h128zm48-48h-32V104a16 16 0 0 0-16-16H88V48h128z"/>
                                </svg>
                            </button>
                        </div>
                    `;
                }).join('');
            }
        }
        
        // Clear all recent tracks (wrapper with confirmation dialog)
        async function handleClearRecentTracks() {
            console.log('üîµ handleClearRecentTracks function called');
            console.log('üîµ About to show confirm dialog');
            const userConfirmed = confirm('Are you sure you want to clear all recently played tracks?');
            console.log('üîµ User clicked:', userConfirmed ? 'OK' : 'Cancel');

            if (userConfirmed) {
                try {
                    console.log('üîµ Calling window.clearAllRecentTracks()...');
                    await window.clearAllRecentTracks();
                    console.log('üîµ window.clearAllRecentTracks() completed successfully');

                    console.log('üîµ Refreshing display...');
                    await displayRecentTracks();
                    console.log('üîµ Display refreshed successfully');
                } catch (error) {
                    console.error('‚ùå Failed to clear recent tracks:', error);
                    alert('Failed to clear recent tracks. Please check the console for details.');
                }
            } else {
                console.log('üîµ User cancelled, no action taken');
            }
        }
        
        // ======================
        // COPY TRACK FUNCTIONS
        // ======================
        
        // Copy single track to clipboard
        async function copySingleTrack(artist, title, buttonElement) {
            const text = `${artist} - ${title}`;
            
            try {
                await navigator.clipboard.writeText(text);
                
                // Visual feedback - replace icon with checkmark
                const originalHTML = buttonElement.innerHTML;
                buttonElement.innerHTML = '<svg width="14" height="14" viewBox="0 0 256 256" style="vertical-align: middle;"><path fill="currentColor" d="M229.66 77.66l-128 128a8 8 0 0 1-11.32 0l-56-56a8 8 0 0 1 11.32-11.32L96 188.69 218.34 66.34a8 8 0 0 1 11.32 11.32z"/></svg>';
                buttonElement.classList.add('copied');
                
                setTimeout(() => {
                    buttonElement.innerHTML = originalHTML;
                    buttonElement.classList.remove('copied');
                }, 2000);
            } catch (err) {
                console.error('Failed to copy:', err);
                alert('Failed to copy to clipboard');
            }
        }

        // Expose to global scope for onclick handlers
        window.copySingleTrack = copySingleTrack;

        // Copy all liked tracks to clipboard
        async function copyAllLikedTracks() {
            const likedTracks = await window.loadLikedTracks();

            if (likedTracks.length === 0) {
                alert('No liked tracks to copy');
                return;
            }

            const text = likedTracks.map(track =>
                `${track.artist} - ${track.title}`
            ).join('\n');

            try {
                await navigator.clipboard.writeText(text);

                // Visual feedback
                const btn = document.getElementById('copyAllLikedBtn');
                const originalHTML = btn.innerHTML;
                btn.innerHTML = '<svg width="16" height="16" viewBox="0 0 256 256" style="vertical-align: middle; margin-right: 6px;"><path fill="currentColor" d="M229.66 77.66l-128 128a8 8 0 0 1-11.32 0l-56-56a8 8 0 0 1 11.32-11.32L96 188.69 218.34 66.34a8 8 0 0 1 11.32 11.32z"/></svg>Copied!';
                btn.style.background = 'rgba(76, 175, 80, 0.3)';
                btn.style.borderColor = 'rgba(76, 175, 80, 0.5)';
                btn.style.color = '#4caf50';

                setTimeout(() => {
                    btn.innerHTML = originalHTML;
                    btn.style.background = '';
                    btn.style.borderColor = '';
                    btn.style.color = '';
                }, 2000);
            } catch (err) {
                console.error('Failed to copy:', err);
                alert('Failed to copy to clipboard');
            }
        }
        
        // Copy all recent tracks to clipboard
        async function copyAllRecentTracks() {
            const recentTracks = await window.loadRecentTracks();

            if (recentTracks.length === 0) {
                alert('No recent tracks to copy');
                return;
            }

            const text = recentTracks.map(track =>
                `${track.artist} - ${track.title}`
            ).join('\n');

            try {
                await navigator.clipboard.writeText(text);

                // Visual feedback
                const btn = document.getElementById('copyAllRecentBtn');
                const originalHTML = btn.innerHTML;
                btn.innerHTML = '<svg width="16" height="16" viewBox="0 0 256 256" style="vertical-align: middle; margin-right: 6px;"><path fill="currentColor" d="M229.66 77.66l-128 128a8 8 0 0 1-11.32 0l-56-56a8 8 0 0 1 11.32-11.32L96 188.69 218.34 66.34a8 8 0 0 1 11.32 11.32z"/></svg>Copied!';
                btn.style.background = 'rgba(76, 175, 80, 0.3)';
                btn.style.borderColor = 'rgba(76, 175, 80, 0.5)';
                btn.style.color = '#4caf50';

                setTimeout(() => {
                    btn.innerHTML = originalHTML;
                    btn.style.background = '';
                    btn.style.borderColor = '';
                    btn.style.color = '';
                }, 2000);
            } catch (err) {
                console.error('Failed to copy:', err);
                alert('Failed to copy to clipboard');
            }
        }
        
        // Download liked tracks as text file
        async function downloadLikedTracksFile() {
            const likedTracks = await window.loadLikedTracks();

            if (likedTracks.length === 0) {
                alert('No liked tracks to download');
                return;
            }

            const text = likedTracks.map(track =>
                `${track.artist} - ${track.title}`
            ).join('\n');

            // Create blob and download
            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `liked-tracks-${new Date().toISOString().split('T')[0]}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            // Visual feedback
            const btn = document.getElementById('downloadLikedBtn');
            const originalHTML = btn.innerHTML;
            btn.innerHTML = '<svg width="16" height="16" viewBox="0 0 256 256" style="vertical-align: middle; margin-right: 6px;"><path fill="currentColor" d="M229.66 77.66l-128 128a8 8 0 0 1-11.32 0l-56-56a8 8 0 0 1 11.32-11.32L96 188.69 218.34 66.34a8 8 0 0 1 11.32 11.32z"/></svg>Downloaded!';
            btn.style.background = 'rgba(76, 175, 80, 0.3)';
            btn.style.borderColor = 'rgba(76, 175, 80, 0.5)';
            btn.style.color = '#4caf50';

            setTimeout(() => {
                btn.innerHTML = originalHTML;
                btn.style.background = '';
                btn.style.borderColor = '';
                btn.style.color = '';
            }, 2000);
        }
        
        // Download recent tracks as text file
        async function downloadRecentTracksFile() {
            const recentTracks = await window.loadRecentTracks();

            if (recentTracks.length === 0) {
                alert('No recent tracks to download');
                return;
            }

            const text = recentTracks.map(track =>
                `${track.artist} - ${track.title}`
            ).join('\n');

            // Create blob and download
            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `recent-tracks-${new Date().toISOString().split('T')[0]}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            // Visual feedback
            const btn = document.getElementById('downloadRecentBtn');
            const originalHTML = btn.innerHTML;
            btn.innerHTML = '<svg width="16" height="16" viewBox="0 0 256 256" style="vertical-align: middle; margin-right: 6px;"><path fill="currentColor" d="M229.66 77.66l-128 128a8 8 0 0 1-11.32 0l-56-56a8 8 0 0 1 11.32-11.32L96 188.69 218.34 66.34a8 8 0 0 1 11.32 11.32z"/></svg>Downloaded!';
            btn.style.background = 'rgba(76, 175, 80, 0.3)';
            btn.style.borderColor = 'rgba(76, 175, 80, 0.5)';
            btn.style.color = '#4caf50';

            setTimeout(() => {
                btn.innerHTML = originalHTML;
                btn.style.background = '';
                btn.style.borderColor = '';
                btn.style.color = '';
            }, 2000);
        }
        
        // Display liked tracks in modal
        async function displayLikedTracks() {
            const rawTracks = await window.loadLikedTracks();
            const likedTracks = rawTracks.map(t => window.normalizeTrack(t));
            const copyAllLikedBtn = document.getElementById('copyAllLikedBtn');
            const downloadLikedBtn = document.getElementById('downloadLikedBtn');

            if (likedTracks.length === 0) {
                likedTracksList.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">‚ô°</div>
                        <div class="empty-state-text">No liked tracks yet. Like a track while listening to save it here!</div>
                    </div>
                `;
                clearAllLikesBtn.style.display = 'none';
                copyAllLikedBtn.style.display = 'none';
                downloadLikedBtn.style.display = 'none';
            } else {
                clearAllLikesBtn.style.display = 'block';
                copyAllLikedBtn.style.display = 'block';
                downloadLikedBtn.style.display = 'block';
                likedTracksList.innerHTML = rawTracks.map((track, index) => {
                    const normalizedTrack = window.normalizeTrack(track);
                    const date = new Date(normalizedTrack.timestamp);
                    const timeAgo = getTimeAgo(date);

                    return `
                        <div class="liked-track-item" data-track-index="${index}">
                            ${normalizedTrack.artworkUrl ?
                                `<img class="liked-track-art" src="${normalizedTrack.artworkUrl}" alt="${escapeHtml(normalizedTrack.title)}">` :
                                `<div class="liked-track-art">‚ô™</div>`
                            }
                            <div class="liked-track-info">
                                <div class="liked-track-title">${escapeHtml(normalizedTrack.title)}</div>
                                <div class="liked-track-artist">${escapeHtml(normalizedTrack.artist)}</div>
                                <div class="liked-track-meta">
                                    ${escapeHtml(normalizedTrack.station)} ‚Ä¢ ${timeAgo}
                                </div>
                            </div>
                            <div class="track-actions">
                                <button class="copy-track-btn" onclick="copySingleTrack('${escapeHtml(normalizedTrack.artist)}', '${escapeHtml(normalizedTrack.title)}', this)">
                                    <svg width="14" height="14" viewBox="0 0 256 256" style="vertical-align: middle;">
                                        <path fill="currentColor" d="M216 32H88a16 16 0 0 0-16 16v40H40a16 16 0 0 0-16 16v120a16 16 0 0 0 16 16h128a16 16 0 0 0 16-16v-40h32a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16zm-48 192H40V104h128zm48-48h-32V104a16 16 0 0 0-16-16H88V48h128z"/>
                                    </svg>
                                </button>
                                <button class="unlike-btn" onclick="unlikeTrack(${index})">√ó</button>
                            </div>
                        </div>
                    `;
                }).join('');
            }
        }
        
        // Unlike a track by index
        async function unlikeTrack(index) {
            const likedTracks = await window.loadLikedTracks();
            const track = likedTracks[index];
            if (track) {
                await window.removeLikedTrack(track);
                await displayLikedTracks();
                await updateLikeButton();
            }
        }

        // Expose to global scope for onclick handlers
        window.unlikeTrack = unlikeTrack;

        // Clear all liked tracks
        async function clearAllLikedTracks() {
            if (confirm('Are you sure you want to clear all liked tracks? This cannot be undone.')) {
                await window.clearAllLikedTracks();
                await displayLikedTracks();
                await updateLikeButton();
            }
        }
        
        // Helper function to get time ago string
        function getTimeAgo(date) {
            const seconds = Math.floor((new Date() - date) / 1000);
            
            const intervals = {
                year: 31536000,
                month: 2592000,
                week: 604800,
                day: 86400,
                hour: 3600,
                minute: 60
            };
            
            for (const [unit, secondsInUnit] of Object.entries(intervals)) {
                const interval = Math.floor(seconds / secondsInUnit);
                if (interval >= 1) {
                    return `${interval} ${unit}${interval === 1 ? '' : 's'} ago`;
                }
            }
            
            return 'Just now';
        }

        
        // Station form elements
        const stationFormModal = document.getElementById('stationFormModal');
        const closeStationFormModal = document.getElementById('closeStationFormModal');
        const stationFormTitle = document.getElementById('stationFormTitle');
        const stationForm = document.getElementById('stationForm');
        const cancelStationForm = document.getElementById('cancelStationForm');
        
        // ======================
        // SUPABASE INITIALIZATION
        // ======================

        // Use the Supabase client initialized by radio-auth.js
        // radio-auth.js sets up window.supabaseClient, window.currentUser, etc.
        const supabase = window.supabaseClient;

        // Check authentication status on load
        if (window.checkAuth) {
            window.checkAuth();
        }

        // ======================
        // RADIO BROWSER API FUNCTIONS
        // ======================

        const RADIO_BROWSER_API_BASE = 'https://de1.api.radio-browser.info/json';

        // Cache original filter data for dynamic filtering
        let originalLanguages = [];
        let originalTags = [];

        // Load countries, languages, and tags for the dropdowns
        async function loadRadioBrowserFilters() {
            try {
                // Load top countries
                const countriesRes = await fetch(`${RADIO_BROWSER_API_BASE}/countries?order=stationcount&reverse=true&limit=50`);
                const countries = await countriesRes.json();

                countries.forEach(country => {
                    if (country.name && country.stationcount > 0) {
                        const option = document.createElement('option');
                        option.value = country.name;
                        option.textContent = `${country.name} (${country.stationcount})`;
                        radioDatabaseCountry.appendChild(option);
                    }
                });

                // Load top languages
                const languagesRes = await fetch(`${RADIO_BROWSER_API_BASE}/languages?order=stationcount&reverse=true&limit=50`);
                const languages = await languagesRes.json();

                // Cache original languages
                originalLanguages = languages.filter(lang => lang.name && lang.stationcount > 0);

                originalLanguages.forEach(lang => {
                    const option = document.createElement('option');
                    option.value = lang.name;
                    option.textContent = `${lang.name} (${lang.stationcount})`;
                    radioDatabaseLanguage.appendChild(option);
                });

                // Load top tags
                const tagsRes = await fetch(`${RADIO_BROWSER_API_BASE}/tags?order=stationcount&reverse=true&limit=100`);
                const tags = await tagsRes.json();

                // Cache original tags
                originalTags = tags.filter(tag => tag.name && tag.stationcount > 0);

                originalTags.forEach(tag => {
                    const option = document.createElement('option');
                    option.value = tag.name;
                    option.textContent = `${tag.name} (${tag.stationcount})`;
                    radioDatabaseTag.appendChild(option);
                });
            } catch (error) {
                console.error('Error loading Radio Browser filters:', error);
            }
        }

        // Update language options based on selected country
        async function updateLanguageOptions(country) {
            if (!country) {
                // Reset to original languages
                restoreLanguageOptions();
                return;
            }

            try {
                // Fetch stations from selected country
                const params = new URLSearchParams();
                params.append('country', country);
                params.append('limit', '10000');
                params.append('hidebroken', 'true');

                const response = await fetch(`${RADIO_BROWSER_API_BASE}/stations/search?${params.toString()}`);
                const stations = await response.json();

                // Extract unique languages and count stations
                const languageMap = new Map();
                stations.forEach(station => {
                    if (station.language) {
                        const lang = station.language;
                        languageMap.set(lang, (languageMap.get(lang) || 0) + 1);
                    }
                });

                // Sort by station count
                const languages = Array.from(languageMap.entries())
                    .sort((a, b) => b[1] - a[1]);

                // Update dropdown
                const currentValue = radioDatabaseLanguage.value;
                radioDatabaseLanguage.innerHTML = '<option value="">All Languages</option>';

                languages.forEach(([lang, count]) => {
                    const option = document.createElement('option');
                    option.value = lang;
                    option.textContent = `${lang} (${count})`;
                    radioDatabaseLanguage.appendChild(option);
                });

                // Restore previous selection if still available
                if (currentValue && languages.some(([lang]) => lang === currentValue)) {
                    radioDatabaseLanguage.value = currentValue;
                } else if (currentValue) {
                    // Language no longer available, clear it
                    radioDatabaseLanguage.value = '';
                }
            } catch (error) {
                console.error('Error updating language options:', error);
            }
        }

        // Update tag options based on selected country and language
        async function updateTagOptions(country, language) {
            if (!country && !language) {
                // Reset to original tags
                restoreTagOptions();
                return;
            }

            try {
                // Fetch stations with selected filters
                const params = new URLSearchParams();
                if (country) params.append('country', country);
                if (language) params.append('language', language);
                params.append('limit', '10000');
                params.append('hidebroken', 'true');

                const response = await fetch(`${RADIO_BROWSER_API_BASE}/stations/search?${params.toString()}`);
                const stations = await response.json();

                // Extract unique tags and count stations
                const tagMap = new Map();
                stations.forEach(station => {
                    if (station.tags) {
                        // Tags are comma-separated
                        const tags = station.tags.split(',').map(t => t.trim()).filter(t => t);
                        tags.forEach(tag => {
                            tagMap.set(tag, (tagMap.get(tag) || 0) + 1);
                        });
                    }
                });

                // Sort by station count
                const tags = Array.from(tagMap.entries())
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 100); // Limit to top 100 tags

                // Update dropdown
                const currentValue = radioDatabaseTag.value;
                radioDatabaseTag.innerHTML = '<option value="">All Tags</option>';

                tags.forEach(([tag, count]) => {
                    const option = document.createElement('option');
                    option.value = tag;
                    option.textContent = `${tag} (${count})`;
                    radioDatabaseTag.appendChild(option);
                });

                // Restore previous selection if still available
                if (currentValue && tags.some(([tag]) => tag === currentValue)) {
                    radioDatabaseTag.value = currentValue;
                } else if (currentValue) {
                    // Tag no longer available, clear it
                    radioDatabaseTag.value = '';
                }
            } catch (error) {
                console.error('Error updating tag options:', error);
            }
        }

        // Restore original language options
        function restoreLanguageOptions() {
            const currentValue = radioDatabaseLanguage.value;
            radioDatabaseLanguage.innerHTML = '<option value="">All Languages</option>';

            originalLanguages.forEach(lang => {
                const option = document.createElement('option');
                option.value = lang.name;
                option.textContent = `${lang.name} (${lang.stationcount})`;
                radioDatabaseLanguage.appendChild(option);
            });

            // Restore previous selection if it exists in original list
            if (currentValue && originalLanguages.some(lang => lang.name === currentValue)) {
                radioDatabaseLanguage.value = currentValue;
            }
        }

        // Restore original tag options
        function restoreTagOptions() {
            const currentValue = radioDatabaseTag.value;
            radioDatabaseTag.innerHTML = '<option value="">All Tags</option>';

            originalTags.forEach(tag => {
                const option = document.createElement('option');
                option.value = tag.name;
                option.textContent = `${tag.name} (${tag.stationcount})`;
                radioDatabaseTag.appendChild(option);
            });

            // Restore previous selection if it exists in original list
            if (currentValue && originalTags.some(tag => tag.name === currentValue)) {
                radioDatabaseTag.value = currentValue;
            }
        }

        // Search Radio Browser API
        async function searchRadioBrowser(page = 1) {
            const searchTerm = radioDatabaseSearchInput.value.trim();
            const country = radioDatabaseCountry.value;
            const language = radioDatabaseLanguage.value;
            const tag = radioDatabaseTag.value;
            const sortBy = radioDatabaseSort.value;

            // Update current page
            radioDatabaseCurrentPage = page;

            // Determine filtering approach
            // Server-side bitrate filtering: Use API's bitrate_min parameter when possible
            // (bitrate > 0 AND includeUnknown is false AND HLS filter is off)
            const canUseServerSideBitrate = radioDatabaseMinBitrate > 0 && !radioDatabaseIncludeUnknown;

            // Large batch approach: Fetch 500 results when ANY filter is active
            // This prevents sparse results across offset-based pagination
            const useLargeBatchApproach = radioDatabaseMinBitrate > 0 || radioDatabaseFilterOutHLS;

            // Build query parameters
            const params = new URLSearchParams();
            if (searchTerm) params.append('name', searchTerm);
            if (country) params.append('country', country);
            if (language) params.append('language', language);
            if (tag) params.append('tag', tag);

            // Add server-side bitrate filter if applicable
            if (canUseServerSideBitrate) {
                params.append('bitrate_min', radioDatabaseMinBitrate.toString());
            }

            // Pagination - fetch large batch if any filter is active to avoid sparse results
            if (useLargeBatchApproach) {
                // Fetch more results to ensure we have enough after filtering
                params.append('limit', '500');
                params.append('offset', '0');
            } else {
                params.append('limit', radioDatabaseItemsPerPage.toString());
                params.append('offset', ((page - 1) * radioDatabaseItemsPerPage).toString());
            }

            // Sorting
            params.append('order', sortBy);
            params.append('reverse', 'true');
            params.append('hidebroken', 'true');

            // Only show loading indicator if there are no existing results
            // This prevents the jittery "Searching..." message during typing
            const hasExistingResults = radioDatabaseResults.children.length > 0 &&
                                      radioDatabaseResults.innerHTML.trim() !== '';

            if (!hasExistingResults) {
                radioDatabaseLoading.style.display = 'block';
            }

            radioDatabaseError.style.display = 'none';
            // Don't clear results immediately - keep them visible until new results arrive
            // radioDatabaseResults.innerHTML = '';

            try {
                const response = await fetch(`${RADIO_BROWSER_API_BASE}/stations/search?${params.toString()}`);

                if (!response.ok) {
                    throw new Error('Failed to fetch stations');
                }

                const results = await response.json();

                // Hide loading
                radioDatabaseLoading.style.display = 'none';

                if (results.length === 0) {
                    radioDatabaseResults.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: var(--text-secondary);">
                            No stations found. Try different search criteria.
                        </div>
                    `;
                    radioDatabasePagination.style.display = 'none';
                    radioDatabaseRawResults = [];
                    // Save state even with no results
                    saveRadioDatabaseState();
                    return;
                }

                // Store raw results for filtering
                radioDatabaseRawResults = results;

                // Apply client-side filters if needed (bitrate/HLS)
                const filteredResults = applyAdvancedFilters(results);

                // Update total results
                radioDatabaseTotalResults = filteredResults.length;

                // Render filtered results
                renderRadioBrowserResults(filteredResults);

                // Update pagination controls
                if (useLargeBatchApproach) {
                    // Hide pagination when using large batch approach
                    // (we fetch all matching results at once)
                    radioDatabasePagination.style.display = 'none';
                } else {
                    // Use normal pagination for unfiltered results
                    updateRadioDatabasePagination(results.length);
                }

                // Save state after successful search
                saveRadioDatabaseState();
            } catch (error) {
                console.error('Error searching Radio Browser:', error);
                radioDatabaseLoading.style.display = 'none';
                radioDatabaseError.style.display = 'block';
                radioDatabaseError.textContent = 'Error searching radio stations. Please try again.';
                radioDatabaseResults.innerHTML = '';
                radioDatabasePagination.style.display = 'none';
            }
        }

        // Handle bitrate dropdown change
        window.handleBitrateChange = function() {
            radioDatabaseMinBitrate = parseInt(bitrateDropdown.value);
            // Trigger new search to apply server-side filtering if possible
            searchRadioBrowser(1);
        };

        // Handle include unknown bitrates checkbox change
        window.handleIncludeUnknownChange = function() {
            radioDatabaseIncludeUnknown = includeUnknownBitrates.checked;
            // Trigger new search to switch between server/client-side filtering
            searchRadioBrowser(1);
        };

        // Handle filter out HLS checkbox change
        window.handleFilterHLSChange = function() {
            radioDatabaseFilterOutHLS = filterOutHLS.checked;
            // Trigger new search to switch between server/client-side filtering
            searchRadioBrowser(1);
        };

        // Apply advanced filters (bitrate/HLS) to raw results
        // Only applies client-side filters (server-side filters already applied)
        function applyAdvancedFilters(results) {
            return results.filter(station => {
                const bitrate = station.bitrate || 0;
                const isHLS = station.hls === 1 || station.hls === true;

                // Check bitrate filter
                let bitrateMatch = true;

                if (radioDatabaseMinBitrate > 0) {
                    // We have a minimum bitrate requirement
                    if (bitrate === 0) {
                        // Unknown bitrate - only include if "Include Unknown" is checked
                        bitrateMatch = radioDatabaseIncludeUnknown;
                    } else {
                        // Known bitrate - check if it meets minimum threshold
                        bitrateMatch = bitrate >= radioDatabaseMinBitrate;
                    }
                } else {
                    // No minimum bitrate filter (All bitrates)
                    // Still check if we should include unknown bitrates
                    if (bitrate === 0 && !radioDatabaseIncludeUnknown) {
                        bitrateMatch = false;
                    }
                }

                // Check HLS filter
                const hlsMatch = !radioDatabaseFilterOutHLS || !isHLS;

                return bitrateMatch && hlsMatch;
            });
        }

        // Update pagination controls
        function updateRadioDatabasePagination(resultsCount) {
            if (resultsCount === 0) {
                radioDatabasePagination.style.display = 'none';
                return;
            }

            // Determine if Next button would be disabled (last page)
            const isLastPage = resultsCount < radioDatabaseItemsPerPage;
            const isFirstPage = radioDatabaseCurrentPage === 1;

            // Only show pagination if we're not on page 1 OR if there are more pages
            // Hide pagination if we're on page 1 and it's also the last page (only one page of results)
            if (isFirstPage && isLastPage) {
                radioDatabasePagination.style.display = 'none';
                return;
            }

            radioDatabasePagination.style.display = 'flex';

            // Update page info
            radioDatabasePageInfo.textContent = `Page ${radioDatabaseCurrentPage}`;

            // Update Previous button
            radioDatabasePrevBtn.disabled = isFirstPage;

            // Update Next button
            radioDatabaseNextBtn.disabled = isLastPage;

            // Scroll results container to top
            radioDatabaseResults.scrollTop = 0;
        }

        // Render Radio Browser search results
        function renderRadioBrowserResults(results) {
            // Check if current user is admin
            console.log('üîç Checking admin status...');
            console.log('window.currentUser:', window.currentUser);
            console.log('window.currentUser.email:', window.currentUser?.email);
            const isAdmin = window.currentUser && window.currentUser.email === 'keith.e.dragon@gmail.com';
            console.log('isAdmin:', isAdmin);

            // Apply grid view class if in grid mode
            if (radioDatabaseViewMode === 'grid') {
                radioDatabaseResults.classList.add('grid-view');
            } else {
                radioDatabaseResults.classList.remove('grid-view');
            }

            radioDatabaseResults.innerHTML = results.map(station => {
                const favicon = station.favicon || '';
                const country = station.country || 'Unknown';
                const language = station.language || 'Unknown';
                const tags = station.tags ? station.tags.split(',').slice(0, 3).join(', ') : '';
                const votes = station.votes || 0;
                const bitrate = station.bitrate || 0;

                // Check if this station is currently playing
                const stationUrl = station.url_resolved || station.url;
                const isPlaying = currentStation && currentStation.url === stationUrl;
                const playingClass = isPlaying ? 'station-item-playing' : '';

                return `
                <div class="station-item ${playingClass}" data-station='${JSON.stringify(station).replace(/'/g, '&apos;')}'>
                    ${favicon ?
                        `<img src="${favicon}" class="station-icon" alt="${station.name}" onerror="this.onerror=null; this.src='${MUSIC_NOTE_DATA_URI}'">` :
                        `<div class="station-icon">${MUSIC_NOTE_ICON}</div>`
                    }
                    <div class="station-info">
                        <div class="station-name">${station.name}${isPlaying ? ' <span style="color: var(--primary-color);">‚ñ∂</span>' : ''}</div>
                        <div class="station-details">${country}${language !== 'Unknown' ? ` ‚Ä¢ ${language}` : ''}${bitrate > 0 ? ` ‚Ä¢ ${bitrate}kbps` : ''}</div>
                        ${tags ? `<div class="station-genres">${tags}</div>` : ''}
                    </div>
                    <button class="station-menu-btn" data-station='${JSON.stringify(station).replace(/'/g, '&apos;')}'>‚ãÆ</button>
                    <div class="station-dropdown">
                        <div class="dropdown-item" data-action="add-to-playlist-modal" data-station='${JSON.stringify(station).replace(/'/g, '&apos;')}'>
                            <span>‚ûï</span> Add to Playlist
                        </div>
                        ${isAdmin ? `
                        <div class="dropdown-item" data-action="add-to-curated-playlist-external" data-station='${JSON.stringify(station).replace(/'/g, '&apos;')}'>
                            <span>üìã</span> Add to Curated Playlist
                        </div>
                        <div class="dropdown-divider"></div>
                        <div class="dropdown-item" data-action="curate-station" data-station='${JSON.stringify(station).replace(/'/g, '&apos;')}'>
                            <span>‚≠ê</span> Add to Curated Stations
                        </div>
                        ` : ''}
                    </div>
                </div>
                `;
            }).join('');

            // Add click event listeners to station items
            document.querySelectorAll('#radioDatabaseResults .station-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    if (!e.target.closest('.station-menu-btn') && !e.target.closest('.station-dropdown')) {
                        const station = JSON.parse(item.getAttribute('data-station'));
                        playRadioBrowserStation(station);
                    }
                });
            });

            // Add event listeners for menu buttons
            document.querySelectorAll('#radioDatabaseResults .station-menu-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const dropdown = btn.nextElementSibling;

                    // Close all other dropdowns
                    document.querySelectorAll('#radioDatabaseResults .station-dropdown').forEach(d => {
                        if (d !== dropdown) d.classList.remove('active');
                    });

                    dropdown.classList.toggle('active');
                });
            });

            // Add hover/click listeners for submenus (mobile support)
            document.querySelectorAll('#radioDatabaseResults .dropdown-submenu').forEach(submenu => {
                // Support click for mobile
                submenu.addEventListener('click', (e) => {
                    if (e.target.closest('.dropdown-item') && !e.target.dataset.action) {
                        e.stopPropagation();
                        submenu.classList.toggle('active');
                    }
                });

                // Close submenu when clicking on backdrop (mobile)
                submenu.addEventListener('click', (e) => {
                    if (e.target === submenu && submenu.classList.contains('active')) {
                        submenu.classList.remove('active');
                    }
                });
            });

            // Add event listeners for dropdown actions
            document.querySelectorAll('#radioDatabaseResults .station-dropdown .dropdown-item').forEach(item => {
                item.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const action = item.dataset.action;

                    if (action === 'add-to-playlist-modal') {
                        const station = JSON.parse(item.getAttribute('data-station'));
                        showPlaylistSelectorForRadioBrowser(station);
                        document.querySelectorAll('#radioDatabaseResults .station-dropdown').forEach(d => d.classList.remove('active'));
                    } else if (action === 'add-to-curated-playlist-external') {
                        const station = JSON.parse(item.getAttribute('data-station'));
                        showCuratedPlaylistSelector(station, true);
                        document.querySelectorAll('#radioDatabaseResults .station-dropdown').forEach(d => d.classList.remove('active'));
                    } else if (action === 'curate-station') {
                        const station = JSON.parse(item.getAttribute('data-station'));
                        showStationFormForCuration(station);
                        document.querySelectorAll('#radioDatabaseResults .station-dropdown').forEach(d => d.classList.remove('active'));
                    }
                });
            });
        }

        // Play a station from Radio Browser
        async function playRadioBrowserStation(station) {
            try {
                let externalStationId = null;

                // Only save to database if authenticated (skip in guest mode)
                if (!window.isGuestMode && window.currentUser) {
                    // Add station to external_stations table (or get existing ID)
                    externalStationId = await addExternalStation(station);
                }

                // Convert Radio Browser station to our station format
                const ourStation = {
                    id: null, // Temporary ID for backwards compatibility
                    name: station.name,
                    url: station.url_resolved || station.url,
                    icon_url: station.favicon || '',
                    genres: station.tags ? station.tags.split(',').map(t => t.trim()) : [],
                    tags: station.tags,
                    call_letters: '',
                    frequency: '',
                    is_external: true,
                    external_id: externalStationId,
                    // Preserve all Radio Browser fields for station info display
                    homepage: station.homepage,
                    country: station.country,
                    countrycode: station.countrycode,
                    country_code: station.countrycode,
                    state: station.state,
                    language: station.language,
                    languagecodes: station.languagecodes,
                    languages: station.languages,
                    countrysubdivisioncode: station.countrysubdivisioncode,
                    countrysubdivision: station.countrysubdivision,
                    codec: station.codec,
                    bitrate: station.bitrate,
                    votes: station.votes
                };

                // Close the radio database modal
                radioDatabaseModal.classList.remove('active');

                // Select and play the station
                selectStation(ourStation);
                setTimeout(() => {
                    playPauseBtn.click();
                }, 100);

                // Track the station play in history (uses localStorage in guest mode)
                await trackStationClick(null, externalStationId);
            } catch (error) {
                console.error('Error playing radio browser station:', error);
                alert('Failed to play station. Please try again.');
            }
        }

        // Show playlist selector for adding a Radio Browser station
        async function showPlaylistSelectorForRadioBrowser(station) {
            if (!window.currentUser || !window.currentUser.id) {
                alert('Please sign in to add stations to playlists');
                return;
            }

            try {
                // Ensure playlists are loaded
                if (playlists.length === 0) {
                    await loadPlaylists();
                }

                // Update modal title
                playlistSelectorTitle.textContent = `Add "${station.name}" to Playlist`;

                // Render playlist options with create button
                const playlistItems = playlists.map(playlist => `
                    <div
                        class="playlist-selector-item"
                        data-playlist-id="${playlist.id}"
                        data-station='${JSON.stringify(station).replace(/'/g, '&apos;')}'
                        style="padding: 16px; margin-bottom: 8px; border: 2px solid var(--border-color); border-radius: 12px; background: var(--card-bg); cursor: pointer; transition: all 0.2s;"
                        onmouseover="this.style.borderColor='var(--accent-color)'; this.style.background='var(--hover-bg, var(--card-bg))';"
                        onmouseout="this.style.borderColor='var(--border-color)'; this.style.background='var(--card-bg)';"
                    >
                        <div style="font-weight: 600; font-size: 16px; color: var(--text-primary);">${playlist.name}</div>
                        ${playlist.description ? `<div style="font-size: 13px; color: var(--text-secondary); margin-top: 4px;">${playlist.description}</div>` : ''}
                    </div>
                `).join('');

                const createButton = `
                    <div
                        class="playlist-selector-create-btn"
                        style="padding: 16px; margin-bottom: 8px; border: 2px dashed var(--border-color); border-radius: 12px; background: var(--card-bg); cursor: pointer; transition: all 0.2s; text-align: center;"
                        onmouseover="this.style.borderColor='var(--accent-color)'; this.style.background='var(--hover-bg, var(--card-bg))';"
                        onmouseout="this.style.borderColor='var(--border-color)'; this.style.background='var(--card-bg)';"
                    >
                        <div style="font-weight: 600; font-size: 16px; color: var(--accent-color);">
                            <span style="font-size: 20px;">+</span> Create New Playlist
                        </div>
                    </div>
                `;

                playlistSelectorList.innerHTML = createButton + (playlists.length > 0 ? playlistItems : '');

                // Add click listener to create button
                document.querySelector('.playlist-selector-create-btn').addEventListener('click', () => {
                    // Store the context so we can return after creating playlist
                    pendingPlaylistSelectorContext = {
                        type: 'radio-browser',
                        station: station
                    };
                    playlistSelectorModal.classList.remove('active');
                    showPlaylistForm();
                });

                // Add click listeners to playlist items
                document.querySelectorAll('.playlist-selector-item').forEach(item => {
                    item.addEventListener('click', async () => {
                        const playlistId = item.getAttribute('data-playlist-id');
                        const stationData = JSON.parse(item.getAttribute('data-station'));

                        try {
                            // Add station to external_stations table first
                            const externalStationId = await addExternalStation(stationData);

                            // Add to the selected playlist (don't show built-in alert, we'll show custom one)
                            const added = await addStationToPlaylist(playlistId, null, externalStationId, false);

                            // Only show success message if actually added (not if already in playlist)
                            if (added) {
                                const selectedPlaylist = playlists.find(p => p.id === playlistId);
                                alert(`Successfully added "${stationData.name}" to playlist "${selectedPlaylist.name}"!`);
                            }

                            // Close modal
                            playlistSelectorModal.classList.remove('active');
                        } catch (error) {
                            console.error('Error adding station to playlist:', error);
                            alert('Failed to add station to playlist. Please try again.');
                        }
                    });
                });

                // Show modal
                playlistSelectorModal.classList.add('active');
            } catch (error) {
                console.error('Error showing playlist selector:', error);
                alert('Failed to load playlists. Please try again.');
            }
        }

        // Show playlist selector for the current playing station
        async function showPlaylistSelectorForCurrentStation() {
            if (!currentStation) {
                alert('No station is currently selected');
                return;
            }

            if (!window.currentUser || !window.currentUser.id) {
                alert('Please sign in to add stations to playlists');
                return;
            }

            try {
                // Ensure playlists are loaded
                if (playlists.length === 0) {
                    await loadPlaylists();
                }

                // Update modal title
                playlistSelectorTitle.textContent = `Add "${currentStation.name}" to Playlist`;

                // Determine if this is an external station or curated station
                const isExternal = currentStation.is_external || false;
                const stationId = isExternal ? null : currentStation.id;
                const externalId = isExternal ? currentStation.external_id : null;

                // Render playlist options with create button
                const playlistItems = playlists.map(playlist => `
                    <div
                        class="playlist-selector-item"
                        data-playlist-id="${playlist.id}"
                        data-station-id="${stationId || ''}"
                        data-external-id="${externalId || ''}"
                        data-is-external="${isExternal}"
                        style="padding: 16px; margin-bottom: 8px; border: 2px solid var(--border-color); border-radius: 12px; background: var(--card-bg); cursor: pointer; transition: all 0.2s;"
                        onmouseover="this.style.borderColor='var(--accent-color)'; this.style.background='var(--hover-bg, var(--card-bg))';"
                        onmouseout="this.style.borderColor='var(--border-color)'; this.style.background='var(--card-bg)';"
                    >
                        <div style="font-weight: 600; font-size: 16px; color: var(--text-primary);">${playlist.name}</div>
                        ${playlist.description ? `<div style="font-size: 13px; color: var(--text-secondary); margin-top: 4px;">${playlist.description}</div>` : ''}
                    </div>
                `).join('');

                const createButton = `
                    <div
                        class="playlist-selector-create-btn"
                        style="padding: 16px; margin-bottom: 8px; border: 2px dashed var(--border-color); border-radius: 12px; background: var(--card-bg); cursor: pointer; transition: all 0.2s; text-align: center;"
                        onmouseover="this.style.borderColor='var(--accent-color)'; this.style.background='var(--hover-bg, var(--card-bg))';"
                        onmouseout="this.style.borderColor='var(--border-color)'; this.style.background='var(--card-bg)';"
                    >
                        <div style="font-weight: 600; font-size: 16px; color: var(--accent-color);">
                            <span style="font-size: 20px;">+</span> Create New Playlist
                        </div>
                    </div>
                `;

                playlistSelectorList.innerHTML = createButton + (playlists.length > 0 ? playlistItems : '');

                // Add click listener to create button
                document.querySelector('.playlist-selector-create-btn').addEventListener('click', () => {
                    // Store the context so we can return after creating playlist
                    pendingPlaylistSelectorContext = {
                        type: 'current-station',
                        station: currentStation
                    };
                    playlistSelectorModal.classList.remove('active');
                    showPlaylistForm();
                });

                // Add click listeners to playlist items
                document.querySelectorAll('.playlist-selector-item').forEach(item => {
                    item.addEventListener('click', async () => {
                        const playlistId = item.getAttribute('data-playlist-id');
                        const isExt = item.getAttribute('data-is-external') === 'true';
                        const stId = item.getAttribute('data-station-id');
                        const extId = item.getAttribute('data-external-id');

                        try {
                            // Add to the selected playlist
                            if (isExt) {
                                // External station - use external_id
                                await addStationToPlaylist(playlistId, null, extId);
                            } else {
                                // Curated station - use station_id
                                await addStationToPlaylist(playlistId, stId);
                            }

                            const selectedPlaylist = playlists.find(p => p.id === playlistId);
                            alert(`Successfully added "${currentStation.name}" to playlist "${selectedPlaylist.name}"!`);

                            // Close modal
                            playlistSelectorModal.classList.remove('active');
                        } catch (error) {
                            console.error('Error adding station to playlist:', error);
                            alert('Failed to add station to playlist. Please try again.');
                        }
                    });
                });

                // Show modal
                playlistSelectorModal.classList.add('active');
            } catch (error) {
                console.error('Error showing playlist selector:', error);
                alert('Failed to load playlists. Please try again.');
            }
        }

        // Show playlist selector for a curated station
        async function showPlaylistSelectorForCuratedStation(station) {
            if (!window.currentUser || !window.currentUser.id) {
                alert('Please sign in to add stations to playlists');
                return;
            }

            try {
                // Ensure playlists are loaded
                if (playlists.length === 0) {
                    await loadPlaylists();
                }

                // Update modal title
                playlistSelectorTitle.textContent = `Add "${station.name}" to Playlist`;

                // Render playlist options with create button
                const playlistItems = playlists.map(playlist => `
                    <div
                        class="playlist-selector-item"
                        data-playlist-id="${playlist.id}"
                        data-station-id="${station.id}"
                        style="padding: 16px; margin-bottom: 8px; border: 2px solid var(--border-color); border-radius: 12px; background: var(--card-bg); cursor: pointer; transition: all 0.2s;"
                        onmouseover="this.style.borderColor='var(--accent-color)'; this.style.background='var(--hover-bg, var(--card-bg))';"
                        onmouseout="this.style.borderColor='var(--border-color)'; this.style.background='var(--card-bg)';"
                    >
                        <div style="font-weight: 600; font-size: 16px; color: var(--text-primary);">${playlist.name}</div>
                        ${playlist.description ? `<div style="font-size: 13px; color: var(--text-secondary); margin-top: 4px;">${playlist.description}</div>` : ''}
                    </div>
                `).join('');

                const createButton = `
                    <div
                        class="playlist-selector-create-btn"
                        style="padding: 16px; margin-bottom: 8px; border: 2px dashed var(--border-color); border-radius: 12px; background: var(--card-bg); cursor: pointer; transition: all 0.2s; text-align: center;"
                        onmouseover="this.style.borderColor='var(--accent-color)'; this.style.background='var(--hover-bg, var(--card-bg))';"
                        onmouseout="this.style.borderColor='var(--border-color)'; this.style.background='var(--card-bg)';"
                    >
                        <div style="font-weight: 600; font-size: 16px; color: var(--accent-color);">
                            <span style="font-size: 20px;">+</span> Create New Playlist
                        </div>
                    </div>
                `;

                playlistSelectorList.innerHTML = createButton + (playlists.length > 0 ? playlistItems : '');

                // Add click listener to create button
                document.querySelector('.playlist-selector-create-btn').addEventListener('click', () => {
                    // Store the context so we can return after creating playlist
                    pendingPlaylistSelectorContext = {
                        type: 'curated-station',
                        station: station
                    };
                    playlistSelectorModal.classList.remove('active');
                    showPlaylistForm();
                });

                // Add click listeners to playlist items
                document.querySelectorAll('.playlist-selector-item').forEach(item => {
                    item.addEventListener('click', async () => {
                        const playlistId = item.getAttribute('data-playlist-id');
                        const stationId = parseInt(item.getAttribute('data-station-id'));

                        try {
                            // Add to the selected playlist
                            const added = await addStationToPlaylist(playlistId, stationId, null, false);

                            // Only show success message if actually added (not if already in playlist)
                            if (added) {
                                const selectedPlaylist = playlists.find(p => p.id === playlistId);
                                alert(`Successfully added "${station.name}" to playlist "${selectedPlaylist.name}"!`);
                            }

                            // Close modal
                            playlistSelectorModal.classList.remove('active');
                        } catch (error) {
                            console.error('Error adding station to playlist:', error);
                            alert('Failed to add station to playlist. Please try again.');
                        }
                    });
                });

                // Show modal
                playlistSelectorModal.classList.add('active');
            } catch (error) {
                console.error('Error showing playlist selector:', error);
                alert('Failed to load playlists. Please try again.');
            }
        }

        // Legacy function - kept for backwards compatibility if needed
        async function addRadioBrowserStationToDatabase(station) {
            console.warn('addRadioBrowserStationToDatabase is deprecated. Use showPlaylistSelectorForRadioBrowser instead.');
            showPlaylistSelectorForRadioBrowser(station);
        }

        // ======================
        // DATABASE FUNCTIONS
        // ======================

        // ======================
        // EXTERNAL STATIONS (RADIO-BROWSER.INFO)
        // ======================

        // Add a Radio Browser station to external_stations table
        async function addExternalStation(station) {
            try {
                const externalStation = {
                    source: 'radio-browser',
                    external_id: station.stationuuid,
                    name: station.name,
                    url: station.url,
                    url_resolved: station.url_resolved,
                    icon_url: station.favicon || null,  // Store favicon as icon_url for consistency
                    favicon: station.favicon,
                    genres: station.tags ? station.tags.split(',').map(t => t.trim()).filter(t => t) : [],
                    country: station.country || null,
                    country_code: station.countrycode || null,
                    language: station.language || null,
                    bitrate: station.bitrate || null,
                    votes: station.votes || 0,
                    click_count: station.clickcount || 0,
                    codec: station.codec || null,
                    homepage: station.homepage || null,
                    metadata: {
                        state: station.state,
                        languagecodes: station.languagecodes,
                        languages: station.languages,
                        countrysubdivisioncode: station.countrysubdivisioncode,
                        countrysubdivision: station.countrysubdivision,
                        hls: station.hls,
                        lastcheckok: station.lastcheckok,
                        lastchecktime: station.lastchecktime
                    }
                };

                // Check if station already exists
                const { data: existing, error: checkError } = await supabase
                    .from('external_stations')
                    .select('id')
                    .eq('source', 'radio-browser')
                    .eq('external_id', station.stationuuid)
                    .maybeSingle();

                if (checkError && checkError.code !== 'PGRST116') {
                    console.error('Error checking existing station:', checkError);
                    throw checkError;
                }

                if (existing) {
                    console.log('External station already exists, updating with latest data:', existing.id);
                    // Update the existing station with latest data (including artwork)
                    const { error: updateError } = await supabase
                        .from('external_stations')
                        .update({
                            name: externalStation.name,
                            url: externalStation.url,
                            url_resolved: externalStation.url_resolved,
                            icon_url: externalStation.icon_url,
                            favicon: externalStation.favicon,
                            genres: externalStation.genres,
                            country: externalStation.country,
                            country_code: externalStation.country_code,
                            language: externalStation.language,
                            bitrate: externalStation.bitrate,
                            votes: externalStation.votes,
                            click_count: externalStation.click_count,
                            codec: externalStation.codec,
                            homepage: externalStation.homepage,
                            metadata: externalStation.metadata
                        })
                        .eq('id', existing.id);

                    if (updateError) {
                        console.error('Error updating existing station:', updateError);
                    } else {
                        console.log('Successfully updated existing station with latest data');
                    }

                    return existing.id;
                }

                // Insert new external station
                const { data, error } = await supabase
                    .from('external_stations')
                    .insert([externalStation])
                    .select('id')
                    .single();

                if (error) {
                    console.error('Error adding external station:', error);
                    throw error;
                }

                console.log('External station added successfully:', data.id);
                return data.id;
            } catch (error) {
                console.error('Error in addExternalStation:', error);
                throw error;
            }
        }

        // Get external station by ID
        async function getExternalStation(externalStationId) {
            try {
                const { data, error } = await supabase
                    .from('external_stations')
                    .select('*')
                    .eq('id', externalStationId)
                    .single();

                if (error) throw error;

                // Convert to station format
                return {
                    id: data.id,
                    name: data.name,
                    url: data.url_resolved || data.url,
                    icon_url: data.icon_url || data.favicon || '',
                    genres: data.genres || [],
                    tags: data.genres ? data.genres.join(', ') : '',
                    call_letters: '',
                    frequency: '',
                    country: data.country,
                    is_external: true,
                    external_id: data.id,
                    // Include all Radio Browser fields for station info display
                    homepage: data.homepage,
                    countrycode: data.country_code,
                    country_code: data.country_code,
                    state: data.metadata?.state,
                    language: data.language,
                    languagecodes: data.metadata?.languagecodes,
                    languages: data.metadata?.languages,
                    countrysubdivisioncode: data.metadata?.countrysubdivisioncode,
                    countrysubdivision: data.metadata?.countrysubdivision,
                    codec: data.codec,
                    bitrate: data.bitrate,
                    votes: data.votes
                };
            } catch (error) {
                console.error('Error getting external station:', error);
                return null;
            }
        }

        // ======================
        // STATION HISTORY TRACKING
        // ======================
        
        // Generate a simple anonymous user ID for tracking
        // Track station click (works in both guest and authenticated mode)
        // Supports both internal stations (numeric ID) and external stations (UUID or object)
        async function trackStationClick(stationId, externalStationId = null) {
            // Skip tracking for temporary stations that don't have an ID
            if (!stationId && !externalStationId) {
                console.log('Skipping tracking for temporary station (no ID)');
                return;
            }

            if (window.isGuestMode) {
                // Guest mode - use localStorage only
                trackStationClickLocal(stationId, externalStationId);
            } else {
                // Authenticated - save to Supabase
                try {
                    const insertData = {
                        user_id: window.currentUser.id,
                        clicked_at: new Date().toISOString()
                    };

                    // Add either station_id or external_station_id
                    if (externalStationId) {
                        insertData.external_station_id = externalStationId;
                    } else {
                        insertData.station_id = stationId;
                    }

                    const { error } = await supabase
                        .from('station_history')
                        .insert(insertData);

                    if (error) {
                        console.error('Error tracking station click:', error);
                        trackStationClickLocal(stationId, externalStationId); // Fallback to local
                    } else {
                        console.log('Station click tracked successfully');
                    }
                } catch (error) {
                    console.error('Error tracking station click:', error);
                    trackStationClickLocal(stationId, externalStationId); // Fallback to local
                }
            }
        }

        // Track station click in local storage (guest mode or fallback)
        function trackStationClickLocal(stationId, externalStationId = null) {
            try {
                let history = JSON.parse(localStorage.getItem('station_history') || '[]');
                const record = {
                    clicked_at: new Date().toISOString()
                };

                // Add either station_id or external_station_id
                if (externalStationId) {
                    record.external_station_id = externalStationId;
                } else {
                    record.station_id = stationId;
                }

                history.push(record);
                if (history.length > 500) {
                    history = history.slice(-500);
                }
                localStorage.setItem('station_history', JSON.stringify(history));
            } catch (error) {
                console.error('Error tracking station click locally:', error);
            }
        }
        
        // Get most recent stations (works in both guest and authenticated mode)
        // Includes both internal and external (radio-browser) stations
        async function getMostRecentStations(limit = 10) {
            if (window.isGuestMode || !window.currentUser) {
                // Guest mode or not authenticated - use localStorage
                return getMostRecentStationsLocal(limit);
            } else {
                // Authenticated - use Supabase
                try {
                    const { data, error } = await supabase
                        .from('station_history')
                        .select('station_id, external_station_id, clicked_at, external_stations(*), radio_stations(*)')
                        .eq('user_id', window.currentUser.id)
                        .order('clicked_at', { ascending: false })
                        .limit(limit * 3);

                    if (error) throw error;

                    const recentStations = [];
                    const seenKeys = new Set();

                    for (const record of data) {
                        // Create unique key for internal or external station
                        const key = record.external_station_id
                            ? `ext-${record.external_station_id}`
                            : `int-${record.station_id}`;

                        if (!seenKeys.has(key)) {
                            seenKeys.add(key);

                            let station = null;
                            if (record.external_station_id && record.external_stations) {
                                // External station from radio-browser
                                const ext = record.external_stations;
                                station = {
                                    id: ext.id,
                                    name: ext.name,
                                    url: ext.url_resolved || ext.url,
                                    icon_url: ext.icon_url || ext.favicon || '',
                                    genres: ext.genres || [],
                                    call_letters: '',
                                    frequency: '',
                                    country: ext.country,
                                    is_external: true,
                                    external_id: ext.id
                                };
                            } else if (record.station_id) {
                                // Internal station
                                station = stations.find(s => s.id === record.station_id);
                            }

                            if (station) {
                                recentStations.push(station);
                                if (recentStations.length >= limit) break;
                            }
                        }
                    }

                    return recentStations;

                } catch (error) {
                    console.error('Error getting recent stations from database:', error);
                    return getMostRecentStationsLocal(limit);
                }
            }
        }
        
        // Get most recent stations from local storage (fallback)
        function getMostRecentStationsLocal(limit = 10) {
            try {
                const history = JSON.parse(localStorage.getItem('station_history') || '[]');
                
                const uniqueStationIds = [];
                const seenIds = new Set();
                
                for (let i = history.length - 1; i >= 0; i--) {
                    const stationId = history[i].station_id;
                    if (!seenIds.has(stationId)) {
                        seenIds.add(stationId);
                        uniqueStationIds.push(stationId);
                        if (uniqueStationIds.length >= limit) break;
                    }
                }
                
                return stations.filter(s => uniqueStationIds.includes(s.id))
                    .sort((a, b) => uniqueStationIds.indexOf(a.id) - uniqueStationIds.indexOf(b.id));
                
            } catch (error) {
                console.error('Error getting recent stations from local storage:', error);
                return [];
            }
        }
        
        // Get most played stations (works in both guest and authenticated mode)
        async function getMostPlayedStations(limit = 10) {
            if (window.isGuestMode || !window.currentUser) {
                // Guest mode or not authenticated - use localStorage
                return getMostPlayedStationsLocal(limit);
            } else {
                // Authenticated - use Supabase
                try {
                    const { data, error } = await supabase
                        .from('station_history')
                        .select('station_id')
                        .eq('user_id', window.currentUser.id);

                    if (error) throw error;

                    const counts = {};
                    data.forEach(record => {
                        counts[record.station_id] = (counts[record.station_id] || 0) + 1;
                    });

                    // Sort by count and get top station IDs (as numbers)
                    const sortedStationIds = Object.keys(counts)
                        .map(id => parseInt(id))
                        .sort((a, b) => counts[b] - counts[a])
                        .slice(0, limit);

                    return stations.filter(s => sortedStationIds.includes(s.id))
                        .sort((a, b) => counts[b.id] - counts[a.id]);

                } catch (error) {
                    console.error('Error getting most played stations from database:', error);
                    return getMostPlayedStationsLocal(limit);
                }
            }
        }
        
        // Get most played stations from local storage (fallback)
        function getMostPlayedStationsLocal(limit = 10) {
            try {
                const history = JSON.parse(localStorage.getItem('station_history') || '[]');

                const counts = {};
                history.forEach(record => {
                    counts[record.station_id] = (counts[record.station_id] || 0) + 1;
                });

                // Sort by count and get top station IDs (as numbers)
                const sortedStationIds = Object.keys(counts)
                    .map(id => parseInt(id))
                    .sort((a, b) => counts[b] - counts[a])
                    .slice(0, limit);

                return stations.filter(s => sortedStationIds.includes(s.id))
                    .sort((a, b) => counts[b.id] - counts[a.id]);

            } catch (error) {
                console.error('Error getting most played stations from local storage:', error);
                return [];
            }
        }

        // Fetch metadata from HLS stream
        // Note: Some HLS streams may not provide metadata due to CORS restrictions
        // or if the stream doesn't include ID3 tags. This is expected and handled gracefully.
        async function fetchHLSMetadata(station) {
            return new Promise((resolve) => {
                const timeout = setTimeout(() => {
                    cleanup();
                    resolve(null);
                }, 15000); // HLS needs more time to load manifest and segments

                let tempHls = null;
                let tempAudio = null;
                let metadataReceived = false;

                const cleanup = () => {
                    clearTimeout(timeout);
                    if (tempHls) {
                        try {
                            tempHls.destroy();
                        } catch (e) {
                        }
                        tempHls = null;
                    }
                    if (tempAudio) {
                        try {
                            tempAudio.pause();
                            tempAudio.src = '';
                            tempAudio.load();
                        } catch (e) {
                            console.log('Error cleaning up temp audio:', e);
                        }
                        tempAudio = null;
                    }
                };

                try {
                    const rawUrl = station.url_standard || station.url;
                    if (!rawUrl) {
                        cleanup();
                        resolve(null);
                        return;
                    }

                    // HLS streams don't need CORS proxy - browsers handle CORS for HLS
                    const streamUrl = rawUrl;

                    if (typeof Hls !== 'undefined' && Hls.isSupported()) {
                        tempAudio = document.createElement('audio');
                        tempAudio.muted = true;
                        tempAudio.volume = 0;

                        tempHls = new Hls({
                            enableWorker: false,
                            debug: false
                        });

                        // Listen for metadata
                        tempHls.on(Hls.Events.FRAG_PARSING_METADATA, (event, data) => {
                            if (metadataReceived) return;

                            try {
                                // Parse ID3 frames
                                if (data.samples && data.samples.length > 0) {
                                    for (const sample of data.samples) {
                                        if (sample.data) {
                                            const id3Data = sample.data;
                                            const frames = parseID3Frames(id3Data);

                                            if (frames.TIT2 || frames.TPE1) {
                                                metadataReceived = true;
                                                cleanup();
                                                resolve({
                                                    title: frames.TIT2 || 'Unknown',
                                                    artist: frames.TPE1 || ''
                                                });
                                                return;
                                            }
                                        }
                                    }
                                }

                                // Check for frag.title format
                                if (data.frag && data.frag.title) {
                                    const fragTitle = data.frag.title;
                                    let title = 'Unknown';
                                    let artist = '';

                                    // Check for attribute-based format: title="...",artist="..."
                                    const titleMatch = fragTitle.match(/title=["']([^"']+)["']/i);
                                    const artistMatch = fragTitle.match(/artist=["']([^"']+)["']/i);

                                    if (titleMatch || artistMatch) {
                                        // Extract from attributes
                                        title = titleMatch ? titleMatch[1].trim() : 'Unknown';
                                        artist = artistMatch ? artistMatch[1].trim() : '';
                                    } else if (fragTitle.includes(' - ')) {
                                        // Fall back to dash-separated format
                                        const parts = fragTitle.split(' - ');
                                        artist = parts[0].trim();
                                        title = parts[1].trim();
                                    } else {
                                        // No recognized format, use as-is
                                        title = fragTitle;
                                    }

                                    metadataReceived = true;
                                    cleanup();
                                    resolve({ title, artist });
                                    return;
                                }
                            } catch (error) {
                            }
                        });

                        tempHls.on(Hls.Events.ERROR, (event, data) => {
                            if (data.fatal) {
                                // Network errors and manifest load errors are expected for HLS streams
                                // without proper CORS headers - fail silently
                                if (data.type !== Hls.ErrorTypes.NETWORK_ERROR) {
                                }
                                cleanup();
                                resolve(null);
                            }
                        });

                        tempHls.on(Hls.Events.MANIFEST_PARSED, () => {
                            tempAudio.play().catch(() => {
                                // Ignore play errors for silent player
                            });
                        });

                        tempHls.loadSource(streamUrl);
                        tempHls.attachMedia(tempAudio);

                    } else if (tempAudio && tempAudio.canPlayType('application/vnd.apple.mpegurl')) {
                        // Safari native HLS
                        tempAudio = document.createElement('audio');
                        tempAudio.muted = true;
                        tempAudio.volume = 0;
                        tempAudio.src = streamUrl;

                        tempAudio.addEventListener('loadedmetadata', () => {
                            const tracks = tempAudio.textTracks;
                            for (let i = 0; i < tracks.length; i++) {
                                const track = tracks[i];
                                if (track.kind === 'metadata') {
                                    track.mode = 'hidden';
                                    track.addEventListener('cuechange', () => {
                                        if (metadataReceived) return;

                                        const cue = track.activeCues && track.activeCues[0];
                                        if (cue && cue.value) {
                                            try {
                                                const frames = cue.value;
                                                if (frames.data) {
                                                    const title = frames.data.TIT2 || frames.data.info || 'Unknown';
                                                    const artist = frames.data.TPE1 || '';

                                                    metadataReceived = true;
                                                    cleanup();
                                                    resolve({ title, artist });
                                                }
                                            } catch (error) {
                                            }
                                        }
                                    });
                                }
                            }
                        });

                        tempAudio.play().catch(() => {
                            // Ignore play errors
                        });
                    } else {
                        cleanup();
                        resolve(null);
                    }
                } catch (error) {
                    // Silently handle errors - CORS and unsupported streams are expected
                    cleanup();
                    resolve(null);
                }
            });
        }

        // Fetch current metadata from a station's stream
        async function fetchStationCurrentMetadata(station) {
            // If this is the currently playing station, use the live metadata we already have
            if (currentStation && station) {
                // Check if it's the same station (compare by ID or URL)
                const isSameStation =
                    (station.id && currentStation.id && station.id === currentStation.id) ||
                    (station.external_id && currentStation.external_id && station.external_id === currentStation.external_id) ||
                    (station.url && currentStation.url && station.url === currentStation.url);

                if (isSameStation && currentTrack && (currentTrack.title || currentTrack.artist)) {
                    // Return the live metadata from the currently playing stream
                    return {
                        title: currentTrack.title || 'Unknown',
                        artist: currentTrack.artist || ''
                    };
                }
            }

            // Check if this is an HLS stream
            const rawUrl = station.url_standard || station.url;
            if (rawUrl && isHLSStream(rawUrl)) {
                return await fetchHLSMetadata(station);
            }

            return new Promise((resolve) => {
                // Timeout after 10 seconds
                const timeout = setTimeout(() => {
                    if (tempPlayer) {
                        try {
                            tempPlayer.stop();
                        } catch (e) {
                            console.log('Error stopping temp player:', e);
                        }
                    }
                    resolve(null);
                }, 10000);

                let tempPlayer = null;
                let metadataReceived = false;

                try {
                    // Get the standard quality URL
                    if (!rawUrl) {
                        clearTimeout(timeout);
                        resolve(null);
                        return;
                    }

                    // Use CORS proxy (Cloudflare Worker)
                    const streamUrl = corsProxies[0].url(rawUrl);

                    tempPlayer = new IcecastMetadataPlayer(streamUrl, {
                        metadataTypes: ['icy', 'ogg'],
                        enableLogging: false,

                        onMetadata: (metadata) => {
                            if (metadataReceived) return; // Only process first metadata
                            metadataReceived = true;

                            clearTimeout(timeout);

                            // Stop and cleanup the player
                            if (tempPlayer) {
                                try {
                                    tempPlayer.stop();
                                } catch (e) {
                                    console.log('Error stopping temp player:', e);
                                }
                            }

                            // Parse metadata
                            if (metadata && metadata.StreamTitle) {
                                const streamTitle = metadata.StreamTitle;
                                let title = 'Unknown';
                                let artist = '';

                                // Helper function to clean metadata text (remove XML attributes from iHeart and similar stations)
                                function cleanMetadataText(text) {
                                    if (!text) return '';

                                    // First, check if the text starts with text="..." pattern and extract the value
                                    // Use non-greedy .*? to handle apostrophes in values like "Don't Stop"
                                    const textMatch = text.match(/^text=(?:"(.*?)"|'(.*?)')/i);
                                    if (textMatch) {
                                        return (textMatch[1] || textMatch[2]).trim();
                                    }

                                    // Otherwise, remove everything after common attribute patterns like text=", song_spot=", etc.
                                    // This matches patterns like: text="..." or attribute="value" or attribute='value'
                                    // Use non-greedy .*? to handle apostrophes in attribute values
                                    const cleaned = text.replace(/\s+(text|song_spot|spotInstanceId|length|MediaBaseId|TAID|TPID|cartcutId|amgArtworkURL|spEventID|[a-zA-Z_]+)=(?:"(.*?)"|'(.*?)').*$/i, '');
                                    return cleaned.trim();
                                }

                                // Check for structured format
                                // Use non-greedy .*? to handle apostrophes in values like "Don't Stop"
                                const titleMatch = streamTitle.match(/title=(?:"(.*?)"|'(.*?)')/i);
                                const artistMatch = streamTitle.match(/artist=(?:"(.*?)"|'(.*?)')/i);

                                if (titleMatch || artistMatch) {
                                    title = titleMatch ? (titleMatch[1] || titleMatch[2]).trim() : 'Unknown';
                                    artist = artistMatch ? (artistMatch[1] || artistMatch[2]).trim() : '';
                                } else if (streamTitle.includes(' - ')) {
                                    const parts = streamTitle.split(' - ');
                                    artist = cleanMetadataText(parts[0].trim());
                                    title = cleanMetadataText(parts[1].trim());
                                } else {
                                    title = cleanMetadataText(streamTitle);
                                }

                                resolve({ title, artist });
                            } else {
                                resolve(null);
                            }
                        },

                        onError: (error) => {
                            clearTimeout(timeout);
                            if (tempPlayer) {
                                try {
                                    tempPlayer.stop();
                                } catch (e) {
                                    console.log('Error stopping temp player:', e);
                                }
                            }
                            resolve(null);
                        }
                    });

                    // Mute and start playback
                    if (tempPlayer.audioElement) {
                        tempPlayer.audioElement.volume = 0;
                        tempPlayer.audioElement.muted = true;

                        // Add error event listener to catch AbortError and other playback errors
                        tempPlayer.audioElement.addEventListener('error', (e) => {
                            // Silently handle AbortError - it's expected when streams are interrupted
                            if (!metadataReceived) {
                                clearTimeout(timeout);
                                if (tempPlayer) {
                                    try {
                                        tempPlayer.stop();
                                    } catch (err) {
                                        // Ignore cleanup errors
                                    }
                                }
                                resolve(null);
                            }
                        }, { once: true });

                        tempPlayer.play().catch((err) => {
                            // Silently handle AbortError - it's expected when multiple streams load
                            if (!metadataReceived) {
                                clearTimeout(timeout);
                                resolve(null);
                            }
                        });
                    } else {
                        setTimeout(() => {
                            if (tempPlayer && tempPlayer.audioElement) {
                                tempPlayer.audioElement.volume = 0;
                                tempPlayer.audioElement.muted = true;

                                // Add error event listener
                                tempPlayer.audioElement.addEventListener('error', (e) => {
                                    if (!metadataReceived) {
                                        clearTimeout(timeout);
                                        if (tempPlayer) {
                                            try {
                                                tempPlayer.stop();
                                            } catch (err) {
                                                // Ignore cleanup errors
                                            }
                                        }
                                        resolve(null);
                                    }
                                }, { once: true });

                                tempPlayer.play().catch((err) => {
                                    if (!metadataReceived) {
                                        clearTimeout(timeout);
                                        resolve(null);
                                    }
                                });
                            }
                        }, 500);
                    }
                } catch (error) {
                    clearTimeout(timeout);
                    resolve(null);
                }
            });
        }
        
        // Load stations from Supabase
        async function loadStations(forceRefresh = false) {
            try {
                console.log('loadStations called');
                const { data, error } = await supabase
                    .from('radio_stations')
                    .select('*')
                    .order('name');
                
                if (error) throw error;
                
                stations = data || [];
                console.log('Loaded stations:', stations.length);
                
                // Populate genre filter dropdown
                populateGenreFilter();
                
                // Re-apply search filter if there's a search term
                const searchTerm = stationSearch ? stationSearch.value.trim() : '';
                if (searchTerm) {
                    console.log('Applying search filter:', searchTerm);
                    filterStations(searchTerm);
                } else {
                    console.log('No search term, setting filteredStations');
                    curatedStationsCurrentPage = 1; // Reset pagination when loading stations
                    filteredStations = [...stations];
                    renderStationList();
                }
                
                // Clear service worker cache if force refresh
                if (forceRefresh && 'serviceWorker' in navigator && navigator.serviceWorker.controller) {
                    navigator.serviceWorker.controller.postMessage({
                        type: 'CLEAR_CACHE'
                    });
                }
                
            } catch (error) {
                console.error('Error loading stations:', error);
                updateStatus('Error loading stations', 'error');
            }
        }
        
        // Load playlists from Supabase
        async function loadPlaylists(forceRefresh = false) {
            try {
                const { data, error } = await supabase
                    .from('playlists')
                    .select('*, playlist_items(count)')
                    .order('sort_order', { ascending: true, nullsFirst: false })
                    .order('created_at', { ascending: false });
                
                if (error) throw error;
                
                playlists = data || [];
                renderPlaylistsList();
                
                // Clear service worker cache if force refresh
                if (forceRefresh && 'serviceWorker' in navigator && navigator.serviceWorker.controller) {
                    navigator.serviceWorker.controller.postMessage({
                        type: 'CLEAR_CACHE'
                    });
                }
                
            } catch (error) {
                console.error('Error loading playlists:', error);
            }
        }

        // Load curated playlists (admin-curated collections)
        async function loadCuratedPlaylists() {
            try {
                const { data, error } = await supabase
                    .from('curated_playlists')
                    .select('*')
                    .order('sort_order', { ascending: true, nullsFirst: false })
                    .order('created_at', { ascending: false });

                if (error) throw error;

                curatedPlaylists = data || [];
                console.log('Loaded curated playlists:', curatedPlaylists.length);

                // Load stations for curated playlists to show in carousels
                await renderCuratedPlaylistsInBrowseModal();

            } catch (error) {
                console.error('Error loading curated playlists:', error);
            }
        }

        // Render curated playlists in Browse Stations modal
        // Note: Curated playlists sections have been moved to the Discover page
        async function renderCuratedPlaylistsInBrowseModal() {
            // This function is no longer used as the sections have been moved to the Discover modal
            // Kept for backwards compatibility
        }

        // Load stations for a curated playlist
        async function loadCuratedPlaylistStations(playlist) {
            try {
                const { data, error } = await supabase
                    .from('curated_playlist_items')
                    .select('*, radio_stations(*), external_stations(*)')
                    .eq('curated_playlist_id', playlist.id)
                    .order('sort_order', { ascending: true, nullsFirst: false })
                    .order('created_at')
                    .limit(12); // Load extra stations to ensure we find 4 with icons

                if (error) throw error;

                const stationsData = data ? data.map(item => {
                    if (item.external_stations) {
                        // External station from radio-browser
                        const ext = item.external_stations;
                        return {
                            id: ext.id,
                            name: ext.name,
                            url: ext.url_resolved || ext.url,
                            icon_url: ext.icon_url || ext.favicon || '',
                            genres: ext.genres || [],
                            call_letters: '',
                            frequency: '',
                            country: ext.country,
                            is_external: true,
                            external_id: ext.id
                        };
                    } else if (item.radio_stations) {
                        // Internal curated station
                        return item.radio_stations;
                    }
                    return null;
                }).filter(s => s !== null) : [];

                return {
                    ...playlist,
                    stations: stationsData
                };
            } catch (error) {
                console.error('Error loading curated playlist stations:', error);
                return {
                    ...playlist,
                    stations: []
                };
            }
        }

        // Show curated playlist selector
        async function showCuratedPlaylistSelector(station, isExternal) {
            pendingCuratedPlaylistStation = station;
            pendingCuratedPlaylistIsExternal = isExternal;

            // Load curated playlists if not already loaded
            if (curatedPlaylists.length === 0) {
                await loadCuratedPlaylists();
            }

            renderCuratedPlaylistSelectorList();
            curatedPlaylistSelectorModal.classList.add('active');
        }

        // Render curated playlist selector list
        function renderCuratedPlaylistSelectorList() {
            if (curatedPlaylists.length === 0) {
                curatedPlaylistSelectorList.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üìã</div>
                        <div class="empty-state-text">No curated playlists yet. Create one to get started!</div>
                    </div>
                `;
                return;
            }

            curatedPlaylistSelectorList.innerHTML = curatedPlaylists.map(playlist => `
                <div
                    class="playlist-selector-item"
                    data-curated-playlist-id="${playlist.id}"
                    style="padding: 16px; margin-bottom: 8px; border: 2px solid var(--border-color); border-radius: 12px; background: var(--card-bg); cursor: pointer; transition: all 0.2s; display: flex; align-items: center; gap: 12px;"
                    onmouseover="this.style.borderColor='var(--accent-color)'; this.style.background='var(--hover-bg, var(--card-bg))';"
                    onmouseout="this.style.borderColor='var(--border-color)'; this.style.background='var(--card-bg)';"
                >
                    <div class="playlist-selector-icon" style="font-size: 24px;">üìã</div>
                    <div class="playlist-selector-content" style="flex: 1;">
                        <div class="playlist-selector-name" style="font-weight: 600; color: var(--text-primary); margin-bottom: 4px;">${escapeHtml(playlist.name)}</div>
                        <div class="playlist-selector-meta" style="font-size: 12px; color: var(--text-secondary);">${playlist.type === 'curated_playlist' ? 'Curated Playlist' : 'Multi-Channel Radio'}</div>
                    </div>
                </div>
            `).join('');

            // Add click handlers (scope to curated playlist selector list only)
            curatedPlaylistSelectorList.querySelectorAll('.playlist-selector-item').forEach(item => {
                item.addEventListener('click', () => {
                    const curatedPlaylistId = item.dataset.curatedPlaylistId;
                    addStationToCuratedPlaylist(pendingCuratedPlaylistStation, curatedPlaylistId, pendingCuratedPlaylistIsExternal);
                });
            });
        }

        // Add station to curated playlist
        async function addStationToCuratedPlaylist(station, curatedPlaylistId, isExternal) {
            try {
                let stationId = null;
                let externalStationId = null;

                if (isExternal) {
                    // External station from Radio Browser - ensure it's in external_stations table
                    externalStationId = await addExternalStation(station);
                } else {
                    // Internal curated station
                    stationId = station.id;
                }

                // Check if station is already in the playlist
                const { data: existing, error: checkError } = await supabase
                    .from('curated_playlist_items')
                    .select('id')
                    .eq('curated_playlist_id', curatedPlaylistId)
                    .eq(isExternal ? 'external_station_id' : 'station_id', isExternal ? externalStationId : stationId)
                    .single();

                if (existing) {
                    updateStatus('Station already in this curated playlist', 'info');
                    curatedPlaylistSelectorModal.classList.remove('active');
                    return;
                }

                // Add station to curated playlist
                const { error } = await supabase
                    .from('curated_playlist_items')
                    .insert({
                        curated_playlist_id: curatedPlaylistId,
                        station_id: stationId,
                        external_station_id: externalStationId
                    });

                if (error) throw error;

                updateStatus('Station added to curated playlist', 'success');
                curatedPlaylistSelectorModal.classList.remove('active');

                // Reload curated playlists to update carousels
                await loadCuratedPlaylists();

            } catch (error) {
                console.error('Error adding station to curated playlist:', error);
                updateStatus('Error adding station to curated playlist', 'error');
            }
        }

        // Show curated playlist form for create/edit
        async function showCuratedPlaylistForm(id = null) {
            editingCuratedPlaylistId = id;

            if (id) {
                // Fetch the playlist from database to ensure we have the latest data
                const { data, error } = await supabase
                    .from('curated_playlists')
                    .select('*')
                    .eq('id', id)
                    .single();

                if (error || !data) {
                    console.error('Error fetching playlist:', error);
                    return;
                }

                curatedPlaylistFormTitle.textContent = 'Edit Curated Playlist';
                curatedPlaylistName.value = data.name;
                curatedPlaylistType.value = data.type;
                curatedPlaylistDescription.value = data.description || '';
            } else {
                curatedPlaylistFormTitle.textContent = 'Create Curated Playlist';
                curatedPlaylistName.value = '';
                curatedPlaylistType.value = 'curated_playlist';
                curatedPlaylistDescription.value = '';
            }

            // Close admin modal if it's open
            if (document.getElementById('adminCuratedPlaylistsModal').classList.contains('active')) {
                document.getElementById('adminCuratedPlaylistsModal').classList.remove('active');
            }

            curatedPlaylistFormModal.classList.add('active');
        }

        // Expose to global scope for onclick handlers
        window.showCuratedPlaylistForm = showCuratedPlaylistForm;

        // Save curated playlist (create or update)
        async function saveCuratedPlaylist() {
            try {
                const name = curatedPlaylistName.value.trim();
                const type = curatedPlaylistType.value;
                const description = curatedPlaylistDescription.value.trim();

                if (!name) {
                    updateStatus('Please enter a playlist name', 'error');
                    return;
                }

                if (editingCuratedPlaylistId) {
                    // Update existing playlist
                    const { error } = await supabase
                        .from('curated_playlists')
                        .update({
                            name,
                            type,
                            description,
                            updated_at: new Date().toISOString()
                        })
                        .eq('id', editingCuratedPlaylistId);

                    if (error) throw error;
                    updateStatus('Curated playlist updated', 'success');
                } else {
                    // Create new playlist
                    const { error } = await supabase
                        .from('curated_playlists')
                        .insert({
                            name,
                            type,
                            description
                        });

                    if (error) throw error;
                    updateStatus('Curated playlist created', 'success');
                }

                curatedPlaylistFormModal.classList.remove('active');
                await loadCuratedPlaylists();

                // If there's a pending station, open the selector again
                if (pendingCuratedPlaylistStation) {
                    setTimeout(() => {
                        renderCuratedPlaylistSelectorList();
                        curatedPlaylistSelectorModal.classList.add('active');
                    }, 300);
                } else {
                    // If we came from the admin modal, reopen it
                    setTimeout(() => {
                        const adminModal = document.getElementById('adminCuratedPlaylistsModal');
                        if (adminModal && !pendingCuratedPlaylistStation) {
                            adminModal.classList.add('active');
                            loadAdminCuratedPlaylists();
                        }
                    }, 300);
                }

            } catch (error) {
                console.error('Error saving curated playlist:', error);
                updateStatus('Error saving curated playlist', 'error');
            }
        }

        // Delete curated playlist
        async function deleteCuratedPlaylist(id) {
            try {
                const { error } = await supabase
                    .from('curated_playlists')
                    .delete()
                    .eq('id', id);

                if (error) throw error;

                updateStatus('Curated playlist deleted', 'success');
                await loadCuratedPlaylists();

                // Reload admin list if in admin mode
                if (document.getElementById('adminCuratedPlaylistsModal').classList.contains('active')) {
                    await loadAdminCuratedPlaylists();
                }

            } catch (error) {
                console.error('Error deleting curated playlist:', error);
                updateStatus('Error deleting curated playlist', 'error');
            }
        }

        // Admin: Load curated playlists list
        let adminCuratedPlaylists = []; // Store for drag and drop
        async function loadAdminCuratedPlaylists() {
            const listContainer = document.getElementById('curatedPlaylistsList');

            // Fetch curated playlists directly
            try {
                const { data, error } = await supabase
                    .from('curated_playlists')
                    .select('*')
                    .order('sort_order', { ascending: true, nullsFirst: false })
                    .order('created_at', { ascending: false });

                if (error) throw error;

                const playlists = data || [];

                if (playlists.length === 0) {
                    listContainer.innerHTML = '<p style="text-align: center; padding: 20px; color: var(--text-secondary);">No curated playlists yet. Click "Add New Curated Playlist" to create one.</p>';
                    return;
                }

                // Load station counts for each playlist
                const playlistsWithCounts = await Promise.all(playlists.map(async (playlist) => {
                    const { data: itemsData, error: itemsError } = await supabase
                        .from('curated_playlist_items')
                        .select('id')
                        .eq('curated_playlist_id', playlist.id);

                    return {
                        ...playlist,
                        stationCount: itemsError ? 0 : (itemsData?.length || 0)
                    };
                }));

                // Store playlists for drag and drop
                adminCuratedPlaylists = playlistsWithCounts;

                listContainer.innerHTML = playlistsWithCounts.map((playlist, index) => `
                    <div class="curated-playlist-item"
                        draggable="true"
                        data-playlist-id="${playlist.id}"
                        data-playlist-index="${index}"
                        style="background: var(--card-bg); border-radius: 8px; padding: 15px; margin-bottom: 10px; display: flex; align-items: center; gap: 15px; cursor: move;">
                        <div style="flex: 1; min-width: 0;">
                            <div style="font-weight: 600; font-size: 16px; margin-bottom: 5px;">${escapeHtml(playlist.name)}</div>
                            <div style="font-size: 13px; color: var(--text-secondary);">
                                Type: ${playlist.type === 'multi_channel_radio' ? 'Multi-Channel Radio' : 'Curated Playlist'}
                                ‚Ä¢ Stations: ${playlist.stationCount}
                            </div>
                            ${playlist.description ? `<div style="font-size: 12px; color: var(--text-secondary); margin-top: 5px;">${escapeHtml(playlist.description)}</div>` : ''}
                            <div style="margin-top: 8px; display: flex; align-items: center; gap: 8px;">
                                <label style="font-size: 12px; color: var(--text-secondary);">Sort Order:</label>
                                <input type="number"
                                    id="sort-order-${playlist.id}"
                                    value="${playlist.sort_order !== null ? playlist.sort_order : index}"
                                    style="width: 80px; padding: 4px 8px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--bg-primary); color: var(--text-primary); font-size: 12px;"
                                    onclick="event.stopPropagation()"
                                    onchange="updateCuratedPlaylistSortOrder('${playlist.id}', this.value)">
                                <small style="font-size: 11px; color: var(--text-tertiary);">Drag to reorder or edit number</small>
                            </div>
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <button class="btn" onclick="event.stopPropagation(); showCuratedPlaylistForm('${playlist.id}')" style="padding: 8px 16px; font-size: 14px;">Edit</button>
                            <button class="btn" onclick="event.stopPropagation(); confirmDeleteCuratedPlaylist('${playlist.id}', '${escapeHtml(playlist.name).replace(/'/g, "\\'")}')" style="padding: 8px 16px; font-size: 14px; background: var(--danger-color);">Delete</button>
                        </div>
                    </div>
                `).join('');

                // Setup drag and drop
                setupCuratedPlaylistDragAndDrop();

            } catch (error) {
                console.error('Error loading admin curated playlists:', error);
                listContainer.innerHTML = '<p style="text-align: center; padding: 20px; color: var(--text-secondary);">Error loading playlists.</p>';
            }
        }

        // Confirm delete curated playlist from admin view
        function confirmDeleteCuratedPlaylist(id, name) {
            if (confirm(`Are you sure you want to delete "${name}"? This will also remove all stations from this playlist.`)) {
                deleteCuratedPlaylist(id);
            }
        }

        // Expose to global scope for onclick handlers
        window.confirmDeleteCuratedPlaylist = confirmDeleteCuratedPlaylist;

        // Setup drag and drop for curated playlist reordering
        function setupCuratedPlaylistDragAndDrop() {
            const playlistItems = document.querySelectorAll('.curated-playlist-item');
            let draggedElement = null;
            let draggedIndex = null;

            playlistItems.forEach((item, index) => {
                // Drag start
                item.addEventListener('dragstart', (e) => {
                    draggedElement = item;
                    draggedIndex = index;
                    item.style.opacity = '0.4';
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/html', item.innerHTML);
                });

                // Drag end
                item.addEventListener('dragend', (e) => {
                    item.style.opacity = '1';
                    // Remove drag-over class from all items
                    document.querySelectorAll('.curated-playlist-item').forEach(i => {
                        i.style.borderTop = '';
                    });
                });

                // Drag over
                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';

                    if (item !== draggedElement) {
                        item.style.borderTop = '2px solid var(--accent-color)';
                    }
                });

                // Drag leave
                item.addEventListener('dragleave', (e) => {
                    item.style.borderTop = '';
                });

                // Drop
                item.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    item.style.borderTop = '';

                    if (draggedElement !== item) {
                        // Get the indices
                        const dropIndex = Array.from(playlistItems).indexOf(item);

                        // Reorder the playlists array
                        const movedPlaylist = adminCuratedPlaylists.splice(draggedIndex, 1)[0];
                        adminCuratedPlaylists.splice(dropIndex, 0, movedPlaylist);

                        // Update sort orders and save to database
                        await updateCuratedPlaylistOrder();

                        // Re-render the list
                        await loadAdminCuratedPlaylists();
                    }
                });
            });
        }

        // Update curated playlist order in database
        async function updateCuratedPlaylistOrder() {
            try {
                // Update each playlist with its new sort_order
                const updates = adminCuratedPlaylists.map((playlist, index) => {
                    return supabase
                        .from('curated_playlists')
                        .update({
                            sort_order: index,
                            updated_at: new Date().toISOString()
                        })
                        .eq('id', playlist.id);
                });

                await Promise.all(updates);
                updateStatus('Playlist order updated', 'success');

                // Reload curated playlists to update Discover modal
                await loadCuratedPlaylists();

            } catch (error) {
                console.error('Error updating curated playlist order:', error);
                updateStatus('Error updating playlist order', 'error');
            }
        }

        // Update curated playlist sort order (manual input)
        async function updateCuratedPlaylistSortOrder(playlistId, newOrder) {
            try {
                const sortOrder = parseInt(newOrder);

                const { error } = await supabase
                    .from('curated_playlists')
                    .update({
                        sort_order: sortOrder,
                        updated_at: new Date().toISOString()
                    })
                    .eq('id', playlistId);

                if (error) throw error;

                updateStatus('Sort order updated', 'success');

                // Reload curated playlists to update Discover modal
                await loadCuratedPlaylists();

                // Reload admin list to reflect new order
                await loadAdminCuratedPlaylists();

            } catch (error) {
                console.error('Error updating sort order:', error);
                updateStatus('Error updating sort order', 'error');

                // Reload admin list to restore original value
                await loadAdminCuratedPlaylists();
            }
        }

        // Expose to global scope for onchange handlers
        window.updateCuratedPlaylistSortOrder = updateCuratedPlaylistSortOrder;

        // Load playlist stations (includes both internal and external stations)
        async function loadPlaylistStations(playlistId) {
            try {
                const { data, error } = await supabase
                    .from('playlist_items')
                    .select('*, radio_stations(*), external_stations(*)')
                    .eq('playlist_id', playlistId)
                    .order('created_at');

                if (error) throw error;

                playlistStations = data.map(item => {
                    if (item.external_stations) {
                        // External station from radio-browser
                        const ext = item.external_stations;
                        return {
                            id: ext.id,
                            name: ext.name,
                            url: ext.url_resolved || ext.url,
                            icon_url: ext.icon_url || ext.favicon || '',
                            genres: ext.genres || [],
                            call_letters: '',
                            frequency: '',
                            country: ext.country,
                            is_external: true,
                            external_id: item.external_station_id  // Use the foreign key from playlist_items, not ext.id
                        };
                    } else {
                        // Internal station
                        return item.radio_stations;
                    }
                });
                renderPlaylistStations();

            } catch (error) {
                console.error('Error loading playlist stations:', error);
            }
        }

        // Load overview modal with carousels
        async function loadOverviewModal() {
            // Load recent stations
            const recentStations = await getMostRecentStations(10);
            renderCarousel('recentTrack', recentStations, 'station');

            // Load most played stations
            const playedStations = await getMostPlayedStations(10);
            await renderMostPlayedList(playedStations);

            // Load playlists with their stations for collage
            await loadPlaylists();

            // Load stations for each playlist (for artwork collage)
            const playlistsWithStations = await Promise.all(playlists.map(async (playlist) => {
                try {
                    const { data, error } = await supabase
                        .from('playlist_items')
                        .select('*, radio_stations(*), external_stations(*)')
                        .eq('playlist_id', playlist.id)
                        .order('created_at')
                        .limit(12); // Load extra stations to ensure we find 4 with icons

                    if (error) throw error;

                    const stationsData = data ? data.map(item => {
                        if (item.external_stations) {
                            // External station from radio-browser
                            const ext = item.external_stations;
                            return {
                                id: ext.id,
                                name: ext.name,
                                url: ext.url_resolved || ext.url,
                                icon_url: ext.icon_url || ext.favicon || '',
                                genres: ext.genres || [],
                                call_letters: '',
                                frequency: '',
                                country: ext.country,
                                is_external: true,
                                external_id: ext.id
                            };
                        } else {
                            // Internal station
                            return item.radio_stations;
                        }
                    }) : [];

                    return {
                        ...playlist,
                        stations: stationsData
                    };
                } catch (error) {
                    console.error('Error loading playlist stations:', error);
                    return {
                        ...playlist,
                        stations: []
                    };
                }
            }));

            renderCarousel('playlistsTrack', playlistsWithStations, 'playlist');

            // Setup carousel navigation
            setupCarouselNavigation('recent', 'recentTrack', 'recentPrev', 'recentNext');
            setupCarouselNavigation('playlists', 'playlistsTrack', 'playlistsPrev', 'playlistsNext');
        }

        // Load discover modal with explore section
        async function loadDiscoverModal() {
            // Load curated playlists if not already loaded
            if (curatedPlaylists.length === 0) {
                const { data, error } = await supabase
                    .from('curated_playlists')
                    .select('*')
                    .order('sort_order', { ascending: true, nullsFirst: false })
                    .order('created_at', { ascending: false });

                if (!error) {
                    curatedPlaylists = data || [];
                }
            }

            // Render curated playlists in Discover modal
            await renderCuratedPlaylistsInDiscoverModal();

            // Render preset searches carousels
            await renderTagPresetsCarousel();
            await renderPresetSearchesCarousel();

            // Load recent stations
            const recentStations = await getMostRecentStations(10);

            // Load most played stations
            const playedStations = await getMostPlayedStations(10);

            // Load Explore section
            await loadDiscoverExploreSection(recentStations, playedStations);
        }

        // Render curated playlists in Discover modal
        // Store all curated playlists for "View All" modal
        let allCuratedPlaylistsWithStations = [];

        async function renderCuratedPlaylistsInDiscoverModal() {
            const curatedPlaylistsSection = document.getElementById('discoverCuratedPlaylistsSection');
            const multiChannelRadioSection = document.getElementById('discoverMultiChannelRadioSection');

            // Separate playlists by type
            const curatedPlaylistItems = curatedPlaylists.filter(p => p.type === 'curated_playlist');
            const multiChannelRadioItems = curatedPlaylists.filter(p => p.type === 'multi_channel_radio');

            // Load stations for each curated playlist
            const curatedPlaylistsWithStations = await Promise.all(curatedPlaylistItems.map(async (playlist) => {
                return await loadCuratedPlaylistStations(playlist);
            }));

            // Store all playlists for "View All" modal
            allCuratedPlaylistsWithStations = curatedPlaylistsWithStations;

            // Load stations for each multi-channel radio
            const multiChannelRadioWithStations = await Promise.all(multiChannelRadioItems.map(async (playlist) => {
                return await loadCuratedPlaylistStations(playlist);
            }));

            // Render Curated Playlists carousel (limit to 8 items)
            if (curatedPlaylistsWithStations.length > 0) {
                const limitedPlaylists = curatedPlaylistsWithStations.slice(0, 8);
                renderCarousel('discoverCuratedPlaylistsTrack', limitedPlaylists, 'curated-playlist');
                setupCarouselNavigation('discoverCuratedPlaylists', 'discoverCuratedPlaylistsTrack', 'discoverCuratedPlaylistsPrev', 'discoverCuratedPlaylistsNext');
                curatedPlaylistsSection.style.display = 'block';

                // Show/hide "View All" link based on whether there are more than 8 playlists
                const viewAllLink = document.getElementById('viewAllCuratedPlaylistsLink');
                if (viewAllLink) {
                    viewAllLink.style.display = curatedPlaylistsWithStations.length > 8 ? 'block' : 'none';
                }
            } else {
                curatedPlaylistsSection.style.display = 'none';
            }

            // Render Multi-Channel Radio carousel
            if (multiChannelRadioWithStations.length > 0) {
                renderCarousel('discoverMultiChannelRadioTrack', multiChannelRadioWithStations, 'curated-playlist');
                setupCarouselNavigation('discoverMultiChannelRadio', 'discoverMultiChannelRadioTrack', 'discoverMultiChannelRadioPrev', 'discoverMultiChannelRadioNext');
                multiChannelRadioSection.style.display = 'block';
            } else {
                multiChannelRadioSection.style.display = 'none';
            }
        }

        // Open All Curated Playlists modal and populate it with a grid of all playlists
        function openAllCuratedPlaylistsModal() {
            const modal = document.getElementById('allCuratedPlaylistsModal');
            const grid = document.getElementById('allCuratedPlaylistsGrid');

            // Clear existing content
            grid.innerHTML = '';

            // Render all playlists in a grid
            allCuratedPlaylistsWithStations.forEach((playlist) => {
                const stations = playlist.stations || [];
                const stationIcons = stations.filter(s => s && s.icon_url).slice(0, 4);

                // Multi-Channel Radio stations always show just the first station icon (no collage)
                const isMultiChannelRadio = playlist.type === 'multi_channel_radio';

                let imageContent;
                if (stationIcons.length === 0) {
                    // No stations with icons - show music note
                    imageContent = `<span style="font-size: 48px;">${MUSIC_NOTE_ICON}</span>`;
                } else if (stationIcons.length === 1 || isMultiChannelRadio) {
                    // Single station OR multi-channel radio - show first icon only
                    imageContent = `<img src="${escapeHtml(stationIcons[0].icon_url)}" alt="Playlist" onerror="this.onerror=null; this.src='${MUSIC_NOTE_DATA_URI}'" style="width: 100%; height: 100%; object-fit: cover; border-radius: 8px;">`;
                } else {
                    // Multiple stations (curated playlist) - create collage
                    const collageHTML = stationIcons.map(s => `
                        <div style="width: 50%; height: 50%; padding: 2px;">
                            <img src="${escapeHtml(s.icon_url)}" alt="${escapeHtml(s.name)}" onerror="this.onerror=null; this.src='${MUSIC_NOTE_DATA_URI}'" style="width: 100%; height: 100%; object-fit: cover; border-radius: 4px;">
                        </div>
                    `).join('');
                    imageContent = `<div style="display: flex; flex-wrap: wrap; width: 100%; height: 100%;">${collageHTML}</div>`;
                }

                // Check if user is admin
                const isAdmin = window.currentUser && window.currentUser.email && window.currentUser.email.split('@')[0] === 'keith.e.dragon';

                const playlistHTML = `
                    <div class="playlist-grid-item" data-playlist-id="${playlist.id}" data-playlist-type="curated-playlist" style="cursor: pointer; transition: transform 0.2s ease;">
                        ${isAdmin ? `
                        <button class="carousel-item-menu-btn" data-curated-playlist-id="${playlist.id}" onclick="event.stopPropagation()" style="position: absolute; top: 8px; right: 8px; z-index: 10;">‚ãÆ</button>
                        <div class="carousel-item-dropdown" style="position: absolute; top: 32px; right: 8px; z-index: 20;">
                            <div class="dropdown-item" data-action="edit-curated-playlist" data-curated-playlist-id="${playlist.id}">
                                <span>‚úèÔ∏è</span> Edit
                            </div>
                            <div class="dropdown-item danger" data-action="delete-curated-playlist" data-curated-playlist-id="${playlist.id}">
                                <span>üóëÔ∏è</span> Delete
                            </div>
                        </div>
                        ` : ''}
                        <div style="position: relative; width: 100%; aspect-ratio: 1; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 8px; overflow: hidden; display: flex; align-items: center; justify-content: center;">
                            ${imageContent}
                        </div>
                        <div style="margin-top: 12px;">
                            <div style="font-weight: 600; font-size: 14px; color: var(--text-primary); margin-bottom: 4px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${escapeHtml(playlist.name)}</div>
                            ${playlist.description ? `<div style="font-size: 12px; color: var(--text-secondary); overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;">${escapeHtml(playlist.description)}</div>` : ''}
                        </div>
                    </div>
                `;

                grid.innerHTML += playlistHTML;
            });

            // Add click handlers to playlist items
            grid.querySelectorAll('.playlist-grid-item').forEach((item) => {
                item.addEventListener('click', async (e) => {
                    const playlistId = parseInt(item.dataset.playlistId);
                    const playlist = allCuratedPlaylistsWithStations.find(p => p.id === playlistId);

                    if (playlist) {
                        // Close this modal
                        modal.classList.remove('active');

                        // Open playlist modal
                        openCuratedPlaylistModal(playlist);
                    }
                });

                // Add hover effect
                item.addEventListener('mouseenter', () => {
                    item.style.transform = 'scale(1.05)';
                });
                item.addEventListener('mouseleave', () => {
                    item.style.transform = 'scale(1)';
                });
            });

            // Handle admin menu buttons if present
            if (window.currentUser && window.currentUser.email && window.currentUser.email.split('@')[0] === 'keith.e.dragon') {
                grid.querySelectorAll('.carousel-item-menu-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const dropdown = btn.nextElementSibling;
                        // Close all other dropdowns
                        document.querySelectorAll('.carousel-item-dropdown').forEach(d => {
                            if (d !== dropdown) d.classList.remove('active');
                        });
                        dropdown.classList.toggle('active');
                    });
                });

                // Handle dropdown actions
                grid.querySelectorAll('.dropdown-item').forEach(item => {
                    item.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        const action = item.dataset.action;
                        const playlistId = parseInt(item.dataset.curatedPlaylistId);

                        if (action === 'edit-curated-playlist') {
                            const playlist = allCuratedPlaylistsWithStations.find(p => p.id === playlistId);
                            if (playlist) {
                                modal.classList.remove('active');
                                openEditCuratedPlaylistModal(playlist);
                            }
                        } else if (action === 'delete-curated-playlist') {
                            if (confirm('Are you sure you want to delete this curated playlist?')) {
                                await deleteCuratedPlaylist(playlistId);
                                // Reload the modal
                                await renderCuratedPlaylistsInDiscoverModal();
                                openAllCuratedPlaylistsModal();
                            }
                        }

                        // Close dropdown
                        item.closest('.carousel-item-dropdown').classList.remove('active');
                    });
                });
            }

            // Open the modal
            modal.classList.add('active');
            pushToNavigationHistory('allCuratedPlaylistsModal');
        }

        // Fetch preset searches from database
        async function fetchPresetSearches() {
            try {
                const { data, error } = await supabase
                    .from('preset_searches')
                    .select('*')
                    .order('display_order', { ascending: true });

                if (error) {
                    console.error('Error fetching preset searches:', error);
                    return [];
                }

                return data || [];
            } catch (err) {
                console.error('Error fetching preset searches:', err);
                return [];
            }
        }

        // Render preset searches carousel in Discover modal (name-based searches only)
        async function renderPresetSearchesCarousel() {
            const presetSearchesSection = document.getElementById('discoverPresetSearchesSection');
            const allPresetSearches = await fetchPresetSearches();

            // Filter for name-based searches (searches that have station_name and no tags)
            const nameBasedSearches = allPresetSearches.filter(preset =>
                preset.station_name && preset.station_name.trim() !== ''
            );

            if (nameBasedSearches.length > 0) {
                renderCarousel('discoverPresetSearchesTrack', nameBasedSearches, 'preset-search');
                setupCarouselNavigation('discoverPresetSearches', 'discoverPresetSearchesTrack', 'discoverPresetSearchesPrev', 'discoverPresetSearchesNext');
                presetSearchesSection.style.display = 'block';
            } else {
                presetSearchesSection.style.display = 'none';
            }
        }

        // Render tag-based preset searches carousel in Discover modal
        async function renderTagPresetsCarousel() {
            const tagPresetsSection = document.getElementById('discoverTagPresetsSection');
            const allPresetSearches = await fetchPresetSearches();

            // Filter for tag-based searches (searches that have tags)
            const tagBasedSearches = allPresetSearches.filter(preset =>
                preset.tags && preset.tags.trim() !== ''
            );

            if (tagBasedSearches.length > 0) {
                renderCarousel('discoverTagPresetsTrack', tagBasedSearches, 'preset-search');
                setupCarouselNavigation('discoverTagPresets', 'discoverTagPresetsTrack', 'discoverTagPresetsPrev', 'discoverTagPresetsNext');
                tagPresetsSection.style.display = 'block';
            } else {
                tagPresetsSection.style.display = 'none';
            }
        }

        // Execute a preset search and display results
        async function executePresetSearch(preset) {
            // Close discover modal
            closeAllModals();

            // Open radio database modal
            radioDatabaseModal.classList.add('active');
            pushToNavigationHistory('radioDatabaseModal');

            // Hide search input and all filter controls
            const searchContainer = radioDatabaseSearchInput.parentElement.parentElement;
            const filterControls = document.querySelector('#radioDatabaseModal .filter-controls');
            const advancedFiltersButton = document.getElementById('toggleAdvancedFilters');
            const advancedFiltersPanel = document.getElementById('advancedFiltersPanel');

            searchContainer.style.display = 'none';
            if (filterControls) filterControls.style.display = 'none';
            if (advancedFiltersButton) advancedFiltersButton.style.display = 'none';
            if (advancedFiltersPanel) advancedFiltersPanel.style.display = 'none';

            // Set the title to show which preset is being displayed
            const modalTitle = radioDatabaseModal.querySelector('.modal-title');
            const originalTitle = modalTitle.textContent;
            modalTitle.textContent = `Results: ${preset.name}`;

            // Store original state to restore later
            window.presetSearchActive = {
                originalTitle: originalTitle,
                searchContainer: searchContainer,
                filterControls: filterControls,
                advancedFiltersButton: advancedFiltersButton,
                advancedFiltersPanel: advancedFiltersPanel
            };

            // Build search parameters
            const params = new URLSearchParams();
            if (preset.station_name) params.append('name', preset.station_name);
            if (preset.country) params.append('country', preset.country);
            if (preset.language) params.append('language', preset.language);
            if (preset.tags) {
                // Use first tag if comma-separated
                const firstTag = preset.tags.split(',')[0].trim();
                params.append('tag', firstTag);
            }

            // Always sort by votes (most popular)
            params.append('limit', '500');
            params.append('order', 'votes');
            params.append('reverse', 'true');
            params.append('hidebroken', 'true');

            try {
                // Fetch from Radio Browser API
                const response = await fetch(`${RADIO_BROWSER_API_BASE}/stations/search?${params.toString()}`);
                const results = await response.json();

                // Apply any advanced filters
                const filteredResults = applyAdvancedFilters(results);

                // Render results
                renderRadioBrowserResults(filteredResults, 1);
            } catch (error) {
                console.error('Error executing preset search:', error);
                radioDatabaseResults.innerHTML = '<p style="text-align: center; padding: 20px;">Error loading stations. Please try again.</p>';
            }
        }

        // Admin: Load preset searches list
        let adminPresetSearches = []; // Store for drag and drop
        async function loadAdminPresetSearches() {
            const listContainer = document.getElementById('presetSearchesList');
            const presetSearches = await fetchPresetSearches();

            if (presetSearches.length === 0) {
                listContainer.innerHTML = '<p style="text-align: center; padding: 20px; color: var(--text-secondary);">No preset searches yet. Click "Add New Preset Search" to create one.</p>';
                return;
            }

            // Store preset searches for drag and drop
            adminPresetSearches = presetSearches;

            listContainer.innerHTML = presetSearches.map((preset, index) => `
                <div class="preset-search-item"
                    draggable="true"
                    data-preset-id="${preset.id}"
                    data-preset-index="${index}"
                    style="background: var(--card-bg); border-radius: 8px; padding: 15px; margin-bottom: 10px; display: flex; align-items: center; gap: 15px; cursor: move;">
                    <div style="width: 60px; height: 60px; border-radius: 8px; overflow: hidden; flex-shrink: 0; background: var(--bg-secondary);">
                        ${preset.image_url ? `<img src="${escapeHtml(preset.image_url)}" alt="${escapeHtml(preset.name)}" style="width: 100%; height: 100%; object-fit: cover;" onerror="this.onerror=null; this.parentElement.innerHTML='üéµ';">` : '<div style="display: flex; align-items: center; justify-content: center; height: 100%; font-size: 24px;">üéµ</div>'}
                    </div>
                    <div style="flex: 1; min-width: 0;">
                        <div style="font-weight: 600; font-size: 16px; margin-bottom: 5px;">${escapeHtml(preset.name)}</div>
                        <div style="font-size: 13px; color: var(--text-secondary);">
                            ${[
                                preset.station_name ? `Station: ${escapeHtml(preset.station_name)}` : null,
                                preset.country ? `Country: ${escapeHtml(preset.country)}` : null,
                                preset.language ? `Language: ${escapeHtml(preset.language)}` : null,
                                preset.tags ? `Tags: ${escapeHtml(preset.tags)}` : null
                            ].filter(Boolean).join(' ‚Ä¢ ') || 'All stations'}
                        </div>
                        ${preset.description ? `<div style="font-size: 12px; color: var(--text-secondary); margin-top: 5px;">${escapeHtml(preset.description)}</div>` : ''}
                        <div style="margin-top: 8px; display: flex; align-items: center; gap: 8px;">
                            <label style="font-size: 12px; color: var(--text-secondary);">Display Order:</label>
                            <input type="number"
                                id="display-order-${preset.id}"
                                value="${preset.display_order !== null ? preset.display_order : index}"
                                style="width: 80px; padding: 4px 8px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--bg-primary); color: var(--text-primary); font-size: 12px;"
                                onclick="event.stopPropagation()"
                                onchange="updatePresetSearchDisplayOrder('${preset.id}', this.value)">
                            <small style="font-size: 11px; color: var(--text-tertiary);">Drag to reorder or edit number</small>
                        </div>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button class="btn" onclick="event.stopPropagation(); showPresetSearchForm('${preset.id}')" style="padding: 8px 16px; font-size: 14px;">Edit</button>
                        <button class="btn" onclick="event.stopPropagation(); deletePresetSearch('${preset.id}')" style="padding: 8px 16px; font-size: 14px; background: var(--danger-color);">Delete</button>
                    </div>
                </div>
            `).join('');

            // Setup drag and drop
            setupPresetSearchDragAndDrop();
        }

        // Setup drag and drop for preset search reordering
        function setupPresetSearchDragAndDrop() {
            const presetItems = document.querySelectorAll('.preset-search-item');
            let draggedElement = null;
            let draggedIndex = null;

            presetItems.forEach((item, index) => {
                // Drag start
                item.addEventListener('dragstart', (e) => {
                    draggedElement = item;
                    draggedIndex = index;
                    item.style.opacity = '0.4';
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/html', item.innerHTML);
                });

                // Drag end
                item.addEventListener('dragend', (e) => {
                    item.style.opacity = '1';
                    // Remove drag-over class from all items
                    document.querySelectorAll('.preset-search-item').forEach(i => {
                        i.style.borderTop = '';
                    });
                });

                // Drag over
                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';

                    if (item !== draggedElement) {
                        item.style.borderTop = '2px solid var(--accent-color)';
                    }
                });

                // Drag leave
                item.addEventListener('dragleave', (e) => {
                    item.style.borderTop = '';
                });

                // Drop
                item.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    item.style.borderTop = '';

                    if (draggedElement !== item) {
                        // Get the indices
                        const dropIndex = Array.from(presetItems).indexOf(item);

                        // Reorder the preset searches array
                        const movedPreset = adminPresetSearches.splice(draggedIndex, 1)[0];
                        adminPresetSearches.splice(dropIndex, 0, movedPreset);

                        // Update display orders and save to database
                        await updatePresetSearchOrder();

                        // Re-render the list
                        await loadAdminPresetSearches();
                    }
                });
            });
        }

        // Update preset search order in database
        async function updatePresetSearchOrder() {
            try {
                // Update each preset search with its new display_order
                const updates = adminPresetSearches.map((preset, index) => {
                    return supabase
                        .from('preset_searches')
                        .update({
                            display_order: index,
                            updated_at: new Date().toISOString()
                        })
                        .eq('id', preset.id);
                });

                await Promise.all(updates);
                updateStatus('Preset search order updated', 'success');

                // Reload preset searches to update Discover modal
                await renderTagPresetsCarousel();
                await renderPresetSearchesCarousel();

            } catch (error) {
                console.error('Error updating preset search order:', error);
                updateStatus('Error updating preset search order', 'error');
            }
        }

        // Update preset search display order (manual input)
        async function updatePresetSearchDisplayOrder(presetId, newOrder) {
            try {
                const displayOrder = parseInt(newOrder);

                const { error } = await supabase
                    .from('preset_searches')
                    .update({
                        display_order: displayOrder,
                        updated_at: new Date().toISOString()
                    })
                    .eq('id', presetId);

                if (error) throw error;

                updateStatus('Display order updated', 'success');

                // Reload preset searches to update Discover modal
                await renderTagPresetsCarousel();
                await renderPresetSearchesCarousel();

                // Reload admin list to reflect new order
                await loadAdminPresetSearches();

            } catch (error) {
                console.error('Error updating display order:', error);
                updateStatus('Error updating display order', 'error');

                // Reload admin list to restore original value
                await loadAdminPresetSearches();
            }
        }

        // Expose to global scope for onclick handlers
        window.updatePresetSearchDisplayOrder = updatePresetSearchDisplayOrder;

        // Admin: Show preset search form (for create or edit)
        let currentEditingPresetId = null;
        async function showPresetSearchForm(presetId = null) {
            const formModal = document.getElementById('presetSearchFormModal');
            const formTitle = document.getElementById('presetSearchFormTitle');
            const form = document.getElementById('presetSearchForm');

            // Reset form
            form.reset();
            currentEditingPresetId = presetId;

            if (presetId) {
                // Edit mode - load existing preset
                formTitle.textContent = 'Edit Preset Search';
                const { data, error } = await supabase
                    .from('preset_searches')
                    .select('*')
                    .eq('id', presetId)
                    .single();

                if (!error && data) {
                    document.getElementById('presetSearchName').value = data.name || '';
                    document.getElementById('presetSearchStationName').value = data.station_name || '';
                    document.getElementById('presetSearchCountry').value = data.country || '';
                    document.getElementById('presetSearchLanguage').value = data.language || '';
                    document.getElementById('presetSearchTags').value = data.tags || '';
                    document.getElementById('presetSearchImageUrl').value = data.image_url || '';
                    document.getElementById('presetSearchDescription').value = data.description || '';
                    document.getElementById('presetSearchDisplayOrder').value = data.display_order || 0;
                }
            } else {
                // Create mode
                formTitle.textContent = 'Create Preset Search';
                document.getElementById('presetSearchDisplayOrder').value = 0;
            }

            // Close admin list modal and open form modal
            document.getElementById('adminPresetSearchesModal').classList.remove('active');
            formModal.classList.add('active');
        }

        // Expose to global scope for onclick handlers
        window.showPresetSearchForm = showPresetSearchForm;

        // Admin: Save preset search (create or update)
        async function savePresetSearch(event) {
            event.preventDefault();

            const formData = {
                name: document.getElementById('presetSearchName').value.trim(),
                station_name: document.getElementById('presetSearchStationName').value.trim() || null,
                country: document.getElementById('presetSearchCountry').value.trim() || null,
                language: document.getElementById('presetSearchLanguage').value.trim() || null,
                tags: document.getElementById('presetSearchTags').value.trim() || null,
                image_url: document.getElementById('presetSearchImageUrl').value.trim() || null,
                description: document.getElementById('presetSearchDescription').value.trim() || null,
                display_order: parseInt(document.getElementById('presetSearchDisplayOrder').value) || 0
            };

            if (!formData.name) {
                alert('Name is required');
                return;
            }

            try {
                let result;
                if (currentEditingPresetId) {
                    // Update existing preset
                    result = await supabase
                        .from('preset_searches')
                        .update(formData)
                        .eq('id', currentEditingPresetId);
                } else {
                    // Create new preset
                    result = await supabase
                        .from('preset_searches')
                        .insert([formData]);
                }

                if (result.error) {
                    console.error('Error saving preset search:', result.error);
                    alert('Error saving preset search: ' + result.error.message);
                    return;
                }

                // Close form and reload admin list
                document.getElementById('presetSearchFormModal').classList.remove('active');
                document.getElementById('adminPresetSearchesModal').classList.add('active');
                await loadAdminPresetSearches();

                // Refresh the discover modal if it's open
                if (document.getElementById('discoverModal').classList.contains('active')) {
                    await renderTagPresetsCarousel();
                    await renderPresetSearchesCarousel();
                }
            } catch (error) {
                console.error('Error saving preset search:', error);
                alert('Error saving preset search. Please try again.');
            }
        }

        // Admin: Delete preset search
        async function deletePresetSearch(presetId) {
            const presetSearches = await fetchPresetSearches();
            const preset = presetSearches.find(p => p.id === presetId);

            if (!preset) return;

            if (!confirm(`Are you sure you want to delete "${preset.name}"?`)) {
                return;
            }

            try {
                const { error } = await supabase
                    .from('preset_searches')
                    .delete()
                    .eq('id', presetId);

                if (error) {
                    console.error('Error deleting preset search:', error);
                    alert('Error deleting preset search: ' + error.message);
                    return;
                }

                // Reload admin list
                await loadAdminPresetSearches();

                // Refresh the discover modal if it's open
                if (document.getElementById('discoverModal').classList.contains('active')) {
                    await renderTagPresetsCarousel();
                    await renderPresetSearchesCarousel();
                }
            } catch (error) {
                console.error('Error deleting preset search:', error);
                alert('Error deleting preset search. Please try again.');
            }
        }

        // Expose to global scope for onclick handlers
        window.deletePresetSearch = deletePresetSearch;

        // Shuffle array using Fisher-Yates algorithm
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Load Explore section with genre-based recommendations
        async function loadExploreSection(recentStations, playedStations) {
            const exploreSection = document.getElementById('exploreSection');
            const becauseListenedSection = document.getElementById('becauseListenedSection');
            const becauseLikeSection = document.getElementById('becauseLikeSection');

            let hasExploreContent = false;

            // "Because you listened to" - based on most recent station
            if (recentStations && recentStations.length > 0) {
                const mostRecentStation = recentStations[0];
                if (mostRecentStation.genres && mostRecentStation.genres.length > 0) {
                    const genre = Array.isArray(mostRecentStation.genres) ? mostRecentStation.genres[0] : mostRecentStation.genres;

                    // Find stations with the same genre (excluding the recent station itself)
                    const filteredStations = stations.filter(station => {
                        if (station.id === mostRecentStation.id) return false;
                        if (!station.genres) return false;

                        if (Array.isArray(station.genres)) {
                            return station.genres.some(g =>
                                g.toLowerCase() === genre.toLowerCase()
                            );
                        } else if (typeof station.genres === 'string') {
                            return station.genres.toLowerCase().includes(genre.toLowerCase());
                        }
                        return false;
                    });
                    // Shuffle and take up to 10 stations
                    const sameGenreStations = shuffleArray(filteredStations).slice(0, 10);

                    if (sameGenreStations.length > 0) {
                        document.getElementById('becauseListenedTitle').textContent = `Because you listened to ${genre}`;
                        renderCarousel('becauseListenedTrack', sameGenreStations, 'station');
                        setupCarouselNavigation('becauseListened', 'becauseListenedTrack', 'becauseListenedPrev', 'becauseListenedNext');
                        becauseListenedSection.style.display = 'block';
                        hasExploreContent = true;
                    }
                }
            }

            // "Because you like" - based on most played station
            if (playedStations && playedStations.length > 0) {
                const mostPlayedStation = playedStations[0];
                if (mostPlayedStation.genres && mostPlayedStation.genres.length > 0) {
                    const genre = Array.isArray(mostPlayedStation.genres) ? mostPlayedStation.genres[0] : mostPlayedStation.genres;

                    // Find stations with the same genre (excluding the most played station itself and any from "Because you listened")
                    const filteredStations = stations.filter(station => {
                        if (station.id === mostPlayedStation.id) return false;
                        if (!station.genres) return false;

                        if (Array.isArray(station.genres)) {
                            return station.genres.some(g =>
                                g.toLowerCase() === genre.toLowerCase()
                            );
                        } else if (typeof station.genres === 'string') {
                            return station.genres.toLowerCase().includes(genre.toLowerCase());
                        }
                        return false;
                    });
                    // Shuffle and take up to 10 stations
                    const sameGenreStations = shuffleArray(filteredStations).slice(0, 10);

                    if (sameGenreStations.length > 0) {
                        document.getElementById('becauseLikeTitle').textContent = `Because you like ${genre}`;
                        renderCarousel('becauseLikeTrack', sameGenreStations, 'station');
                        setupCarouselNavigation('becauseLike', 'becauseLikeTrack', 'becauseLikePrev', 'becauseLikeNext');
                        becauseLikeSection.style.display = 'block';
                        hasExploreContent = true;
                    }
                }
            }

            // Show/hide the entire explore section based on whether we have any content
            exploreSection.style.display = hasExploreContent ? 'block' : 'none';
        }

        // Load Discover Explore section with genre-based recommendations
        async function loadDiscoverExploreSection(recentStations, playedStations) {
            const exploreSection = document.getElementById('discoverExploreSection');
            const becauseListenedSection = document.getElementById('discoverBecauseListenedSection');
            const becauseLikeSection = document.getElementById('discoverBecauseLikeSection');

            let hasExploreContent = false;

            // "Because you listened to" - based on most recent station
            if (recentStations && recentStations.length > 0) {
                const mostRecentStation = recentStations[0];
                if (mostRecentStation.genres && mostRecentStation.genres.length > 0) {
                    const genre = Array.isArray(mostRecentStation.genres) ? mostRecentStation.genres[0] : mostRecentStation.genres;

                    // Find stations with the same genre (excluding the recent station itself)
                    const filteredStations = stations.filter(station => {
                        if (station.id === mostRecentStation.id) return false;
                        if (!station.genres) return false;

                        if (Array.isArray(station.genres)) {
                            return station.genres.some(g =>
                                g.toLowerCase() === genre.toLowerCase()
                            );
                        } else if (typeof station.genres === 'string') {
                            return station.genres.toLowerCase().includes(genre.toLowerCase());
                        }
                        return false;
                    });
                    // Shuffle and take up to 10 stations
                    const sameGenreStations = shuffleArray(filteredStations).slice(0, 10);

                    if (sameGenreStations.length > 0) {
                        document.getElementById('discoverBecauseListenedTitle').textContent = `Because you listened to ${genre}`;
                        renderCarousel('discoverBecauseListenedTrack', sameGenreStations, 'station');
                        setupCarouselNavigation('discoverBecauseListened', 'discoverBecauseListenedTrack', 'discoverBecauseListenedPrev', 'discoverBecauseListenedNext');
                        becauseListenedSection.style.display = 'block';
                        hasExploreContent = true;
                    }
                }
            }

            // "Because you like" - based on most played station
            if (playedStations && playedStations.length > 0) {
                const mostPlayedStation = playedStations[0];
                if (mostPlayedStation.genres && mostPlayedStation.genres.length > 0) {
                    const genre = Array.isArray(mostPlayedStation.genres) ? mostPlayedStation.genres[0] : mostPlayedStation.genres;

                    // Find stations with the same genre (excluding the most played station itself and any from "Because you listened")
                    const filteredStations = stations.filter(station => {
                        if (station.id === mostPlayedStation.id) return false;
                        if (!station.genres) return false;

                        if (Array.isArray(station.genres)) {
                            return station.genres.some(g =>
                                g.toLowerCase() === genre.toLowerCase()
                            );
                        } else if (typeof station.genres === 'string') {
                            return station.genres.toLowerCase().includes(genre.toLowerCase());
                        }
                        return false;
                    });
                    // Shuffle and take up to 10 stations
                    const sameGenreStations = shuffleArray(filteredStations).slice(0, 10);

                    if (sameGenreStations.length > 0) {
                        document.getElementById('discoverBecauseLikeTitle').textContent = `Because you like ${genre}`;
                        renderCarousel('discoverBecauseLikeTrack', sameGenreStations, 'station');
                        setupCarouselNavigation('discoverBecauseLike', 'discoverBecauseLikeTrack', 'discoverBecauseLikePrev', 'discoverBecauseLikeNext');
                        becauseLikeSection.style.display = 'block';
                        hasExploreContent = true;
                    }
                }
            }

            // Show/hide the entire explore section based on whether we have any content
            exploreSection.style.display = hasExploreContent ? 'block' : 'none';
        }

        // Render carousel items
        function renderCarousel(trackId, items, type) {
            const track = document.getElementById(trackId);

            if (!items || items.length === 0) {
                track.innerHTML = '<div class="carousel-empty">No items to display</div>';
                return;
            }

            const itemsHTML = items.map((item, index) => {
                if (type === 'station') {
                    return `
                        <div class="carousel-item" data-station-id="${item.id}" data-station-index="${index}" data-is-external="${item.is_external || false}">
                            <div class="carousel-item-image">
                                ${item.icon_url ? `<img src="${escapeHtml(item.icon_url)}" alt="${escapeHtml(item.name)}" onerror="this.onerror=null; this.src='${MUSIC_NOTE_DATA_URI}'">` : `<span class="carousel-item-icon">${MUSIC_NOTE_ICON}</span>`}
                            </div>
                            <div class="carousel-item-content">
                                <div class="carousel-item-title">${isStationCurated(item) ? VERIFIED_ICON : ''}${escapeHtml(item.name)}</div>
                            </div>
                        </div>
                    `;
                } else if (type === 'preset-search') {
                    // Check if user is admin (for preset search menu)
                    const isAdmin = window.currentUser && window.currentUser.email && window.currentUser.email.split('@')[0] === 'keith.e.dragon';

                    return `
                        <div class="preset-search-button" data-preset-id="${item.id}" data-preset-index="${index}">
                            ${isAdmin ? `
                            <button class="carousel-item-menu-btn" data-preset-id="${item.id}" onclick="event.stopPropagation()">‚ãÆ</button>
                            <div class="carousel-item-dropdown">
                                <div class="dropdown-item" data-action="edit-preset-search" data-preset-id="${item.id}">
                                    <span>‚úèÔ∏è</span> Edit
                                </div>
                                <div class="dropdown-item danger" data-action="delete-preset-search" data-preset-id="${item.id}">
                                    <span>üóëÔ∏è</span> Delete
                                </div>
                            </div>
                            ` : ''}
                            <div class="preset-search-icon">
                                ${item.image_url ? `<img src="${escapeHtml(item.image_url)}" alt="${escapeHtml(item.name)}" onerror="this.onerror=null; this.src='${MUSIC_NOTE_DATA_URI}'">` : `<span class="carousel-item-icon">${MUSIC_NOTE_ICON}</span>`}
                            </div>
                            <div class="preset-search-content">
                                <div class="preset-search-name">${escapeHtml(item.name)}</div>
                                ${item.description ? `<div class="preset-search-description">${escapeHtml(item.description)}</div>` : ''}
                            </div>
                        </div>
                    `;
                } else if (type === 'playlist' || type === 'curated-playlist') {
                    // Create a collage of station artworks (or single icon for multi-channel radio)
                    const stations = item.stations || [];
                    const stationIcons = stations.filter(s => s && s.icon_url).slice(0, 4);

                    // Multi-Channel Radio stations always show just the first station icon (no collage)
                    const isMultiChannelRadio = item.type === 'multi_channel_radio';

                    let imageContent;
                    if (stationIcons.length === 0) {
                        // No stations with icons - show music note
                        imageContent = `<span class="carousel-item-icon">${MUSIC_NOTE_ICON}</span>`;
                    } else if (stationIcons.length === 1 || isMultiChannelRadio) {
                        // Single station OR multi-channel radio - show first icon only
                        imageContent = `<img src="${escapeHtml(stationIcons[0].icon_url)}" alt="Playlist" onerror="this.onerror=null; this.src='${MUSIC_NOTE_DATA_URI}'">`;
                    } else {
                        // Multiple stations (curated playlist) - create collage
                        imageContent = `
                            <div class="playlist-collage">
                                ${stationIcons.map(s => `
                                    <div class="playlist-collage-item">
                                        <img src="${escapeHtml(s.icon_url)}" alt="${escapeHtml(s.name)}" onerror="this.onerror=null; this.src='${MUSIC_NOTE_DATA_URI}'">
                                    </div>
                                `).join('')}
                            </div>
                        `;
                    }

                    // Check if user is admin (for curated playlists menu)
                    const isAdmin = type === 'curated-playlist' && window.currentUser && window.currentUser.email && window.currentUser.email.split('@')[0] === 'keith.e.dragon';

                    return `
                        <div class="carousel-item" data-playlist-id="${item.id}" data-playlist-type="${type}">
                            ${isAdmin ? `
                            <button class="carousel-item-menu-btn" data-curated-playlist-id="${item.id}" onclick="event.stopPropagation()">‚ãÆ</button>
                            <div class="carousel-item-dropdown">
                                <div class="dropdown-item" data-action="edit-curated-playlist" data-curated-playlist-id="${item.id}">
                                    <span>‚úèÔ∏è</span> Edit
                                </div>
                                <div class="dropdown-item danger" data-action="delete-curated-playlist" data-curated-playlist-id="${item.id}">
                                    <span>üóëÔ∏è</span> Delete
                                </div>
                            </div>
                            ` : ''}
                            <div class="carousel-item-image">
                                ${imageContent}
                            </div>
                            <div class="carousel-item-content">
                                <div class="carousel-item-title">${escapeHtml(item.name)}</div>
                                ${item.description ? `<div class="carousel-item-subtitle">${escapeHtml(item.description)}</div>` : ''}
                            </div>
                        </div>
                    `;
                }
            });

            // For preset-search, group items into columns of 4
            if (type === 'preset-search') {
                const columns = [];

                // Group buttons into columns of 4
                for (let i = 0; i < itemsHTML.length; i += 4) {
                    const columnButtons = itemsHTML.slice(i, i + 4);
                    columns.push(`
                        <div class="preset-search-column">
                            ${columnButtons.join('')}
                        </div>
                    `);
                }

                track.innerHTML = columns.join('');
            } else {
                track.innerHTML = itemsHTML.join('');
            }

            // Add click handlers
            const itemSelector = type === 'preset-search' ? '.preset-search-button' : '.carousel-item';
            track.querySelectorAll(itemSelector).forEach(item => {
                item.addEventListener('click', (e) => {
                    // Don't open playlist if clicking menu button or dropdown
                    if (e.target.closest('.carousel-item-menu-btn') || e.target.closest('.carousel-item-dropdown')) {
                        return;
                    }

                    if (type === 'station') {
                        const stationIndex = parseInt(item.dataset.stationIndex);
                        const station = items[stationIndex];
                        if (station) {
                            selectStation(station);
                            overviewModal.classList.remove('active');
                        }
                    } else if (type === 'preset-search') {
                        const presetIndex = parseInt(item.dataset.presetIndex);
                        const preset = items[presetIndex];
                        if (preset) {
                            executePresetSearch(preset);
                        }
                    } else if (type === 'playlist') {
                        const playlistId = item.dataset.playlistId; // Don't parseInt - IDs are UUIDs (strings)
                        openPlaylist(playlistId);
                        overviewModal.classList.remove('active');
                    } else if (type === 'curated-playlist') {
                        const playlistId = item.dataset.playlistId;
                        openCuratedPlaylist(playlistId);
                        browseStationsModal.classList.remove('active');
                    }
                });
            });

            // Add event listeners for curated playlist menu buttons
            if (type === 'curated-playlist') {
                track.querySelectorAll('.carousel-item-menu-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const dropdown = btn.nextElementSibling;

                        // Close all other dropdowns in this track
                        track.querySelectorAll('.carousel-item-dropdown').forEach(d => {
                            if (d !== dropdown) d.classList.remove('active');
                        });

                        dropdown.classList.toggle('active');
                    });
                });

                // Add event listeners for dropdown actions
                track.querySelectorAll('.carousel-item-dropdown .dropdown-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const action = item.dataset.action;
                        const curatedPlaylistId = item.dataset.curatedPlaylistId;

                        if (action === 'edit-curated-playlist') {
                            showCuratedPlaylistForm(curatedPlaylistId);
                            track.querySelectorAll('.carousel-item-dropdown').forEach(d => d.classList.remove('active'));
                        } else if (action === 'delete-curated-playlist') {
                            const playlist = curatedPlaylists.find(p => p.id === curatedPlaylistId);
                            if (playlist && confirm(`Are you sure you want to delete "${playlist.name}"?`)) {
                                deleteCuratedPlaylist(curatedPlaylistId);
                            }
                            track.querySelectorAll('.carousel-item-dropdown').forEach(d => d.classList.remove('active'));
                        }
                    });
                });
            }

            // Add event listeners for preset search menu buttons
            if (type === 'preset-search') {
                track.querySelectorAll('.carousel-item-menu-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const dropdown = btn.nextElementSibling;

                        // Close all other dropdowns in this track
                        track.querySelectorAll('.carousel-item-dropdown').forEach(d => {
                            if (d !== dropdown) d.classList.remove('active');
                        });

                        dropdown.classList.toggle('active');
                    });
                });

                // Add event listeners for dropdown actions
                track.querySelectorAll('.carousel-item-dropdown .dropdown-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const action = item.dataset.action;
                        const presetId = item.dataset.presetId;

                        if (action === 'edit-preset-search') {
                            showPresetSearchForm(presetId);
                            track.querySelectorAll('.carousel-item-dropdown').forEach(d => d.classList.remove('active'));
                        } else if (action === 'delete-preset-search') {
                            const preset = items.find(p => p.id === presetId);
                            if (preset && confirm(`Are you sure you want to delete "${preset.name}"?`)) {
                                deletePresetSearch(presetId);
                            }
                            track.querySelectorAll('.carousel-item-dropdown').forEach(d => d.classList.remove('active'));
                        }
                    });
                });
            }
        }

        // Render Most Played Stations as a list with currently playing song
        async function renderMostPlayedList(stations) {
            const listContainer = document.getElementById('playedStationsList');

            if (!stations || stations.length === 0) {
                listContainer.innerHTML = '<div class="stations-list-empty">No stations to display</div>';
                return;
            }

            // First render the list with loading states
            listContainer.innerHTML = stations.map((station, index) => {
                return `
                    <div class="station-list-item" data-station-id="${station.id}" data-station-index="${index}">
                        <div class="station-list-icon">
                            ${station.icon_url ? `<img src="${escapeHtml(station.icon_url)}" alt="${escapeHtml(station.name)}" onerror="this.onerror=null; this.src='${MUSIC_NOTE_DATA_URI}'">` : `<span class="station-list-icon-emoji">${MUSIC_NOTE_ICON}</span>`}
                        </div>
                        <div class="station-list-content">
                            <div class="station-list-name">${escapeHtml(station.name)}</div>
                            <div class="station-list-metadata-loading">Loading current track...</div>
                        </div>
                    </div>
                `;
            }).join('');

            // Add click handlers
            listContainer.querySelectorAll('.station-list-item').forEach(item => {
                item.addEventListener('click', () => {
                    const stationIndex = parseInt(item.dataset.stationIndex);
                    const station = stations[stationIndex];
                    if (station) {
                        selectStation(station);
                        overviewModal.classList.remove('active');
                    }
                });
            });

            // Fetch metadata for each station with concurrency limit to avoid race conditions
            // Limit to 2 concurrent metadata fetches to prevent AbortError from too many simultaneous streams
            await limitConcurrency(stations, 2, async (station, index) => {
                try {
                    const metadata = await fetchStationCurrentMetadata(station);

                    // Update the station's metadata display
                    const stationElement = listContainer.querySelector(`[data-station-id="${station.id}"]`);
                    if (!stationElement) return;

                    const contentDiv = stationElement.querySelector('.station-list-content');
                    if (!contentDiv) return;

                    // Remove loading message
                    const loadingDiv = contentDiv.querySelector('.station-list-metadata-loading');
                    if (loadingDiv) {
                        loadingDiv.remove();
                    }

                    if (metadata && (metadata.title || metadata.artist)) {
                        // Add metadata display
                        const metadataDiv = document.createElement('div');
                        metadataDiv.className = 'station-list-metadata';
                        metadataDiv.innerHTML = `
                            <div class="station-list-now-playing">
                                ${metadata.artist ? `${escapeHtml(metadata.artist)} - ` : ''}${escapeHtml(metadata.title || 'Unknown')}
                            </div>
                        `;
                        contentDiv.appendChild(metadataDiv);
                    } else {
                        // No metadata available
                        const emptyDiv = document.createElement('div');
                        emptyDiv.className = 'station-list-metadata-empty';
                        emptyDiv.textContent = 'No track info available';
                        contentDiv.appendChild(emptyDiv);
                    }
                } catch (error) {
                    console.warn('Error fetching metadata for station:', station.name, error);
                }
            });
        }

        // Setup carousel navigation
        function setupCarouselNavigation(name, trackId, prevBtnId, nextBtnId) {
            const track = document.getElementById(trackId);
            const prevBtn = document.getElementById(prevBtnId);
            const nextBtn = document.getElementById(nextBtnId);

            const scrollAmount = 200; // pixels to scroll

            prevBtn.addEventListener('click', () => {
                track.scrollBy({ left: -scrollAmount, behavior: 'smooth' });
            });

            nextBtn.addEventListener('click', () => {
                track.scrollBy({ left: scrollAmount, behavior: 'smooth' });
            });

            // Update button states based on scroll position
            const updateButtonStates = () => {
                const hasOverflow = track.scrollWidth > track.clientWidth;

                if (!hasOverflow) {
                    // No scrolling needed - disable both buttons
                    prevBtn.disabled = true;
                    nextBtn.disabled = true;
                    return;
                }

                const isAtStart = track.scrollLeft <= 0;
                const isAtEnd = track.scrollLeft + track.clientWidth >= track.scrollWidth - 1;

                prevBtn.disabled = isAtStart;
                nextBtn.disabled = isAtEnd;
            };

            track.addEventListener('scroll', updateButtonStates);

            // Wait for DOM to be fully rendered before checking button states
            setTimeout(updateButtonStates, 100);
        }

        // Create playlist
        async function createPlaylist(name, description) {
            try {
                console.log('Creating playlist with:', { name, description });

                // Ensure user is authenticated
                if (!window.currentUser || !window.currentUser.id) {
                    throw new Error('You must be signed in to create playlists. Please sign in and try again.');
                }

                // Get the max sort_order to add new playlist at the end
                const maxSortOrder = playlists.length > 0
                    ? Math.max(...playlists.map(p => p.sort_order || 0))
                    : -1;

                const { data, error } = await supabase
                    .from('playlists')
                    .insert([{
                        name,
                        description,
                        sort_order: maxSortOrder + 1,
                        user_id: window.currentUser.id
                    }])
                    .select();
                
                if (error) {
                    console.error('Supabase error:', error);
                    console.error('Error details:', JSON.stringify(error, null, 2));
                    throw error;
                }
                
                console.log('Playlist created successfully:', data);
                await loadPlaylists(true); // Force refresh to bypass cache
                alert('Playlist created successfully!');
                return data && data.length > 0 ? data[0] : null;
                
            } catch (error) {
                console.error('Error creating playlist:', error);
                alert(`Failed to create playlist: ${error.message || 'Unknown error'}\n\nCheck browser console for details.`);
                return null;
            }
        }
        
        // Update playlist
        async function updatePlaylist(id, name, description) {
            try {
                console.log('Updating playlist:', { id, name, description });
                
                const { data, error } = await supabase
                    .from('playlists')
                    .update({ name, description })
                    .eq('id', id)
                    .select();
                
                if (error) {
                    console.error('Supabase error:', error);
                    console.error('Error details:', JSON.stringify(error, null, 2));
                    throw error;
                }
                
                console.log('Playlist updated successfully:', data);
                await loadPlaylists(true); // Force refresh to bypass cache
                alert('Playlist updated successfully!');
                
            } catch (error) {
                console.error('Error updating playlist:', error);
                alert(`Failed to update playlist: ${error.message || 'Unknown error'}\n\nCheck browser console for details.`);
            }
        }
        
        // Delete playlist
        async function deletePlaylist(id) {
            try {
                // First delete all playlist items
                await supabase
                    .from('playlist_items')
                    .delete()
                    .eq('playlist_id', id);
                
                // Then delete the playlist
                const { error } = await supabase
                    .from('playlists')
                    .delete()
                    .eq('id', id);
                
                if (error) throw error;
                
                await loadPlaylists(true); // Force refresh to bypass cache
                
            } catch (error) {
                console.error('Error deleting playlist:', error);
                alert('Failed to delete playlist');
            }
        }
        
        // Add station to playlist (supports both internal and external stations)
        // Returns true if added successfully, false if already exists or error
        async function addStationToPlaylist(playlistId, stationId, externalStationId = null, showAlert = true) {
            try {
                // Check if station is already in playlist
                let existingQuery = supabase
                    .from('playlist_items')
                    .select('id')
                    .eq('playlist_id', playlistId);

                if (externalStationId) {
                    existingQuery = existingQuery.eq('external_station_id', externalStationId);
                } else {
                    existingQuery = existingQuery.eq('station_id', stationId);
                }

                const { data: existing } = await existingQuery.maybeSingle();

                if (existing) {
                    alert('Station is already in this playlist');
                    return false;
                }

                // Insert with either station_id or external_station_id
                const insertData = { playlist_id: playlistId };
                if (externalStationId) {
                    insertData.external_station_id = externalStationId;
                } else {
                    insertData.station_id = stationId;
                }

                const { error } = await supabase
                    .from('playlist_items')
                    .insert([insertData]);

                if (error) throw error;

                await loadPlaylists(true); // Force refresh to bypass cache

                // Show success message with station and playlist names (if requested)
                if (showAlert) {
                    const playlist = playlists.find(p => p.id === playlistId);
                    let stationName = 'Station';

                    if (stationId) {
                        const station = stations.find(s => s.id === stationId);
                        if (station) stationName = station.name;
                    } else if (externalStationId) {
                        // For external stations, try to find the name from recently added
                        stationName = 'Station';
                    }

                    if (playlist) {
                        alert(`‚úì Added "${stationName}" to "${playlist.name}"`);
                    }
                }

                return true;

            } catch (error) {
                console.error('Error adding station to playlist:', error);
                alert('Failed to add station to playlist');
                return false;
            }
        }
        
        // Remove station from playlist (supports both internal and external stations)
        async function removeStationFromPlaylist(playlistId, stationId, isExternal = false, externalId = null) {
            try {
                // Check if this is a curated playlist
                const isCuratedPlaylist = currentPlaylist && currentPlaylist.is_curated;
                const tableName = isCuratedPlaylist ? 'curated_playlist_items' : 'playlist_items';
                const playlistIdColumn = isCuratedPlaylist ? 'curated_playlist_id' : 'playlist_id';

                let deleteQuery = supabase
                    .from(tableName)
                    .delete()
                    .eq(playlistIdColumn, playlistId);

                // Use external_station_id for external stations, station_id for internal stations
                if (isExternal && externalId) {
                    deleteQuery = deleteQuery.eq('external_station_id', externalId);
                } else {
                    deleteQuery = deleteQuery.eq('station_id', stationId);
                }

                const { error } = await deleteQuery;

                if (error) throw error;

                // Reload the appropriate playlist type
                if (isCuratedPlaylist) {
                    await loadCuratedPlaylistStationsForModal(playlistId);
                    await loadCuratedPlaylists(); // Refresh carousels
                } else {
                    await loadPlaylistStations(playlistId);
                    await loadPlaylists(true); // Force refresh to bypass cache
                }

            } catch (error) {
                console.error('Error removing station from playlist:', error);
                alert('Failed to remove station from playlist');
            }
        }
        
        // Create station
        async function createStation(stationData) {
            try {
                console.log('Creating station with:', stationData);
                
                const { data, error } = await supabase
                    .from('radio_stations')
                    .insert([stationData])
                    .select();
                
                if (error) {
                    console.error('Supabase error:', error);
                    console.error('Error details:', JSON.stringify(error, null, 2));
                    throw error;
                }
                
                console.log('Station created successfully:', data);
                await loadStations(true); // Force refresh to bypass cache
                alert('Station created successfully!');
                return data && data.length > 0 ? data[0] : null;
                
            } catch (error) {
                console.error('Error creating station:', error);
                alert(`Failed to create station: ${error.message || 'Unknown error'}\n\nCheck browser console for details.`);
                return null;
            }
        }
        
        // Update station
        async function updateStation(id, stationData) {
            try {
                console.log('Updating station:', { id, stationData });
                
                const { data, error } = await supabase
                    .from('radio_stations')
                    .update(stationData)
                    .eq('id', id)
                    .select();
                
                if (error) {
                    console.error('Supabase error:', error);
                    console.error('Error details:', JSON.stringify(error, null, 2));
                    throw error;
                }
                
                console.log('Station updated successfully:', data);
                await loadStations(true); // Force refresh to bypass cache
                alert('Station updated successfully!');
                
            } catch (error) {
                console.error('Error updating station:', error);
                console.error('Error message:', error.message);
                console.error('Error details:', error.details);
                console.error('Error hint:', error.hint);
                alert(`Failed to update station: ${error.message || 'Unknown error'}\n\nCheck browser console for details.`);
            }
        }
        
        // Delete station
        async function deleteStation(id) {
            try {
                // First delete from all playlists
                await supabase
                    .from('playlist_items')
                    .delete()
                    .eq('station_id', id);
                
                // Then delete the station
                const { error } = await supabase
                    .from('radio_stations')
                    .delete()
                    .eq('id', id);
                
                if (error) throw error;
                
                await loadStations(true); // Force refresh to bypass cache
                await loadPlaylists(true); // Force refresh to bypass cache
                
            } catch (error) {
                console.error('Error deleting station:', error);
                alert('Failed to delete station');
            }
        }
        
        // ======================
        // UI FUNCTIONS
        // ======================
        
        // Render playlists list
        async function renderPlaylistsList() {
            // Apply grid view class if in grid mode
            if (playlistViewMode === 'grid') {
                playlistsList.classList.add('grid-view');
            } else {
                playlistsList.classList.remove('grid-view');
            }

            // Start with empty content (history buttons moved to main page)
            let htmlContent = '';

            if (playlists.length === 0) {
                htmlContent += `
                    <div class="empty-state">
                        <div class="empty-state-icon">üìù</div>
                        <div class="empty-state-text">No custom playlists yet. Create one to organize your favorite stations!</div>
                    </div>
                `;
            } else {
                // Load stations for each playlist (for artwork collage)
                const playlistsWithStations = await Promise.all(playlists.map(async (playlist) => {
                    try {
                        const { data, error } = await supabase
                            .from('playlist_items')
                            .select('*, radio_stations(*), external_stations(*)')
                            .eq('playlist_id', playlist.id)
                            .order('created_at')
                            .limit(12); // Load extra stations to ensure we find 4 with icons

                        if (error) throw error;

                        // Map to station objects, handling both internal and external stations
                        const stationsData = data ? data.map(item => {
                            if (item.external_stations) {
                                // External station from radio-browser
                                const ext = item.external_stations;
                                return {
                                    id: ext.id,
                                    name: ext.name,
                                    icon_url: ext.icon_url || ext.favicon || '',
                                    is_external: true
                                };
                            } else {
                                // Internal station
                                return item.radio_stations;
                            }
                        }) : [];

                        return {
                            ...playlist,
                            stations: stationsData
                        };
                    } catch (error) {
                        console.error('Error loading playlist stations:', error);
                        return {
                            ...playlist,
                            stations: []
                        };
                    }
                }));

                htmlContent += playlistsWithStations.map(playlist => {
                    const count = playlist.playlist_items?.[0]?.count || 0;

                    // Create a collage of station artworks (same logic as carousel)
                    const stations = playlist.stations || [];
                    const stationIcons = stations.filter(s => s && s.icon_url).slice(0, 4);

                    let iconContent;
                    if (stationIcons.length === 0) {
                        // No stations with icons - show music note
                        iconContent = MUSIC_NOTE_ICON;
                    } else if (stationIcons.length === 1) {
                        // Single station - show its icon as image
                        iconContent = `<img src="${escapeHtml(stationIcons[0].icon_url)}" alt="Playlist" onerror="this.onerror=null; this.src='${MUSIC_NOTE_DATA_URI}'">`;
                    } else {
                        // Multiple stations - create collage
                        iconContent = `
                            <div class="playlist-collage">
                                ${stationIcons.map(s => `
                                    <div class="playlist-collage-item">
                                        <img src="${escapeHtml(s.icon_url)}" alt="${escapeHtml(s.name)}" onerror="this.onerror=null; this.src='${MUSIC_NOTE_DATA_URI}'">
                                    </div>
                                `).join('')}
                            </div>
                        `;
                    }

                    return `
                        <div class="playlist-item" data-id="${playlist.id}" draggable="true">
                            <div class="playlist-drag-handle">‚ãÆ‚ãÆ</div>
                            <div class="playlist-icon">${iconContent}</div>
                            <div class="playlist-info">
                                <div class="playlist-name">${escapeHtml(playlist.name)}</div>
                                <div class="playlist-count">${count} ${count === 1 ? 'station' : 'stations'}</div>
                            </div>
                            <button class="playlist-menu-btn" data-id="${playlist.id}">‚ãÆ</button>
                            <div class="playlist-dropdown">
                                <div class="dropdown-item" data-action="view" data-playlist-id="${playlist.id}">
                                    <span>üìª</span> View Playlist
                                </div>
                                <div class="dropdown-item" data-action="edit" data-playlist-id="${playlist.id}">
                                    <span>‚úèÔ∏è</span> Rename
                                </div>
                                <div class="dropdown-divider"></div>
                                <div class="dropdown-item danger" data-action="delete" data-playlist-id="${playlist.id}">
                                    <span>üóëÔ∏è</span> Delete
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
            }

            playlistsList.innerHTML = htmlContent;
            
            // Add event listeners for playlist items
            document.querySelectorAll('.playlist-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    if (!e.target.closest('.playlist-menu-btn') && !e.target.closest('.playlist-dropdown')) {
                        const id = item.dataset.id;
                        openPlaylist(id);
                    }
                });
            });
            
            // Setup drag and drop for reordering playlists
            setupPlaylistDragAndDrop();
            
            // Add event listeners for playlist menu buttons
            document.querySelectorAll('.playlist-menu-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const dropdown = btn.nextElementSibling;
                    
                    // Close all other dropdowns
                    document.querySelectorAll('.playlist-dropdown').forEach(d => {
                        if (d !== dropdown) d.classList.remove('active');
                    });
                    
                    dropdown.classList.toggle('active');
                });
            });
            
            // Add event listeners for dropdown items
            document.querySelectorAll('.playlist-dropdown .dropdown-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const action = item.dataset.action;
                    const playlistId = item.dataset.playlistId;
                    
                    if (!action || !playlistId) return;
                    
                    // Close dropdown
                    item.closest('.playlist-dropdown').classList.remove('active');
                    
                    if (action === 'view') {
                        openPlaylist(playlistId);
                    } else if (action === 'edit') {
                        editPlaylist(playlistId);
                    } else if (action === 'delete') {
                        confirmDeletePlaylist(playlistId);
                    }
                });
            });
        }
        
        // Setup drag and drop for playlist reordering
        function setupPlaylistDragAndDrop() {
            const playlistItems = document.querySelectorAll('.playlist-item');
            let draggedElement = null;
            let draggedIndex = null;
            
            playlistItems.forEach((item, index) => {
                // Drag start
                item.addEventListener('dragstart', (e) => {
                    draggedElement = item;
                    draggedIndex = index;
                    item.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/html', item.innerHTML);
                });
                
                // Drag end
                item.addEventListener('dragend', (e) => {
                    item.classList.remove('dragging');
                    // Remove drag-over class from all items
                    document.querySelectorAll('.playlist-item').forEach(i => {
                        i.classList.remove('drag-over');
                    });
                });
                
                // Drag over
                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    
                    if (item !== draggedElement) {
                        item.classList.add('drag-over');
                    }
                });
                
                // Drag leave
                item.addEventListener('dragleave', (e) => {
                    item.classList.remove('drag-over');
                });
                
                // Drop
                item.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    item.classList.remove('drag-over');
                    
                    if (draggedElement !== item) {
                        // Get the indices
                        const dropIndex = Array.from(playlistItems).indexOf(item);
                        
                        // Reorder the playlists array
                        const movedPlaylist = playlists.splice(draggedIndex, 1)[0];
                        playlists.splice(dropIndex, 0, movedPlaylist);
                        
                        // Update sort orders and save to database
                        await updatePlaylistOrder();
                        
                        // Re-render the list
                        renderPlaylistsList();
                    }
                });
            });
        }
        
        // Update playlist order in database
        async function updatePlaylistOrder() {
            try {
                // Update each playlist with its new sort_order
                const updates = playlists.map((playlist, index) => {
                    return supabase
                        .from('playlists')
                        .update({ sort_order: index })
                        .eq('id', playlist.id);
                });
                
                await Promise.all(updates);
                console.log('Playlist order updated successfully');
                
            } catch (error) {
                console.error('Error updating playlist order:', error);
                alert('Failed to save playlist order');
            }
        }
        
        // Render station list
        function renderStationList() {
            console.log('renderStationList called', {
                stationList: stationList,
                filteredStationsLength: filteredStations.length,
                stationsLength: stations.length
            });

            if (!stationList) {
                console.error('stationList element not found!');
                return;
            }

            // Apply grid view class if in grid mode
            if (stationViewMode === 'grid') {
                stationList.classList.add('grid-view');
            } else {
                stationList.classList.remove('grid-view');
            }

            if (filteredStations.length === 0) {
                stationList.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">${MUSIC_NOTE_ICON}</div>
                        <div class="empty-state-text">
                            ${stations.length === 0 ? 'No stations yet. Add one to get started!' : 'No stations found.'}
                        </div>
                    </div>
                `;
                updateCuratedStationsPagination(0);
                return;
            }

            // Calculate pagination
            const startIndex = (curatedStationsCurrentPage - 1) * curatedStationsItemsPerPage;
            const endIndex = startIndex + curatedStationsItemsPerPage;
            const paginatedStations = filteredStations.slice(startIndex, endIndex);

            stationList.innerHTML = paginatedStations.map(station => {
                // Handle genres as array or string
                const genresDisplay = station.genres && Array.isArray(station.genres)
                    ? station.genres.join(', ')
                    : (station.genres || 'No genres');
                
                // Build station details (call letters and frequency)
                const detailsParts = [];
                if (station.call_letters) {
                    detailsParts.push(station.call_letters);
                }
                if (station.frequency) {
                    detailsParts.push(station.frequency);
                }
                const detailsDisplay = detailsParts.length > 0 ? detailsParts.join(' ‚Ä¢ ') : '';

                // Check if current user is admin
                const isAdmin = window.currentUser && window.currentUser.email && window.currentUser.email.split('@')[0] === 'keith.e.dragon';

                return `
                <div class="station-item ${currentStation?.id === station.id ? 'selected' : ''}" data-id="${station.id}">
                    ${station.icon_url ?
                        `<img src="${station.icon_url}" class="station-icon" alt="${escapeHtml(station.name)}" onerror="this.onerror=null; this.src='${MUSIC_NOTE_DATA_URI}'">` :
                        `<div class="station-icon">${MUSIC_NOTE_ICON}</div>`
                    }
                    <div class="station-info">
                        <div class="station-name">${isStationCurated(station) ? VERIFIED_ICON : ''}${escapeHtml(station.name)}</div>
                        ${detailsDisplay ? `<div class="station-details">${escapeHtml(detailsDisplay)}</div>` : ''}
                        <div class="station-genres">${escapeHtml(genresDisplay)}</div>
                    </div>
                    <button class="station-menu-btn" data-id="${station.id}">‚ãÆ</button>
                    <div class="station-dropdown">
                        <div class="dropdown-item" data-action="add-to-playlist-modal" data-station-id="${station.id}">
                            <span>‚ûï</span> Add to Playlist
                        </div>
                        ${isAdmin ? `
                        <div class="dropdown-item" data-action="add-to-curated-playlist" data-station-id="${station.id}">
                            <span>‚≠ê</span> Add to Curated Playlist
                        </div>
                        <div class="dropdown-divider"></div>
                        <div class="dropdown-item" data-action="edit-station" data-station-id="${station.id}">
                            <span>‚úèÔ∏è</span> Edit Station
                        </div>
                        <div class="dropdown-item danger" data-action="delete-station" data-station-id="${station.id}">
                            <span>üóëÔ∏è</span> Delete Station
                        </div>
                        ` : ''}
                    </div>
                </div>
            `;
            }).join('');
            
            // Add event listeners
            document.querySelectorAll('.station-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    if (!e.target.closest('.station-menu-btn') && !e.target.closest('.station-dropdown')) {
                        const id = parseInt(item.dataset.id);
                        const station = stations.find(s => s.id === id);
                        selectStation(station);
                    }
                });
            });
            
            // Add event listeners for menu buttons
            document.querySelectorAll('.station-menu-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const dropdown = btn.nextElementSibling;
                    
                    // Close all other dropdowns
                    document.querySelectorAll('.station-dropdown').forEach(d => {
                        if (d !== dropdown) d.classList.remove('active');
                    });
                    
                    dropdown.classList.toggle('active');
                });
            });
            
            // Add hover/click listeners for submenus (mobile support)
            document.querySelectorAll('.dropdown-submenu').forEach(submenu => {
                // Support click for mobile
                submenu.addEventListener('click', (e) => {
                    if (e.target.closest('.dropdown-item') && !e.target.dataset.action) {
                        e.stopPropagation();
                        submenu.classList.toggle('active');
                    }
                });
                
                // Close submenu when clicking on backdrop (mobile)
                submenu.addEventListener('click', (e) => {
                    if (e.target === submenu && submenu.classList.contains('active')) {
                        submenu.classList.remove('active');
                    }
                });
            });
            
            // Add event listeners for dropdown actions
            document.querySelectorAll('.station-dropdown .dropdown-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const action = item.dataset.action;

                    if (action === 'add-to-playlist-modal') {
                        const stationId = parseInt(item.dataset.stationId);
                        const station = stations.find(s => s.id === stationId);
                        if (station) {
                            showPlaylistSelectorForCuratedStation(station);
                        }
                        document.querySelectorAll('.station-dropdown').forEach(d => d.classList.remove('active'));
                    } else if (action === 'add-to-curated-playlist') {
                        const stationId = parseInt(item.dataset.stationId);
                        const station = stations.find(s => s.id === stationId);
                        if (station) {
                            showCuratedPlaylistSelector(station, false);
                        }
                        document.querySelectorAll('.station-dropdown').forEach(d => d.classList.remove('active'));
                    } else if (action === 'edit-station') {
                        const stationId = parseInt(item.dataset.stationId);
                        editStation(stationId);
                        document.querySelectorAll('.station-dropdown').forEach(d => d.classList.remove('active'));
                    } else if (action === 'delete-station') {
                        const stationId = parseInt(item.dataset.stationId);
                        confirmDeleteStation(stationId);
                        document.querySelectorAll('.station-dropdown').forEach(d => d.classList.remove('active'));
                    }
                });
            });

            // Update pagination controls
            updateCuratedStationsPagination(paginatedStations.length);
        }

        // Update curated stations pagination controls
        function updateCuratedStationsPagination(resultsCount) {
            const curatedStationsPagination = document.getElementById('curatedStationsPagination');
            const curatedStationsPrevBtn = document.getElementById('curatedStationsPrevBtn');
            const curatedStationsNextBtn = document.getElementById('curatedStationsNextBtn');
            const curatedStationsPageInfo = document.getElementById('curatedStationsPageInfo');

            if (!curatedStationsPagination) return;

            if (resultsCount === 0) {
                curatedStationsPagination.style.display = 'none';
                return;
            }

            // Determine if Next button would be disabled (last page)
            const isLastPage = resultsCount < curatedStationsItemsPerPage;
            const isFirstPage = curatedStationsCurrentPage === 1;

            // Only show pagination if we're not on page 1 OR if there are more pages
            if (isFirstPage && isLastPage) {
                curatedStationsPagination.style.display = 'none';
                return;
            }

            curatedStationsPagination.style.display = 'flex';

            // Update page info
            curatedStationsPageInfo.textContent = `Page ${curatedStationsCurrentPage}`;

            // Update Previous button
            curatedStationsPrevBtn.disabled = isFirstPage;

            // Update Next button
            curatedStationsNextBtn.disabled = isLastPage;

            // Scroll station list container to top
            if (stationList) {
                stationList.scrollTop = 0;
            }
        }

        // Render playlist stations
        async function renderPlaylistStations() {
            // Check if admin and viewing curated playlist
            const isAdmin = window.currentUser && window.currentUser.email === 'keith.e.dragon@gmail.com';
            const isCuratedPlaylist = currentPlaylist && currentPlaylist.is_curated;
            const canReorder = isAdmin && isCuratedPlaylist;

            // Apply grid view class if in grid mode
            if (playlistStationViewMode === 'grid') {
                playlistStationList.classList.add('grid-view');
            } else {
                playlistStationList.classList.remove('grid-view');
            }

            if (playlistStations.length === 0) {
                playlistStationList.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">${MUSIC_NOTE_ICON}</div>
                        <div class="empty-state-text">No stations in this playlist yet.</div>
                    </div>
                `;
                return;
            }

            // Sort stations: curated stations first, then external stations
            // Preserve original order within each group
            playlistStations = playlistStations.sort((a, b) => {
                const aIsCurated = isStationCurated(a);
                const bIsCurated = isStationCurated(b);

                if (aIsCurated && !bIsCurated) return -1; // a comes first
                if (!aIsCurated && bIsCurated) return 1;  // b comes first
                return 0; // maintain original order for stations of the same type
            });

            playlistStationList.innerHTML = playlistStations.map((station, index) => {
                // Handle genres as array or string
                const genresDisplay = station.genres && Array.isArray(station.genres)
                    ? station.genres.join(', ')
                    : (station.genres || 'No genres');

                // Build station details (call letters and frequency)
                const detailsParts = [];
                if (station.call_letters) {
                    detailsParts.push(station.call_letters);
                }
                if (station.frequency) {
                    detailsParts.push(station.frequency);
                }
                const detailsDisplay = detailsParts.length > 0 ? detailsParts.join(' ‚Ä¢ ') : '';

                return `
                <div class="station-item ${currentStation?.id === station.id ? 'selected' : ''}"
                     data-id="${station.id}"
                     data-station-index="${index}"
                     ${canReorder ? 'draggable="true" style="cursor: move;"' : ''}>
                    ${canReorder ? '<div class="drag-handle" style="margin-right: 8px; color: var(--text-secondary); cursor: move;">‚ãÆ‚ãÆ</div>' : ''}
                    ${station.icon_url ?
                        `<img src="${station.icon_url}" class="station-icon" alt="${escapeHtml(station.name)}" onerror="this.onerror=null; this.src='${MUSIC_NOTE_DATA_URI}'">` :
                        `<div class="station-icon">${MUSIC_NOTE_ICON}</div>`
                    }
                    <div class="station-info">
                        <div class="station-name">${isStationCurated(station) ? VERIFIED_ICON : ''}${escapeHtml(station.name)}</div>
                        ${detailsDisplay ? `<div class="station-details">${escapeHtml(detailsDisplay)}</div>` : ''}
                        <div class="station-now-playing-loading">Loading current track...</div>
                    </div>
                    <button class="station-menu-btn" data-id="${station.id}">‚ãÆ</button>
                    <div class="station-dropdown">
                        <div class="dropdown-item danger" data-action="remove-from-playlist"
                             data-playlist-id="${currentPlaylist.id}"
                             data-station-id="${station.id}"
                             data-is-external="${station.is_external || false}"
                             data-external-id="${station.external_id || ''}">
                            <span>‚ûñ</span> Remove from Playlist
                        </div>
                    </div>
                </div>
            `;
            }).join('');
            
            // Add event listeners
            document.querySelectorAll('#playlistStationList .station-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    if (!e.target.closest('.station-menu-btn') && !e.target.closest('.station-dropdown')) {
                        const stationIndex = parseInt(item.dataset.stationIndex);
                        const station = playlistStations[stationIndex];
                        if (station) {
                            selectStation(station);
                            closePlaylistModal.click();
                        }
                    }
                });
            });
            
            // Add event listeners for menu buttons
            document.querySelectorAll('#playlistStationList .station-menu-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const dropdown = btn.nextElementSibling;
                    
                    // Close all other dropdowns
                    document.querySelectorAll('#playlistStationList .station-dropdown').forEach(d => {
                        if (d !== dropdown) d.classList.remove('active');
                    });
                    
                    dropdown.classList.toggle('active');
                });
            });
            
            // Add event listeners for dropdown actions
            document.querySelectorAll('#playlistStationList .dropdown-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const action = item.dataset.action;

                    if (action === 'remove-from-playlist') {
                        const playlistId = item.dataset.playlistId;
                        const stationId = parseInt(item.dataset.stationId);
                        const isExternal = item.dataset.isExternal === 'true';
                        const externalId = item.dataset.externalId || null;  // Keep as string (UUID), don't parseInt
                        removeFromPlaylist(playlistId, stationId, isExternal, externalId);
                        document.querySelectorAll('.station-dropdown').forEach(d => d.classList.remove('active'));
                    }
                });
            });

            // Fetch metadata for each station in parallel
            playlistStations.forEach(async (station) => {
                const metadata = await fetchStationCurrentMetadata(station);

                // Update the station's metadata display
                const stationElement = playlistStationList.querySelector(`[data-id="${station.id}"]`);
                if (!stationElement) return;

                const infoDiv = stationElement.querySelector('.station-info');
                if (!infoDiv) return;

                // Remove loading message
                const loadingDiv = infoDiv.querySelector('.station-now-playing-loading');
                if (loadingDiv) {
                    loadingDiv.remove();
                }

                if (metadata && (metadata.title || metadata.artist)) {
                    // Add metadata display (replaces the genres div position)
                    const genresDiv = infoDiv.querySelector('.station-genres');
                    if (genresDiv) {
                        genresDiv.remove();
                    }

                    const metadataDiv = document.createElement('div');
                    metadataDiv.className = 'station-now-playing';
                    metadataDiv.innerHTML = `
                        <span class="now-playing-label">‚ô™</span> ${metadata.artist ? `${escapeHtml(metadata.artist)} - ` : ''}${escapeHtml(metadata.title || 'Unknown')}
                    `;
                    infoDiv.appendChild(metadataDiv);
                } else {
                    // No metadata available - show genres
                    const genresDiv = infoDiv.querySelector('.station-genres');
                    if (!genresDiv) {
                        const newGenresDiv = document.createElement('div');
                        newGenresDiv.className = 'station-genres';
                        const genresDisplay = station.genres && Array.isArray(station.genres)
                            ? station.genres.join(', ')
                            : (station.genres || 'No genres');
                        newGenresDiv.textContent = genresDisplay;
                        infoDiv.appendChild(newGenresDiv);
                    }
                }
            });

            // Setup drag and drop if admin and curated playlist
            if (canReorder) {
                setupPlaylistStationDragAndDrop();
            }
        }

        // Setup drag and drop for playlist station reordering (admin only for curated playlists)
        function setupPlaylistStationDragAndDrop() {
            const stationItems = document.querySelectorAll('#playlistStationList .station-item[draggable="true"]');
            let draggedElement = null;
            let draggedIndex = null;

            stationItems.forEach((item, index) => {
                // Drag start
                item.addEventListener('dragstart', (e) => {
                    draggedElement = item;
                    draggedIndex = parseInt(item.dataset.stationIndex);
                    item.style.opacity = '0.4';
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/html', item.innerHTML);
                });

                // Drag end
                item.addEventListener('dragend', (e) => {
                    item.style.opacity = '1';
                    // Remove border from all items
                    document.querySelectorAll('#playlistStationList .station-item').forEach(i => {
                        i.style.borderTop = '';
                    });
                });

                // Drag over
                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';

                    if (item !== draggedElement) {
                        item.style.borderTop = '2px solid var(--accent-color)';
                    }
                });

                // Drag leave
                item.addEventListener('dragleave', (e) => {
                    item.style.borderTop = '';
                });

                // Drop
                item.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    item.style.borderTop = '';

                    if (draggedElement !== item) {
                        const dropIndex = parseInt(item.dataset.stationIndex);

                        // Reorder the playlistStations array
                        const movedStation = playlistStations.splice(draggedIndex, 1)[0];
                        playlistStations.splice(dropIndex, 0, movedStation);

                        // Update sort orders in database
                        await updateCuratedPlaylistStationOrder();

                        // Re-render the list
                        await renderPlaylistStations();
                    }
                });
            });
        }

        // Update curated playlist station order in database
        async function updateCuratedPlaylistStationOrder() {
            if (!currentPlaylist || !currentPlaylist.is_curated) return;

            try {
                // Update each station with its new sort_order using the playlist_item_id
                const updates = playlistStations.map(async (station, index) => {
                    if (!station.playlist_item_id) {
                        console.warn('Station missing playlist_item_id:', station);
                        return;
                    }

                    const { data, error } = await supabase
                        .from('curated_playlist_items')
                        .update({
                            sort_order: index
                        })
                        .eq('id', station.playlist_item_id);

                    if (error) {
                        console.error('Error updating station:', station.name, 'Error:', error);
                        throw error;
                    }
                    return data;
                });

                const results = await Promise.all(updates);
                console.log('Curated playlist station order updated successfully');

            } catch (error) {
                console.error('Error updating curated playlist station order:', error);
                alert('Failed to save station order: ' + (error.message || 'Unknown error'));
            }
        }

        // Populate station overview in the station info modal
        function populateStationOverview(station) {
            if (!station) return;

            const stationLogoContainer = document.getElementById('stationLogoContainer');
            const stationLogo = document.getElementById('stationLogo');
            const stationInfoGrid = document.getElementById('stationInfoGrid');

            // Clear previous content
            stationInfoGrid.innerHTML = '';

            // Helper function to create info row
            function createInfoRow(label, value, isLink = false) {
                if (!value || value === '' || (Array.isArray(value) && value.length === 0)) {
                    return '';
                }

                let displayValue = value;
                if (Array.isArray(value)) {
                    displayValue = value.join(', ');
                }

                if (isLink && value) {
                    displayValue = `<a href="${value}" target="_blank" rel="noopener noreferrer" style="color: var(--accent-color); text-decoration: none; word-break: break-all;">${value}</a>`;
                }

                return `
                    <div style="display: flex; gap: 12px; padding: 10px; background: var(--card-bg, rgba(255,255,255,0.05)); border-radius: 8px;">
                        <div style="font-weight: 600; color: var(--text-secondary); min-width: 140px; flex-shrink: 0;">${label}:</div>
                        <div style="color: var(--text-primary); flex: 1; word-break: break-word;">${displayValue}</div>
                    </div>
                `;
            }

            // Display station logo if available
            const logoUrl = station.icon_url || station.favicon || '';
            if (logoUrl) {
                stationLogo.src = logoUrl;
                stationLogo.onerror = function() {
                    stationLogoContainer.style.display = 'none';
                };
                stationLogoContainer.style.display = 'block';
            } else {
                stationLogoContainer.style.display = 'none';
            }

            let infoHTML = '';

            // Check if this is an external (Radio Browser) station or Supabase station
            if (station.is_external) {
                // Radio Browser station
                infoHTML += createInfoRow('Station Name', station.name);
                infoHTML += createInfoRow('Website', station.homepage, true);
                infoHTML += createInfoRow('Country', station.country);
                infoHTML += createInfoRow('Country Code', station.country_code || station.countrycode);

                // Country Subdivision (State/Region) - display both code and name if available
                const subdivisionCode = station.countrysubdivisioncode || (station.metadata && station.metadata.countrysubdivisioncode);
                if (subdivisionCode) {
                    infoHTML += createInfoRow('Country Subdivision Code', subdivisionCode);
                }

                const subdivisionName = station.countrysubdivision || (station.metadata && station.metadata.countrysubdivision);
                if (subdivisionName) {
                    infoHTML += createInfoRow('Country Subdivision', subdivisionName);
                }

                // Languages (full names)
                const languages = station.languages || (station.metadata && station.metadata.languages);
                if (languages) {
                    infoHTML += createInfoRow('Languages', languages);
                }

                infoHTML += createInfoRow('Language', station.language);

                // Language Codes
                const langCodes = station.languagecodes || (station.metadata && station.metadata.languagecodes);
                if (langCodes) {
                    infoHTML += createInfoRow('Language Codes', langCodes);
                }

                infoHTML += createInfoRow('Tags', station.tags || (station.genres && Array.isArray(station.genres) ? station.genres.join(', ') : ''));
                infoHTML += createInfoRow('Audio Codec', station.codec);
                infoHTML += createInfoRow('Bitrate', station.bitrate ? `${station.bitrate} kbps` : '');
                infoHTML += createInfoRow('Votes', station.votes);
                infoHTML += createInfoRow('Popularity', station.click_count || station.clickcount);
            } else {
                // Supabase (curated) station
                infoHTML += createInfoRow('Station Name', station.name);
                infoHTML += createInfoRow('Call Letters', station.call_letters);
                infoHTML += createInfoRow('Frequency', station.frequency);
                infoHTML += createInfoRow('Website', station.website_url, true);
                infoHTML += createInfoRow('Description', station.description);
                infoHTML += createInfoRow('Genres', station.genres);
            }

            stationInfoGrid.innerHTML = infoHTML;
        }

        // Select station
        function selectStation(station) {
            currentStation = station;

            // Close Discover modal and related modals if they're open
            if (discoverModal.classList.contains('active')) {
                discoverModal.classList.remove('active');
            }
            if (radioDatabaseModal.classList.contains('active')) {
                radioDatabaseModal.classList.remove('active');
                // Restore radio database search UI if we were in preset search mode
                restoreRadioDatabaseSearchUI();
            }
            if (browseStationsModal.classList.contains('active')) {
                browseStationsModal.classList.remove('active');
            }

            // Reset fallback attempt flag for new station
            hasFallbackAttempted = false;

            // Reset to Live mode for new station
            if (playbackMode === 'simple') {
                playbackMode = 'live';
                if (currentModeText) currentModeText.textContent = 'Live';
            }

            // Track the station click - handle both internal and external stations
            if (station.is_external) {
                trackStationClick(null, station.id); // For external stations, id is the external_station_id
            } else {
                trackStationClick(station.id);
            }

            // Update display - keep it visible along with buttons and enable clicking
            stationDisplay.style.display = 'flex';
            stationDisplay.classList.remove('disabled');
            // Don't hide the selector buttons anymore
            // stationSelectorButtons.style.display = 'none';
            stationDisplayIcon.src = station.icon_url || '';
            stationDisplayIcon.style.display = station.icon_url ? 'block' : 'none';
            // Add error handler to fallback to music note icon
            stationDisplayIcon.onerror = function() {
                this.onerror = null;
                this.src = MUSIC_NOTE_DATA_URI;
            };
            stationDisplayName.innerHTML = `${isStationCurated(station) ? VERIFIED_ICON : ''}${escapeHtml(station.name)}`;
            
            
            // Display call letters and frequency
            const detailsParts = [];
            if (station.call_letters) {
                detailsParts.push(station.call_letters);
            }
            if (station.frequency) {
                detailsParts.push(station.frequency);
            }
            const stationDisplayDetails = document.getElementById('stationDisplayDetails');
            stationDisplayDetails.textContent = detailsParts.length > 0 ? detailsParts.join(' ‚Ä¢ ') : '';
            stationDisplayDetails.style.display = detailsParts.length > 0 ? 'block' : 'none';
            
            // Update quality button availability
            updateQualityButtons(station);
            
            playPauseBtn.disabled = false;

            // Stop current stream if playing before starting new one
            if (player) {
                player.stop();
            }

            // Stop and clean up simple audio player if it's playing
            if (simpleAudioPlayer) {
                simpleAudioPlayer.pause();
                simpleAudioPlayer.src = '';
                // Remove all event listeners by cloning and replacing
                const oldPlayer = simpleAudioPlayer;
                simpleAudioPlayer = oldPlayer.cloneNode(true);
                oldPlayer.remove();
            }

            // Stop metadata-only player when switching stations
            stopMetadataOnlyPlayer();

            // Reset playing state
            isPlaying = false;
            isPaused = false;
            updatePlayPauseButton(false);

            // Close modals
            browseStationsModal.classList.remove('active');
            playlistsModal.classList.remove('active');
            playlistModal.classList.remove('active');
            
            // Re-render lists to update selected state
            renderStationList();
            if (currentPlaylist) {
                renderPlaylistStations();
            }


            // Automatically start playing the station (but not if we're casting)
            if (!castSession) {
                setTimeout(() => {
                    playPauseBtn.click();
                }, 100);
            } else {
                // If casting, restart metadata-only player for the new station
                stopMetadataOnlyPlayer();
                setTimeout(() => {
                    startMetadataOnlyPlayer();
                }, 500);
            }

            // Update Cast if currently casting
            updateCastMedia();


        }
        
        // Update quality button availability based on station URLs
        function updateQualityButtons(station) {
            const lowBtn = document.querySelector('.quality-option-modal[data-quality="low"]');
            const standardBtn = document.querySelector('.quality-option-modal[data-quality="standard"]');
            const highBtn = document.querySelector('.quality-option-modal[data-quality="high"]');

            let hasMultipleQualities = false;

            // Enable/disable based on available URLs
            if (station.url_low) {
                lowBtn.classList.remove('disabled');
                hasMultipleQualities = true;
            } else {
                lowBtn.classList.add('disabled');
                if (selectedQuality === 'low') {
                    // Switch to standard if low was selected but not available
                    selectedQuality = 'standard';
                    standardBtn.classList.add('selected');
                    lowBtn.classList.remove('selected');
                }
            }

            // Standard URL is always required, so always enabled
            standardBtn.classList.remove('disabled');

            if (station.url_high) {
                highBtn.classList.remove('disabled');
                hasMultipleQualities = true;
            } else {
                highBtn.classList.add('disabled');
                if (selectedQuality === 'high') {
                    // Switch to standard if high was selected but not available
                    selectedQuality = 'standard';
                    standardBtn.classList.add('selected');
                    highBtn.classList.remove('selected');
                }
            }

            // Update select quality button in station info modal
            const selectQualityBtn = document.getElementById('selectQualityBtn');
            if (selectQualityBtn) {
                if (hasMultipleQualities) {
                    selectQualityBtn.classList.remove('disabled');
                } else {
                    selectQualityBtn.classList.add('disabled');
                }
            }
        }
        
        // Open playlist
        function openPlaylist(id) {
            currentPlaylist = playlists.find(p => p.id === id);
            if (!currentPlaylist) return;

            lastOpenedModal = { type: 'playlist', id: id };
            playlistModalTitle.textContent = currentPlaylist.name;

            // Show/hide description
            if (currentPlaylist.description) {
                playlistModalDescription.textContent = currentPlaylist.description;
                playlistModalDescription.style.display = 'block';
            } else {
                playlistModalDescription.style.display = 'none';
            }

            loadPlaylistStations(id);

            playlistsModal.classList.remove('active');
            playlistModal.classList.add('active');
            pushToNavigationHistory('playlistModal', { playlistId: id });
        }

        // Open curated playlist (reuses playlist modal UI)
        function openCuratedPlaylist(id) {
            const curatedPlaylist = curatedPlaylists.find(p => p.id === id);
            if (!curatedPlaylist) return;

            // Temporarily set currentPlaylist to the curated playlist for display
            currentPlaylist = { ...curatedPlaylist, is_curated: true };
            lastOpenedModal = { type: 'curated_playlist', id: id };
            playlistModalTitle.textContent = curatedPlaylist.name;

            // Show/hide description
            if (curatedPlaylist.description) {
                playlistModalDescription.textContent = curatedPlaylist.description;
                playlistModalDescription.style.display = 'block';
            } else {
                playlistModalDescription.style.display = 'none';
            }

            // Load curated playlist stations into the playlist modal
            loadCuratedPlaylistStationsForModal(id);

            playlistModal.classList.add('active');
            pushToNavigationHistory('playlistModal', { curatedPlaylistId: id });
        }

        // Load curated playlist stations for display in modal
        async function loadCuratedPlaylistStationsForModal(curatedPlaylistId) {
            try {
                const { data, error } = await supabase
                    .from('curated_playlist_items')
                    .select('*, radio_stations(*), external_stations(*)')
                    .eq('curated_playlist_id', curatedPlaylistId)
                    .order('sort_order', { ascending: true, nullsFirst: false })
                    .order('created_at');

                if (error) throw error;

                playlistStations = data ? data.map(item => {
                    if (item.external_stations) {
                        // External station from radio-browser
                        const ext = item.external_stations;
                        return {
                            id: ext.id,
                            name: ext.name,
                            url: ext.url_resolved || ext.url,
                            icon_url: ext.icon_url || ext.favicon || '',
                            genres: ext.genres || [],
                            call_letters: '',
                            frequency: '',
                            country: ext.country,
                            is_external: true,
                            external_id: ext.id,
                            playlist_item_id: item.id  // Store the curated_playlist_items ID
                        };
                    } else if (item.radio_stations) {
                        // Internal curated station
                        return {
                            ...item.radio_stations,
                            playlist_item_id: item.id  // Store the curated_playlist_items ID
                        };
                    }
                    return null;
                }).filter(s => s !== null) : [];

                renderPlaylistStations();

            } catch (error) {
                console.error('Error loading curated playlist stations:', error);
                playlistStations = [];
                renderPlaylistStations();
            }
        }

        // Show playlist form
        function showPlaylistForm(id = null) {
            editingPlaylistId = id;
            
            if (id) {
                const playlist = playlists.find(p => p.id === id);
                if (!playlist) return;
                
                playlistFormTitle.textContent = 'Edit Playlist';
                playlistName.value = playlist.name;
                playlistDescription.value = playlist.description || '';
            } else {
                playlistFormTitle.textContent = 'Create Playlist';
                playlistName.value = '';
                playlistDescription.value = '';
            }
            
            // Close dropdowns
            document.querySelectorAll('.playlist-dropdown, .station-dropdown').forEach(d => {
                d.classList.remove('active');
            });
            
            playlistFormModal.classList.add('active');
        }
        
        // Edit playlist
        function editPlaylist(id) {
            showPlaylistForm(id);
        }
        
        // Confirm delete playlist
        function confirmDeletePlaylist(id) {
            const playlist = playlists.find(p => p.id === id);
            if (!playlist) return;
            
            if (confirm(`Are you sure you want to delete "${playlist.name}"?`)) {
                deletePlaylist(id);
            }
        }
        
        // Add station to playlist
        function addToPlaylist(playlistId, stationId) {
            addStationToPlaylist(playlistId, stationId);
            
            // Close dropdown
            document.querySelectorAll('.station-dropdown').forEach(d => {
                d.classList.remove('active');
            });
        }
        
        // Remove station from playlist
        async function removeFromPlaylist(playlistId, stationId, isExternal = false, externalId = null) {
            if (confirm('Remove this station from the playlist?')) {
                await removeStationFromPlaylist(playlistId, stationId, isExternal, externalId);
            }

            // Close dropdown
            document.querySelectorAll('.station-dropdown').forEach(d => {
                d.classList.remove('active');
            });
        }
        
        // Show station form
        function showStationForm(id = null) {
            editingStationId = id;
            
            if (id) {
                const station = stations.find(s => s.id === id);
                if (!station) return;
                
                stationFormTitle.textContent = 'Edit Station';
                document.getElementById('stationFormName').value = station.name;
                document.getElementById('stationFormUrl').value = station.url;
                document.getElementById('stationFormUrlLow').value = station.url_low || '';
                document.getElementById('stationFormUrlHigh').value = station.url_high || '';
                document.getElementById('stationFormCallLetters').value = station.call_letters || '';
                document.getElementById('stationFormFrequency').value = station.frequency || '';
                document.getElementById('stationFormWebsiteUrl').value = station.website_url || '';
                document.getElementById('stationFormDescription').value = station.description || '';
                
                // Convert genres array to comma-separated string for display
                // If genres is ["News", "Talk"], display as "News, Talk"
                const genresDisplay = station.genres && Array.isArray(station.genres) 
                    ? station.genres.join(', ') 
                    : (station.genres || '');
                document.getElementById('stationFormGenres').value = genresDisplay;
                
                document.getElementById('stationFormIconUrl').value = station.icon_url || '';
            } else {
                stationFormTitle.textContent = 'Add Station';
                stationForm.reset();
                
                // Reset image preview
                stationFormIconUpload.value = '';
                iconPreview.style.display = 'none';
                uploadIconBtn.textContent = 'üì∑ Choose Image';
                uploadIconBtn.style.background = '';
            }
            
            // Close dropdowns
            document.querySelectorAll('.station-dropdown').forEach(d => {
                d.classList.remove('active');
            });
            
            stationFormModal.classList.add('active');
        }

        // Show station form pre-populated with Radio Browser data for curation
        function showStationFormForCuration(radioBrowserStation) {
            // Reset the editing ID since this is a new station
            editingStationId = null;

            // Set form title
            stationFormTitle.textContent = 'Add Station to Curated Stations';

            // Populate form with Radio Browser data
            document.getElementById('stationFormName').value = radioBrowserStation.name || '';
            document.getElementById('stationFormUrl').value = radioBrowserStation.url_resolved || radioBrowserStation.url || '';
            document.getElementById('stationFormUrlLow').value = '';
            document.getElementById('stationFormUrlHigh').value = '';
            document.getElementById('stationFormCallLetters').value = '';
            document.getElementById('stationFormFrequency').value = '';
            document.getElementById('stationFormWebsiteUrl').value = radioBrowserStation.homepage || '';
            document.getElementById('stationFormDescription').value = '';

            // Convert tags to genres (Radio Browser uses tags, we use genres)
            const tags = radioBrowserStation.tags || '';
            const genresArray = tags.split(',').map(tag => tag.trim()).filter(tag => tag.length > 0);
            document.getElementById('stationFormGenres').value = genresArray.join(', ');

            // Set icon URL
            document.getElementById('stationFormIconUrl').value = radioBrowserStation.favicon || '';

            // Reset image preview
            stationFormIconUpload.value = '';
            iconPreview.style.display = 'none';
            uploadIconBtn.textContent = 'üì∑ Choose Image';
            uploadIconBtn.style.background = '';

            // Close any dropdowns
            document.querySelectorAll('.station-dropdown').forEach(d => {
                d.classList.remove('active');
            });

            // Close Radio Browser modal and open station form modal
            radioDatabaseModal.classList.remove('active');
            stationFormModal.classList.add('active');
        }

        // Show station form pre-populated with current station data for curation
        function showStationFormForCurrentStation() {
            // Reset the editing ID since this is a new station (curating, not editing)
            editingStationId = null;

            // Set form title
            stationFormTitle.textContent = 'Add Station to Curated Stations';

            // Populate form with current station data
            document.getElementById('stationFormName').value = currentStation.name || '';
            document.getElementById('stationFormUrl').value = currentStation.url || '';
            document.getElementById('stationFormUrlLow').value = currentStation.url_low || '';
            document.getElementById('stationFormUrlHigh').value = currentStation.url_high || '';
            document.getElementById('stationFormCallLetters').value = currentStation.call_letters || '';
            document.getElementById('stationFormFrequency').value = currentStation.frequency || '';
            document.getElementById('stationFormWebsiteUrl').value = currentStation.website_url || '';
            document.getElementById('stationFormDescription').value = currentStation.description || '';

            // Convert genres array to comma-separated string
            const genresStr = Array.isArray(currentStation.genres)
                ? currentStation.genres.join(', ')
                : (currentStation.genres || '');
            document.getElementById('stationFormGenres').value = genresStr;

            // Set icon URL
            document.getElementById('stationFormIconUrl').value = currentStation.icon_url || '';

            // Reset image preview
            stationFormIconUpload.value = '';
            iconPreview.style.display = 'none';
            uploadIconBtn.textContent = 'üì∑ Choose Image';
            uploadIconBtn.style.background = '';

            // Close any dropdowns
            document.querySelectorAll('.station-dropdown').forEach(d => {
                d.classList.remove('active');
            });

            // Close station info modal and open station form modal
            stationInfoModal.classList.remove('active');
            stationFormModal.classList.add('active');
        }

        // Edit station
        function editStation(id) {
            showStationForm(id);
        }
        
        // Confirm delete station
        function confirmDeleteStation(id) {
            const station = stations.find(s => s.id === id);
            if (!station) return;
            
            if (confirm(`Are you sure you want to delete "${station.name}"?`)) {
                deleteStation(id);
            }
        }
        
        // Filter stations
        function filterStations(query) {
            console.log('filterStations called with query:', query);
            console.log('Total stations:', stations.length);
            const lowerQuery = query.toLowerCase();

            // Reset to first page when filtering
            curatedStationsCurrentPage = 1;
            filteredStations = stations.filter(station => {
                // First apply genre filter
                if (currentGenreFilter) {
                    let hasGenre = false;
                    if (Array.isArray(station.genres)) {
                        hasGenre = station.genres.some(g => 
                            g.toLowerCase() === currentGenreFilter.toLowerCase()
                        );
                    } else if (typeof station.genres === 'string') {
                        hasGenre = station.genres.toLowerCase().includes(currentGenreFilter.toLowerCase());
                    }
                    if (!hasGenre) return false;
                }
                
                // Then apply search query if present
                if (!query) return true;

                // Search across all station fields
                const nameMatch = station.name && station.name.toLowerCase().includes(lowerQuery);
                const callLettersMatch = station.call_letters && station.call_letters.toLowerCase().includes(lowerQuery);
                const frequencyMatch = station.frequency && station.frequency.toLowerCase().includes(lowerQuery);
                const websiteMatch = station.website_url && station.website_url.toLowerCase().includes(lowerQuery);
                const descriptionMatch = station.description && station.description.toLowerCase().includes(lowerQuery);

                // Handle genres as array or string
                let genresMatch = false;
                if (station.genres) {
                    if (Array.isArray(station.genres)) {
                        // Search in array elements
                        genresMatch = station.genres.some(genre =>
                            genre.toLowerCase().includes(lowerQuery)
                        );
                    } else if (typeof station.genres === 'string') {
                        // Handle as string (for backward compatibility)
                        genresMatch = station.genres.toLowerCase().includes(lowerQuery);
                    }
                }

                return nameMatch || genresMatch || callLettersMatch || frequencyMatch || websiteMatch || descriptionMatch;
            });
            console.log('Filtered stations:', filteredStations.length);
            sortStations(); // Apply current sort after filtering
        }
        
        // Populate genre filter dropdown
        function populateGenreFilter() {
            const genreSet = new Set();
            const genreCounts = {};
            
            stations.forEach(station => {
                if (Array.isArray(station.genres)) {
                    station.genres.forEach(genre => {
                        if (genre && genre.trim()) {
                            genreSet.add(genre.trim());
                            genreCounts[genre.trim()] = (genreCounts[genre.trim()] || 0) + 1;
                        }
                    });
                } else if (typeof station.genres === 'string' && station.genres.trim()) {
                    // Split by comma for string genres
                    station.genres.split(',').forEach(genre => {
                        const trimmedGenre = genre.trim();
                        if (trimmedGenre) {
                            genreSet.add(trimmedGenre);
                            genreCounts[trimmedGenre] = (genreCounts[trimmedGenre] || 0) + 1;
                        }
                    });
                }
            });
            
            const sortedGenres = Array.from(genreSet).sort();
            
            // Build dropdown HTML
            let dropdownHTML = `
                <div class="filter-option active" data-genre="">
                    <span class="filter-option-icon">üéµ</span>
                    <span>All Genres</span>
                    <span class="genre-count">${stations.length}</span>
                </div>
            `;
            
            sortedGenres.forEach(genre => {
                dropdownHTML += `
                    <div class="filter-option" data-genre="${escapeHtml(genre)}">
                        <span class="filter-option-icon">üéµ</span>
                        <span>${escapeHtml(genre)}</span>
                        <span class="genre-count">${genreCounts[genre]}</span>
                    </div>
                `;
            });
            
            genreDropdown.innerHTML = dropdownHTML;
            
            // Re-attach event listeners
            genreDropdown.querySelectorAll('.filter-option').forEach(option => {
                option.addEventListener('click', (e) => {
                    e.stopPropagation();
                    
                    // Update active state
                    genreDropdown.querySelectorAll('.filter-option').forEach(opt => opt.classList.remove('active'));
                    option.classList.add('active');
                    
                    // Update genre filter
                    currentGenreFilter = option.dataset.genre;
                    
                    // Update button label
                    genreLabel.textContent = option.dataset.genre || 'All Genres';
                    
                    // Show/hide clear button
                    const clearBtn = document.getElementById('clearSearchBtn');
                    if (currentGenreFilter !== '' || stationSearch.value.trim() !== '') {
                        clearBtn.style.display = 'flex';
                    } else {
                        clearBtn.style.display = 'none';
                    }
                    
                    // Close dropdown
                    genreDropdown.classList.remove('active');
                    
                    // Apply filter
                    filterStations(stationSearch.value);
                });
            });
        }
        
        // Sort stations based on current sort method
        async function sortStations() {
            console.log('Sorting stations by:', currentSortMethod);

            // Reset to first page when sorting
            curatedStationsCurrentPage = 1;

            switch(currentSortMethod) {
                case 'name-asc':
                    filteredStations.sort((a, b) => 
                        (a.name || '').localeCompare(b.name || '')
                    );
                    break;
                    
                case 'name-desc':
                    filteredStations.sort((a, b) => 
                        (b.name || '').localeCompare(a.name || '')
                    );
                    break;
                    
                case 'most-played':
                    const mostPlayed = await getMostPlayedStations(filteredStations.length);
                    const mostPlayedIds = mostPlayed.map(s => s.id);
                    filteredStations.sort((a, b) => {
                        const indexA = mostPlayedIds.indexOf(a.id);
                        const indexB = mostPlayedIds.indexOf(b.id);
                        if (indexA === -1 && indexB === -1) return 0;
                        if (indexA === -1) return 1;
                        if (indexB === -1) return -1;
                        return indexA - indexB;
                    });
                    break;
                    
                case 'recent':
                    const recentStations = await getMostRecentStations(filteredStations.length);
                    const recentIds = recentStations.map(s => s.id);
                    filteredStations.sort((a, b) => {
                        const indexA = recentIds.indexOf(a.id);
                        const indexB = recentIds.indexOf(b.id);
                        if (indexA === -1 && indexB === -1) return 0;
                        if (indexA === -1) return 1;
                        if (indexB === -1) return -1;
                        return indexA - indexB;
                    });
                    break;
            }
            
            renderStationList();
        }
        
        // Update status
        function updateStatus(message, type = 'default') {
            statusText.textContent = message;
            statusDot.className = 'status-dot';
            
            if (type === 'playing') {
                statusDot.classList.add('playing');
            } else if (type === 'error') {
                statusDot.classList.add('error');
            } else if (type === 'loading') {
                statusDot.classList.add('loading');
            }
        }
        
        // Escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Check if a station is curated (in the curated stations database)
        function isStationCurated(station) {
            if (!station) return false;

            // "Curated stations" means stations from the radio_stations table only
            // These are manually curated internal stations

            // External stations (Radio Browser) are NOT considered curated
            // even if they're saved to external_stations table or in playlists
            if (station.is_external === true) {
                return false;
            }

            // Radio Browser search results (not curated)
            if (station.stationuuid) {
                return false;
            }

            // If it has an id and is not external, it's from radio_stations table (curated)
            return station.id !== null && station.id !== undefined;
        }

        // ======================
        // EVENT LISTENERS
        // ======================

        // Open overview modal from overview button
        overviewBtn.addEventListener('click', () => {
            overviewModal.classList.add('active');
            loadOverviewModal();
        });

        // Open hamburger menu modal
        hamburgerMenuBtn.addEventListener('click', () => {
            hamburgerMenuModal.classList.add('active');
        });

        // Close hamburger menu modal
        closeHamburgerMenuModal.addEventListener('click', () => {
            hamburgerMenuModal.classList.remove('active');
        });

        // Settings menu button - opens settings modal
        settingsMenuBtn.addEventListener('click', () => {
            hamburgerMenuModal.classList.remove('active');
            settingsModal.classList.add('active');
            pushToNavigationHistory('settingsModal');
        });

        // Station display click - open station info modal
        stationDisplay.addEventListener('click', () => {
            // Only open if a station is loaded and playing
            if (!currentStation || !isPlaying) {
                return;
            }

            // Show/hide admin buttons based on admin status
            const curateStationBtn = document.getElementById('curateStationBtn');
            const addToCuratedPlaylistBtn = document.getElementById('addToCuratedPlaylistBtn');
            const isAdmin = window.currentUser && window.currentUser.email === 'keith.e.dragon@gmail.com';
            if (curateStationBtn) {
                curateStationBtn.style.display = isAdmin ? 'flex' : 'none';
            }
            if (addToCuratedPlaylistBtn) {
                addToCuratedPlaylistBtn.style.display = isAdmin ? 'flex' : 'none';
            }

            // Populate station overview with current station data
            populateStationOverview(currentStation);

            stationInfoModal.classList.add('active');
        });

        // Update station display cursor based on playing state
        function updateStationDisplayCursor() {
            if (currentStation && isPlaying) {
                stationDisplay.style.cursor = 'pointer';
            } else {
                stationDisplay.style.cursor = 'default';
            }
        }

        // Close playlists modal
        closePlaylistsModal.addEventListener('click', () => {
            playlistsModal.classList.remove('active');
        });

        // Close browse stations modal
        closeBrowseStationsModal.addEventListener('click', () => {
            browseStationsModal.classList.remove('active');
        });

        // Close overview modal
        closeOverviewModal.addEventListener('click', () => {
            overviewModal.classList.remove('active');
        });

        // Close discover modal
        closeDiscoverModal.addEventListener('click', () => {
            discoverModal.classList.remove('active');
        });

        // Close all curated playlists modal
        const allCuratedPlaylistsModal = document.getElementById('allCuratedPlaylistsModal');
        const closeAllCuratedPlaylistsModal = document.getElementById('closeAllCuratedPlaylistsModal');

        closeAllCuratedPlaylistsModal.addEventListener('click', () => {
            allCuratedPlaylistsModal.classList.remove('active');
        });

        // View All Curated Playlists link
        document.getElementById('viewAllCuratedPlaylistsLink').addEventListener('click', (e) => {
            e.preventDefault();
            openAllCuratedPlaylistsModal();
        });

        // Search Curated Stations button in Discover modal
        document.getElementById('searchCuratedBtn').addEventListener('click', () => {
            // Close discover modal
            discoverModal.classList.remove('active');

            // Open browse stations modal
            browseStationsModal.classList.add('active');
            pushToNavigationHistory('browseStationsModal');

            // Clear any existing search
            stationSearch.value = '';

            // Load curated playlists
            loadCuratedPlaylists();

            // Ensure stations are displayed
            if (stations.length > 0) {
                if (filteredStations.length === 0) {
                    filteredStations = [...stations];
                }
                renderStationList();
            }
        });

        // Search Radio Database button in Discover modal
        document.getElementById('searchDatabaseBtn').addEventListener('click', async () => {
            // Close discover modal
            discoverModal.classList.remove('active');

            // Open radio database modal
            radioDatabaseModal.classList.add('active');
            pushToNavigationHistory('radioDatabaseModal');

            // Load filters if not already loaded
            if (radioDatabaseCountry.children.length === 1) {
                await loadRadioBrowserFilters();
            }

            // Load state or perform initial search
            const state = loadRadioDatabaseState();
            if (state) {
                // Restore previous state
                radioDatabaseSearchInput.value = state.searchTerm || '';
                radioDatabaseCountry.value = state.country || '';
                radioDatabaseLanguage.value = state.language || '';
                radioDatabaseTag.value = state.tag || '';
                radioDatabaseSort.value = state.sortBy || 'votes';
                radioDatabaseCurrentPage = state.currentPage || 1;
                radioDatabaseViewMode = state.viewMode || 'list';
                radioDatabaseMinBitrate = state.minBitrate !== undefined ? state.minBitrate : 0;
                radioDatabaseIncludeUnknown = state.includeUnknown !== undefined ? state.includeUnknown : true;
                radioDatabaseFilterOutHLS = state.filterOutHLS !== undefined ? state.filterOutHLS : false;

                // Update bitrate filter UI elements
                bitrateDropdown.value = radioDatabaseMinBitrate.toString();
                includeUnknownBitrates.checked = radioDatabaseIncludeUnknown;
                filterOutHLS.checked = radioDatabaseFilterOutHLS;

                // Restore view mode
                updateRadioDatabaseViewUI();

                // Update dependent filters based on country selection
                if (state.country) {
                    await updateLanguageOptions(state.country);
                }
                if (state.country || state.language) {
                    await updateTagOptions(state.country, state.language);
                }

                // Show/hide clear button based on filters
                const hasFilters = state.searchTerm || state.country || state.language || state.tag;
                document.getElementById('radioDatabaseClearBtn').style.display = hasFilters ? 'flex' : 'none';

                // Trigger search with saved page
                searchRadioBrowser(state.currentPage || 1);
            } else {
                // No saved state - perform default search
                searchRadioBrowser();
            }
        });

        // Play random station button in Discover modal
        document.getElementById('discoverPlayRandomStationBtn').addEventListener('click', () => {
            if (stations.length === 0) {
                alert('No stations available');
                return;
            }

            // Select a random station from all available stations
            const randomIndex = Math.floor(Math.random() * stations.length);
            const randomStation = stations[randomIndex];

            // Close the discover modal
            discoverModal.classList.remove('active');

            // Select and play the random station
            selectStation(randomStation);
            setTimeout(() => {
                playPauseBtn.click();
            }, 100);
        });

        // View Liked Songs button in Overview modal
        document.getElementById('overviewViewLikedTracksBtn').addEventListener('click', () => {
            displayLikedTracks();
            overviewModal.classList.remove('active');
            likedTracksModal.classList.add('active');
            pushToNavigationHistory('likedTracksModal');
        });

        // View Recent Songs button in Overview modal
        document.getElementById('overviewViewRecentTracksBtn').addEventListener('click', () => {
            displayRecentTracks();
            overviewModal.classList.remove('active');
            recentTracksModal.classList.add('active');
            pushToNavigationHistory('recentTracksModal');
        });

        // Close station info modal
        closeStationInfoModal.addEventListener('click', () => {
            stationInfoModal.classList.remove('active');
        });

        // Add current station to playlist button
        document.getElementById('addCurrentStationToPlaylistBtn').addEventListener('click', () => {
            showPlaylistSelectorForCurrentStation();
        });

        // Select quality button in station info modal
        document.getElementById('selectQualityBtn').addEventListener('click', () => {
            // Don't open modal if button is disabled
            if (document.getElementById('selectQualityBtn').classList.contains('disabled')) {
                return;
            }
            qualityModal.classList.add('active');
        });

        // Curate station button in station info modal (admin only)
        document.getElementById('curateStationBtn').addEventListener('click', () => {
            if (currentStation) {
                showStationFormForCurrentStation();
            }
        });

        // Add to curated playlist button in station info modal (admin only)
        document.getElementById('addToCuratedPlaylistBtn').addEventListener('click', () => {
            if (currentStation) {
                // Determine if current station is external or internal
                const isExternal = currentStation.is_external || false;
                showCuratedPlaylistSelector(currentStation, isExternal);
                stationInfoModal.classList.remove('active');
            }
        });

        // Close settings modal
        closeSettingsModal.addEventListener('click', () => {
            settingsModal.classList.remove('active');
        });

        // Close settings modal when clicking outside
        settingsModal.addEventListener('click', (e) => {
            if (e.target === settingsModal) {
                settingsModal.classList.remove('active');
            }
        });

        // Bottom Navigation Event Listeners

        // Function to close all modals
        function closeAllModals() {
            const allModals = [
                hamburgerMenuModal,
                playlistsModal,
                browseStationsModal,
                settingsModal,
                overviewModal,
                discoverModal,
                allCuratedPlaylistsModal,
                stationInfoModal,
                playlistModal,
                playlistFormModal,
                likedTracksModal,
                radioDatabaseModal,
                playlistSelectorModal,
                stationFormModal,
                recentTracksModal,
                lyricsModal,
                nowPlayingModal,
                qualityModal,
                playbackModeModal
            ];

            allModals.forEach(modal => {
                if (modal) {
                    modal.classList.remove('active');
                }
            });
        }

        // Navigation history helper functions
        function pushToNavigationHistory(modalId, context = {}) {
            // Don't add to history if it's the same as the current top
            const currentTop = navigationHistory[navigationHistory.length - 1];
            if (currentTop && currentTop.modalId === modalId) {
                return;
            }

            // Push the modal to navigation history
            navigationHistory.push({
                modalId: modalId,
                context: context,
                timestamp: Date.now()
            });

            // Update back button state
            updateBackButtonState();
        }

        function navigateBack() {
            if (navigationHistory.length === 0) {
                return;
            }

            // Get the last entry in history
            const lastEntry = navigationHistory[navigationHistory.length - 1];

            // Check if the last modal in history is currently open
            const lastModal = document.getElementById(lastEntry.modalId);
            const isLastModalOpen = lastModal && lastModal.classList.contains('active');

            let targetEntry;

            if (isLastModalOpen) {
                // If the last modal is currently open, pop it and go to the previous one
                navigationHistory.pop();
                targetEntry = navigationHistory[navigationHistory.length - 1];
            } else {
                // If no modal is open (main player), just open the last modal in history
                targetEntry = lastEntry;
            }

            if (targetEntry) {
                // Close all modals
                closeAllModals();

                // Get the modal element
                const modalElement = document.getElementById(targetEntry.modalId);

                if (modalElement) {
                    // Open the target modal
                    modalElement.classList.add('active');

                    // Restore context if needed - do NOT call functions that push to history
                    if (targetEntry.context.playlistId) {
                        // Restore user playlist content without calling openPlaylist
                        const id = targetEntry.context.playlistId;
                        currentPlaylist = playlists.find(p => p.id === id);
                        if (currentPlaylist) {
                            lastOpenedModal = { type: 'playlist', id: id };
                            playlistModalTitle.textContent = currentPlaylist.name;
                            if (currentPlaylist.description) {
                                playlistModalDescription.textContent = currentPlaylist.description;
                                playlistModalDescription.style.display = 'block';
                            } else {
                                playlistModalDescription.style.display = 'none';
                            }
                            loadPlaylistStations(id);
                        }
                    } else if (targetEntry.context.curatedPlaylistId) {
                        // Restore curated playlist content without calling openCuratedPlaylist
                        const id = targetEntry.context.curatedPlaylistId;
                        const curatedPlaylist = curatedPlaylists.find(p => p.id === id);
                        if (curatedPlaylist) {
                            currentPlaylist = { ...curatedPlaylist, is_curated: true };
                            lastOpenedModal = { type: 'curated_playlist', id: id };
                            playlistModalTitle.textContent = curatedPlaylist.name;
                            if (curatedPlaylist.description) {
                                playlistModalDescription.textContent = curatedPlaylist.description;
                                playlistModalDescription.style.display = 'block';
                            } else {
                                playlistModalDescription.style.display = 'none';
                            }
                            loadCuratedPlaylistStationsForModal(id);
                        }
                    } else if (targetEntry.modalId === 'overviewModal') {
                        loadOverviewModal();
                    } else if (targetEntry.modalId === 'discoverModal') {
                        loadDiscoverModal();
                    } else if (targetEntry.modalId === 'allCuratedPlaylistsModal') {
                        openAllCuratedPlaylistsModal();
                    } else if (targetEntry.modalId === 'likedTracksModal') {
                        displayLikedTracks();
                    } else if (targetEntry.modalId === 'recentTracksModal') {
                        displayRecentTracks();
                    } else if (targetEntry.modalId === 'browseStationsModal') {
                        loadCuratedPlaylists();
                    }
                }
            }

            // Update back button state
            updateBackButtonState();
        }

        function updateBackButtonState() {
            const backBtn = document.getElementById('backBtn');
            if (backBtn) {
                // Enable back button if there's any history (can go back to at least one modal)
                backBtn.disabled = navigationHistory.length === 0;
            }
        }

        // Bottom nav - Overview button
        document.getElementById('bottomNavOverview').addEventListener('click', () => {
            closeAllModals();
            overviewModal.classList.add('active');
            loadOverviewModal();
            pushToNavigationHistory('overviewModal');
        });

        // Bottom nav - Discover button
        document.getElementById('bottomNavDiscover').addEventListener('click', () => {
            closeAllModals();
            discoverModal.classList.add('active');
            loadDiscoverModal();
            pushToNavigationHistory('discoverModal');
        });

        // Bottom nav - Menu button
        document.getElementById('bottomNavMenu').addEventListener('click', () => {
            closeAllModals();
            hamburgerMenuModal.classList.add('active');
            pushToNavigationHistory('hamburgerMenuModal');
        });

        // Helper function to restore radio database search UI
        function restoreRadioDatabaseSearchUI() {
            // Check if we were in preset search mode
            if (window.presetSearchActive) {
                const modalTitle = radioDatabaseModal.querySelector('.modal-title');
                const searchContainer = window.presetSearchActive.searchContainer;
                const filterControls = window.presetSearchActive.filterControls;
                const advancedFiltersButton = window.presetSearchActive.advancedFiltersButton;
                const advancedFiltersPanel = window.presetSearchActive.advancedFiltersPanel;

                // Restore original title
                if (modalTitle) {
                    modalTitle.textContent = window.presetSearchActive.originalTitle;
                }

                // Show all search and filter controls again
                if (searchContainer) {
                    searchContainer.style.display = '';
                }
                if (filterControls) {
                    filterControls.style.display = '';
                }
                if (advancedFiltersButton) {
                    advancedFiltersButton.style.display = '';
                }
                // Don't restore advancedFiltersPanel visibility - it should stay closed unless user opened it

                // Clear the preset search active flag
                window.presetSearchActive = null;
            }
        }

        // Close Radio Database modal
        closeRadioDatabaseModal.addEventListener('click', () => {
            restoreRadioDatabaseSearchUI();
            radioDatabaseModal.classList.remove('active');
        });

        // Close Radio Database modal when clicking outside
        radioDatabaseModal.addEventListener('click', (e) => {
            if (e.target === radioDatabaseModal) {
                restoreRadioDatabaseSearchUI();
                radioDatabaseModal.classList.remove('active');
            }
        });

        // Close Playlist Selector modal
        closePlaylistSelectorModal.addEventListener('click', () => {
            playlistSelectorModal.classList.remove('active');
        });

        // Close Curated Playlist Selector modal
        closeCuratedPlaylistSelectorModal.addEventListener('click', () => {
            curatedPlaylistSelectorModal.classList.remove('active');
            pendingCuratedPlaylistStation = null;
            pendingCuratedPlaylistIsExternal = false;
        });

        // Create New Curated Playlist button
        createNewCuratedPlaylistBtn.addEventListener('click', () => {
            curatedPlaylistSelectorModal.classList.remove('active');
            showCuratedPlaylistForm();
        });

        // Close Curated Playlist Form modal
        closeCuratedPlaylistFormModal.addEventListener('click', () => {
            curatedPlaylistFormModal.classList.remove('active');
            editingCuratedPlaylistId = null;
        });

        // Cancel Curated Playlist Form button
        cancelCuratedPlaylistFormBtn.addEventListener('click', () => {
            curatedPlaylistFormModal.classList.remove('active');
            editingCuratedPlaylistId = null;
        });

        // Submit Curated Playlist Form
        curatedPlaylistForm.addEventListener('submit', (e) => {
            e.preventDefault();
            saveCuratedPlaylist();
        });

        // Close Playlist Selector modal when clicking outside
        playlistSelectorModal.addEventListener('click', (e) => {
            if (e.target === playlistSelectorModal) {
                playlistSelectorModal.classList.remove('active');
            }
        });

        // Close Curated Playlist Selector modal when clicking outside
        curatedPlaylistSelectorModal.addEventListener('click', (e) => {
            if (e.target === curatedPlaylistSelectorModal) {
                curatedPlaylistSelectorModal.classList.remove('active');
                pendingCuratedPlaylistStation = null;
                pendingCuratedPlaylistIsExternal = false;
            }
        });

        // Close Curated Playlist Form modal when clicking outside
        curatedPlaylistFormModal.addEventListener('click', (e) => {
            if (e.target === curatedPlaylistFormModal) {
                curatedPlaylistFormModal.classList.remove('active');
                editingCuratedPlaylistId = null;
            }
        });

        // Radio Database real-time search
        radioDatabaseSearchInput.addEventListener('input', (e) => {
            const clearBtn = document.getElementById('radioDatabaseClearBtn');

            // Show/hide clear button based on input or filters
            const hasFilters = radioDatabaseCountry.value !== '' ||
                              radioDatabaseLanguage.value !== '' ||
                              radioDatabaseTag.value !== '';

            if (e.target.value.trim() !== '' || hasFilters) {
                clearBtn.style.display = 'flex';
            } else {
                clearBtn.style.display = 'none';
            }

            // Trigger search immediately
            searchRadioBrowser();
        });

        // Radio Database clear button
        const radioDatabaseClearBtn = document.getElementById('radioDatabaseClearBtn');
        radioDatabaseClearBtn.addEventListener('click', () => {
            // Clear search input
            radioDatabaseSearchInput.value = '';

            // Reset filters
            radioDatabaseCountry.value = '';
            radioDatabaseLanguage.value = '';
            radioDatabaseTag.value = '';

            // Reset advanced filters (bitrate/HLS)
            radioDatabaseMinBitrate = 0;
            radioDatabaseIncludeUnknown = true;
            radioDatabaseFilterOutHLS = false;
            bitrateDropdown.value = '0';
            includeUnknownBitrates.checked = true;
            filterOutHLS.checked = false;

            // Restore original filter options
            restoreLanguageOptions();
            restoreTagOptions();

            // Hide clear button
            radioDatabaseClearBtn.style.display = 'none';

            // Clear saved state from sessionStorage
            clearRadioDatabaseState();

            // Trigger search with defaults (this will save the cleared state)
            searchRadioBrowser();
        });

        // Radio Database filter changes - trigger search
        radioDatabaseCountry.addEventListener('change', async () => {
            const clearBtn = document.getElementById('radioDatabaseClearBtn');
            const country = radioDatabaseCountry.value;
            const language = radioDatabaseLanguage.value;

            const hasFilters = country !== '' ||
                              language !== '' ||
                              radioDatabaseTag.value !== '' ||
                              radioDatabaseSearchInput.value.trim() !== '';

            if (hasFilters) {
                clearBtn.style.display = 'flex';
            } else {
                clearBtn.style.display = 'none';
            }

            // Update dependent filters
            await updateLanguageOptions(country);
            await updateTagOptions(country, radioDatabaseLanguage.value);

            searchRadioBrowser();
        });

        radioDatabaseLanguage.addEventListener('change', async () => {
            const clearBtn = document.getElementById('radioDatabaseClearBtn');
            const country = radioDatabaseCountry.value;
            const language = radioDatabaseLanguage.value;

            const hasFilters = country !== '' ||
                              language !== '' ||
                              radioDatabaseTag.value !== '' ||
                              radioDatabaseSearchInput.value.trim() !== '';

            if (hasFilters) {
                clearBtn.style.display = 'flex';
            } else {
                clearBtn.style.display = 'none';
            }

            // Update tag options based on country and language
            await updateTagOptions(country, language);

            searchRadioBrowser();
        });

        radioDatabaseTag.addEventListener('change', () => {
            const clearBtn = document.getElementById('radioDatabaseClearBtn');
            const hasFilters = radioDatabaseCountry.value !== '' ||
                              radioDatabaseLanguage.value !== '' ||
                              radioDatabaseTag.value !== '' ||
                              radioDatabaseSearchInput.value.trim() !== '';

            if (hasFilters) {
                clearBtn.style.display = 'flex';
            } else {
                clearBtn.style.display = 'none';
            }

            searchRadioBrowser();
        });

        // Radio Database sort change - restart search from page 1
        radioDatabaseSort.addEventListener('change', () => {
            searchRadioBrowser(1);
        });

        // Toggle Advanced Filters panel
        toggleAdvancedFilters.addEventListener('click', () => {
            const isHidden = advancedFiltersPanel.style.display === 'none';
            advancedFiltersPanel.style.display = isHidden ? 'block' : 'none';
            toggleAdvancedFilters.innerHTML = isHidden ?
                '‚ñ≤ Advanced Filters' :
                '‚ñº Advanced Filters';
        });

        // Radio Database pagination - Previous button
        radioDatabasePrevBtn.addEventListener('click', () => {
            if (radioDatabaseCurrentPage > 1) {
                searchRadioBrowser(radioDatabaseCurrentPage - 1);
            }
        });

        // Radio Database pagination - Next button
        radioDatabaseNextBtn.addEventListener('click', () => {
            searchRadioBrowser(radioDatabaseCurrentPage + 1);
        });

        // Curated Stations pagination - Previous button
        const curatedStationsPrevBtn = document.getElementById('curatedStationsPrevBtn');
        const curatedStationsNextBtn = document.getElementById('curatedStationsNextBtn');

        curatedStationsPrevBtn.addEventListener('click', () => {
            if (curatedStationsCurrentPage > 1) {
                curatedStationsCurrentPage--;
                renderStationList();
            }
        });

        // Curated Stations pagination - Next button
        curatedStationsNextBtn.addEventListener('click', () => {
            curatedStationsCurrentPage++;
            renderStationList();
        });

        // Close hamburger menu modal when clicking outside
        hamburgerMenuModal.addEventListener('click', (e) => {
            if (e.target === hamburgerMenuModal) {
                hamburgerMenuModal.classList.remove('active');
            }
        });

        // Auth button handler
        authBtn.addEventListener('click', () => {
            if (window.isAuthenticated && window.currentUser) {
                // User is signed in, call sign out
                if (window.signOut) {
                    window.signOut();
                }
            } else {
                // User is not signed in, redirect to login
                window.location.href = 'login.html';
            }
        });
        
        // Auto-fallback toggle
        const autoFallbackCheckbox = document.getElementById('autoFallback');
        autoFallbackCheckbox.addEventListener('change', (e) => {
            autoFallbackEnabled = e.target.checked;
            console.log('Auto-fallback:', autoFallbackEnabled ? 'enabled' : 'disabled');
        });

        // Keep Screen Awake functionality
        let wakeLock = null;
        const keepScreenAwakeCheckbox = document.getElementById('keepScreenAwake');

        async function requestWakeLock() {
            if ('wakeLock' in navigator) {
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                    console.log('Screen Wake Lock activated');

                    wakeLock.addEventListener('release', () => {
                        console.log('Screen Wake Lock released');
                    });
                } catch (err) {
                    console.error('Failed to activate Screen Wake Lock:', err);
                }
            } else {
                console.warn('Screen Wake Lock API not supported');
            }
        }

        async function releaseWakeLock() {
            if (wakeLock !== null) {
                try {
                    await wakeLock.release();
                    wakeLock = null;
                    console.log('Screen Wake Lock manually released');
                } catch (err) {
                    console.error('Failed to release Screen Wake Lock:', err);
                }
            }
        }

        keepScreenAwakeCheckbox.addEventListener('change', async (e) => {
            const isEnabled = e.target.checked;
            localStorage.setItem('keepScreenAwake', isEnabled);

            if (isEnabled) {
                await requestWakeLock();
            } else {
                await releaseWakeLock();
            }
        });

        // Re-acquire wake lock when page becomes visible again
        document.addEventListener('visibilitychange', async () => {
            if (wakeLock !== null && document.visibilityState === 'visible') {
                const isEnabled = localStorage.getItem('keepScreenAwake') === 'true';
                if (isEnabled) {
                    await requestWakeLock();
                }
            }
        });

        // Fullscreen Mode functionality
        const fullscreenCheckbox = document.getElementById('fullscreenMode');

        async function toggleFullscreen(enable) {
            try {
                if (enable) {
                    if (document.documentElement.requestFullscreen) {
                        await document.documentElement.requestFullscreen();
                    } else if (document.documentElement.webkitRequestFullscreen) {
                        await document.documentElement.webkitRequestFullscreen();
                    } else if (document.documentElement.mozRequestFullScreen) {
                        await document.documentElement.mozRequestFullScreen();
                    } else if (document.documentElement.msRequestFullscreen) {
                        await document.documentElement.msRequestFullscreen();
                    }
                    console.log('Fullscreen mode activated');
                } else {
                    if (document.exitFullscreen) {
                        await document.exitFullscreen();
                    } else if (document.webkitExitFullscreen) {
                        await document.webkitExitFullscreen();
                    } else if (document.mozCancelFullScreen) {
                        await document.mozCancelFullScreen();
                    } else if (document.msExitFullscreen) {
                        await document.msExitFullscreen();
                    }
                    console.log('Fullscreen mode deactivated');
                }
            } catch (err) {
                console.error('Fullscreen toggle failed:', err);
            }
        }

        fullscreenCheckbox.addEventListener('change', async (e) => {
            const isEnabled = e.target.checked;
            localStorage.setItem('fullscreenMode', isEnabled);
            await toggleFullscreen(isEnabled);
        });

        // Listen for fullscreen changes (e.g., user presses ESC)
        document.addEventListener('fullscreenchange', () => {
            const isFullscreen = !!document.fullscreenElement;
            if (fullscreenCheckbox.checked !== isFullscreen) {
                fullscreenCheckbox.checked = isFullscreen;
                localStorage.setItem('fullscreenMode', isFullscreen);
            }
        });

        document.addEventListener('webkitfullscreenchange', () => {
            const isFullscreen = !!document.webkitFullscreenElement;
            if (fullscreenCheckbox.checked !== isFullscreen) {
                fullscreenCheckbox.checked = isFullscreen;
                localStorage.setItem('fullscreenMode', isFullscreen);
            }
        });

        document.addEventListener('mozfullscreenchange', () => {
            const isFullscreen = !!document.mozFullScreenElement;
            if (fullscreenCheckbox.checked !== isFullscreen) {
                fullscreenCheckbox.checked = isFullscreen;
                localStorage.setItem('fullscreenMode', isFullscreen);
            }
        });

        document.addEventListener('msfullscreenchange', () => {
            const isFullscreen = !!document.msFullscreenElement;
            if (fullscreenCheckbox.checked !== isFullscreen) {
                fullscreenCheckbox.checked = isFullscreen;
                localStorage.setItem('fullscreenMode', isFullscreen);
            }
        });

        // Toggle Chromecast section
        // ======================
        // GOOGLE CAST SDK INTEGRATION
        // ======================
        
        let castSession = null;
        let castPlayer = null;
        let currentMediaInfo = null;
        let castInitRetries = 0;
        const MAX_CAST_RETRIES = 10;
        
        // Initialize Cast SDK
        window['__onGCastApiAvailable'] = function(isAvailable) {
            if (isAvailable) {
                // Wait a bit for SDK to fully load, then try initialization
                setTimeout(initializeCastApi, 500);
            }
        };
        
        function initializeCastApi() {
            try {
                // Check if cast object exists
                if (typeof cast === 'undefined' || typeof chrome === 'undefined' || 
                    typeof chrome.cast === 'undefined' || typeof cast.framework === 'undefined') {
                    
                    
                    // Retry if not reached max attempts
                    if (castInitRetries < MAX_CAST_RETRIES) {
                        castInitRetries++;
                        setTimeout(initializeCastApi, 500);
                        return;
                    } else {
                        console.error('Cast SDK failed to load after', MAX_CAST_RETRIES, 'attempts');
                        return;
                    }
                }
                
                // Temporarily testing with default receiver
                const applicationID = chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID;
                // Your custom: const applicationID = '60D76D0F';
                
                
                const castContext = cast.framework.CastContext.getInstance();
                castContext.setOptions({
                    receiverApplicationId: applicationID,
                    autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED
                });
                
                
                // Add event listeners
                castContext.addEventListener(
                    cast.framework.CastContextEventType.SESSION_STATE_CHANGED,
                    onSessionStateChanged
                );
                
                castContext.addEventListener(
                    cast.framework.CastContextEventType.CAST_STATE_CHANGED,
                    onCastStateChanged
                );
                

                // Prevent cast button from opening station info modal
                const castButton = document.getElementById('castButton');
                if (castButton) {
                    castButton.addEventListener('click', (event) => {
                        event.stopPropagation();
                    });
                }

                // Check cast state
                setTimeout(() => {
                    const castState = castContext.getCastState();

                    // Check if button exists and is visible
                    const button = document.getElementById('castButton');
                    if (button) {
                        const styles = window.getComputedStyle(button);
                    }
                }, 2000);
            } catch (error) {
                console.error('Error initializing Cast SDK:', error);
                
                // Retry on error
                if (castInitRetries < MAX_CAST_RETRIES) {
                    castInitRetries++;
                    setTimeout(initializeCastApi, 1000);
                }
            }
        }
        
        function onSessionStateChanged(event) {
            
            // Log detailed error information for failed sessions
            if (event.sessionState === cast.framework.SessionState.SESSION_START_FAILED) {
                console.error('Cast session failed to start!');
                console.error('Error code:', event.errorCode);
                console.error('Error details:', event);
                
                // Common error codes
                const errorMessages = {
                    'cancel': 'User cancelled the connection',
                    'timeout': 'Connection timed out - check if receiver URL is accessible',
                    'api_not_initialized': 'Cast API not initialized properly',
                    'invalid_parameter': 'Invalid receiver application ID or parameters',
                    'receiver_unavailable': 'Receiver application not available - check if it\'s published',
                    'session_error': 'Session error - receiver may have failed to load',
                    'channel_error': 'Communication channel error',
                    'load_media_failed': 'Failed to load media'
                };
                
                const errorMsg = errorMessages[event.errorCode] || 'Unknown error: ' + event.errorCode;
                console.error('Error explanation:', errorMsg);
                updateStatus('Cast failed: ' + errorMsg, 'error');
                return;
            }
            
            try {
                switch (event.sessionState) {
                    case cast.framework.SessionState.SESSION_STARTED:
                        castSession = cast.framework.CastContext.getInstance().getCurrentSession();

                        // Stop local playback
                        if (player) {
                            try {
                                player.stop();
                            } catch (e) {}
                        }
                        if (simpleAudioPlayer && !simpleAudioPlayer.paused) {
                            simpleAudioPlayer.pause();
                        }

                        updateStatus('Cast connected...', 'playing');

                        // Start metadata-only player to continue receiving metadata locally
                        startMetadataOnlyPlayer();

                        // Wait a moment for session to fully establish before loading media
                        setTimeout(() => {
                            if (currentStation && castSession) {
                                loadMediaToCast();
                            }
                        }, 1000);

                        break;
                        
                    case cast.framework.SessionState.SESSION_ENDED:
                        castSession = null;
                        updateStatus('Not connected', '');

                        // Stop metadata-only player
                        stopMetadataOnlyPlayer();

                        // Reset play/pause button state
                        updatePlayPauseButton(false);
                        const wasCastingAndPlaying = isPlaying;
                        isPlaying = false;

                        // Resume local playback if desired
                        if (currentStation && wasCastingAndPlaying) {
                            setTimeout(() => {
                                playPauseBtn.click();
                            }, 300);
                        }
                        break;
                }
            } catch (error) {
                console.error('Error in session state change:', error);
            }
        }
        
        function onCastStateChanged(event) {

            // Show/hide Chromecast button based on device availability
            const castButton = document.getElementById('castButton');

            // Show button only when Chromecast devices are available
            const isDeviceAvailable = event.castState !== cast.framework.CastState.NO_DEVICES_AVAILABLE;

            if (castButton) {
                castButton.style.display = isDeviceAvailable ? 'flex' : 'none';
            }

        }
        
        function loadMediaToCast() {
            if (!castSession || !currentStation) {
                return;
            }
            
            try {
                // Get stream URL based on quality
                const streamUrl = selectedQuality === 'low' && currentStation.url_low ? currentStation.url_low :
                                 selectedQuality === 'high' && currentStation.url_high ? currentStation.url_high :
                                 currentStation.url;

                // Create media info
                const mediaInfo = new chrome.cast.media.MediaInfo(streamUrl, 'audio/mpeg');
                
                // Set metadata
                const metadata = new chrome.cast.media.GenericMediaMetadata();
                metadata.title = currentStation.name;
                metadata.subtitle = 'Live Radio Stream';
                
                if (currentStation.icon_url) {
                    metadata.images = [new chrome.cast.Image(currentStation.icon_url)];
                }
                
                mediaInfo.metadata = metadata;
                mediaInfo.streamType = chrome.cast.media.StreamType.LIVE;
                
                // Load media
                const request = new chrome.cast.media.LoadRequest(mediaInfo);
                request.autoplay = true;
                
                
                castSession.loadMedia(request).then(
                    () => {
                        currentMediaInfo = mediaInfo;
                        updateStatus('Casting...', 'playing');
                        // Enable play/pause button and set to pause state (casting is playing)
                        playPauseBtn.disabled = false;
                        updatePlayPauseButton(true);
                        isPlaying = true;

                        // Add listener to media session to keep button in sync with Cast state
                        const media = castSession.getMediaSession();
                        if (media) {
                            media.addUpdateListener((isAlive) => {
                                if (isAlive && castSession) {
                                    const updatedMedia = castSession.getMediaSession();
                                    if (updatedMedia) {
                                        const playerState = updatedMedia.playerState;
                                        if (playerState === 'PLAYING' || playerState === 'BUFFERING') {
                                            updatePlayPauseButton(true);
                                            updateStatus('Casting...', 'playing');
                                        } else if (playerState === 'PAUSED') {
                                            updatePlayPauseButton(false);
                                            updateStatus('Paused (Casting)', 'stopped');
                                        } else if (playerState === 'IDLE') {
                                            updatePlayPauseButton(false);
                                        }
                                    }
                                }
                            });
                        }
                    },
                    (errorCode) => {
                        console.error('‚ùå Failed to load media:', errorCode);
                        updateStatus('Cast error: ' + errorCode, 'error');
                    }
                );
            } catch (error) {
                console.error('‚ùå Error loading media to cast:', error);
                updateStatus('Cast error: ' + error.message, 'error');
            }
        }
        
        // Expose function to update Cast media when station changes
        function updateCastMedia() {
            if (castSession && currentStation) {
                loadMediaToCast();
            }
        }
        
        // Update Cast metadata with current track info
        function updateCastMetadata(title, artist, artworkUrl) {
            if (!castSession) {
                return;
            }

            try {
                const media = castSession.getMediaSession();
                if (!media) {
                    // Media hasn't loaded yet, retry in a moment
                    setTimeout(() => {
                        const retryMedia = castSession ? castSession.getMediaSession() : null;
                        if (retryMedia) {
                            updateCastMetadata(title, artist, artworkUrl);
                        }
                    }, 1500);
                    return;
                }

                // Create new metadata
                const metadata = new chrome.cast.media.MusicTrackMediaMetadata();
                metadata.songName = title || currentStation.name;
                metadata.artist = artist || 'Live Radio Stream';
                metadata.albumName = currentStation.name;

                // Use album art if available, otherwise station icon
                if (artworkUrl) {
                    metadata.images = [new chrome.cast.Image(artworkUrl)];
                } else if (currentStation.icon_url) {
                    metadata.images = [new chrome.cast.Image(currentStation.icon_url)];
                }

                // Update the media info
                const mediaInfo = media.media;
                mediaInfo.metadata = metadata;

                // Send the update
                const request = new chrome.cast.media.QueueUpdateItemsRequest([{
                    media: mediaInfo
                }]);


            } catch (error) {
            }
        }

        // Calculate exponential backoff delay for metadata player retries
        function getMetadataPlayerRetryDelay(retryCount) {
            // Exponential backoff: 2s, 4s, 8s, 16s, 30s (capped at 30s)
            const baseDelay = 2000; // 2 seconds
            const delay = Math.min(baseDelay * Math.pow(2, retryCount), 30000);
            return delay;
        }

        // Reset metadata player retry counter (call on successful playback)
        function resetMetadataPlayerRetries() {
            metadataOnlyPlayerRetryCount = 0;
            metadataOnlyPlayerErrorCount = 0;
        }

        // Clear any pending metadata player retry timeout
        function clearMetadataPlayerRetryTimeout() {
            if (metadataOnlyPlayerRetryTimeoutId) {
                clearTimeout(metadataOnlyPlayerRetryTimeoutId);
                metadataOnlyPlayerRetryTimeoutId = null;
            }
        }

        // Clear any pending metadata player waiting timeout
        function clearMetadataPlayerWaitingTimeout() {
            if (metadataOnlyPlayerWaitingTimeoutId) {
                clearTimeout(metadataOnlyPlayerWaitingTimeoutId);
                metadataOnlyPlayerWaitingTimeoutId = null;
            }
        }

        // Set a timeout to detect if metadata player is stuck waiting
        function setMetadataPlayerWaitingTimeout() {
            clearMetadataPlayerWaitingTimeout();
            metadataOnlyPlayerWaitingTimeoutId = setTimeout(() => {
                console.error('‚ùå Metadata player stuck in waiting state for too long (30s). Stopping to prevent infinite retries.');
                metadataOnlyPlayerErrorCount++;

                // Stop the player after too many consecutive timeout errors
                if (metadataOnlyPlayerErrorCount >= metadataOnlyPlayerMaxErrors) {
                    console.error(`‚ùå Metadata player reached ${metadataOnlyPlayerMaxErrors} timeout errors. Giving up.`);
                    if (metadataOnlyPlayer) {
                        metadataOnlyPlayerIntentionalStop = true; // Mark as intentional to prevent restart
                        try {
                            metadataOnlyPlayer.stop();
                        } catch (e) {
                        }
                        metadataOnlyPlayer = null;
                        metadataOnlyPlayerUrl = null;
                    }
                    metadataOnlyPlayerErrorCount = 0; // Reset for next attempt
                    clearMetadataPlayerRetryTimeout();
                } else {
                    // Try to restart the player
                    if (metadataOnlyPlayer) {
                        try {
                            metadataOnlyPlayer.stop();
                        } catch (e) {
                        }
                    }
                }
            }, metadataOnlyPlayerWaitingTimeout);
        }

        // Clear any pending metadata player refresh interval
        function clearMetadataPlayerRefreshInterval() {
            if (metadataOnlyPlayerRefreshIntervalId) {
                clearInterval(metadataOnlyPlayerRefreshIntervalId);
                metadataOnlyPlayerRefreshIntervalId = null;
            }
        }

        // Fetch metadata once without continuous playback
        // Uses IcecastMetadataPlayer library which properly handles all metadata formats including apostrophes
        async function fetchMetadataOnce() {
            if (!currentStation) {
                return;
            }


            // Get stream URL based on quality
            const rawUrl = selectedQuality === 'low' && currentStation.url_low ? currentStation.url_low :
                          selectedQuality === 'high' && currentStation.url_high ? currentStation.url_high :
                          currentStation.url;

            if (!rawUrl) {
                return;
            }

            // Check if HLS stream - use HLS metadata fetching
            if (isHLSStream(rawUrl)) {
                const metadata = await fetchHLSMetadata(currentStation);
                if (metadata) {
                    displayMetadata({ StreamTitle: metadata.artist ? `${metadata.artist} - ${metadata.title}` : metadata.title });
                }
                return;
            }

            // Use CORS proxy for metadata fetching
            const streamUrl = corsProxies[0].url(rawUrl);

            // Use IcecastMetadataPlayer to fetch metadata
            fetchMetadataWithAudio(streamUrl);
        }

        // Fetch metadata using IcecastMetadataPlayer library
        function fetchMetadataWithAudio(streamUrl) {
            let tempPlayer = null;
            let metadataReceived = false;

            try {
                tempPlayer = new IcecastMetadataPlayer(streamUrl, {
                    metadataTypes: ['icy', 'ogg'],
                    enableLogging: false,

                    onMetadata: (metadata) => {
                        if (!metadataReceived) {
                            metadataReceived = true;
                            displayMetadata(metadata);

                            try {
                                if (tempPlayer) {
                                    tempPlayer.stop();
                                }
                            } catch (e) {
                                console.log('Error stopping temp player:', e);
                            }
                        }
                    },

                    onError: (error) => {
                        try {
                            if (tempPlayer) {
                                tempPlayer.stop();
                            }
                        } catch (e) {
                            // Ignore cleanup errors
                        }
                    }
                });

                if (tempPlayer.audioElement) {
                    tempPlayer.audioElement.volume = 0;
                    tempPlayer.audioElement.muted = true;
                    tempPlayer.play().catch(error => {
                    });
                } else {
                    setTimeout(() => {
                        if (tempPlayer && tempPlayer.audioElement) {
                            tempPlayer.audioElement.volume = 0;
                            tempPlayer.audioElement.muted = true;
                            tempPlayer.play().catch(error => {
                            });
                        }
                    }, 100);
                }

                setTimeout(() => {
                    if (tempPlayer && !metadataReceived) {
                        try {
                            tempPlayer.stop();
                        } catch (e) {
                            // Ignore cleanup errors
                        }
                    }
                }, 5000);

            } catch (error) {
            }
        }

        // Start periodic metadata fetching
        function startMetadataPlayerRefreshInterval() {
            // Clear any existing interval
            clearMetadataPlayerRefreshInterval();

            // Fetch immediately
            fetchMetadataOnce();

            // Start periodic fetching
            metadataOnlyPlayerRefreshIntervalId = setInterval(() => {
                // Try to fetch new metadata
                fetchMetadataOnce();

                // Also refresh the notification with current metadata
                // This ensures notification stays updated even when background fetch fails
                if (currentTrack && (currentTrack.title || currentTrack.artist)) {
                    updateMediaSession(
                        currentTrack.title,
                        currentTrack.artist,
                        currentTrack.album,
                        currentTrack.artworkUrl
                    );
                } else if (currentStation) {
                    // If no track metadata, at least update with station info
                    updateMediaSession(
                        currentStation.name,
                        '',
                        '',
                        currentStation.icon_url
                    );
                }
            }, metadataOnlyPlayerRefreshInterval);

        }

        // Start metadata-only player (periodic fetching for Chromecast sessions)
        function startMetadataOnlyPlayer() {
            if (!currentStation || metadataOnlyPlayerRefreshIntervalId) {
                return; // Already running or no station
            }


            // Start periodic metadata fetching
            startMetadataPlayerRefreshInterval();
        }

        // Stop metadata-only player
        function stopMetadataOnlyPlayer() {
            clearMetadataPlayerRefreshInterval(); // Clear refresh interval
        }

        // Start metadata-only player for Simple Mode (deprecated - now uses periodic fetching)
        function startMetadataOnlyPlayerForSimpleMode(rawUrl) {
            startMetadataPlayerRefreshInterval();
        }

        // Fallback: Start metadata-only player with direct URL (deprecated - now uses periodic fetching)
        function startMetadataOnlyPlayerDirect(rawUrl) {
            startMetadataPlayerRefreshInterval();
        }

        // Theme Toggle Functionality
        const themeToggle = document.getElementById('themeToggle');
        const resetThemeBtn = document.getElementById('resetThemeBtn');
        const colorThemeBtns = document.querySelectorAll('.color-theme-btn');
        const html = document.documentElement;

        // Function to get system theme preference (brightness only)
        function getSystemBrightness() {
            return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        }

        // Function to show/hide reset button
        function updateResetButtonVisibility() {
            const hasManualBrightness = localStorage.getItem('themeBrightness');
            // Only show reset button if brightness is manually set
            if (hasManualBrightness) {
                resetThemeBtn.style.display = 'flex';
            } else {
                resetThemeBtn.style.display = 'none';
            }
        }

        // Function to build full theme string
        function buildThemeString(color, brightness) {
            if (color === 'default') {
                return brightness; // 'dark' or 'light'
            }
            return `${color}-${brightness}`; // e.g., 'ocean-blue-dark'
        }

        // Function to apply theme
        function applyTheme(color, brightness) {
            const themeString = buildThemeString(color, brightness);
            html.setAttribute('data-theme', themeString);
            updateThemeToggleUI(brightness);
            updateColorThemeUI(color);
        }

        // Load saved theme or use system preference
        const savedColor = localStorage.getItem('themeColor') || 'default';
        const savedBrightness = localStorage.getItem('themeBrightness') || getSystemBrightness();
        applyTheme(savedColor, savedBrightness);
        updateResetButtonVisibility();

        // Listen for system theme changes (only if user hasn't set a manual preference)
        const darkModeMediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
        darkModeMediaQuery.addEventListener('change', (e) => {
            // Only auto-update if user hasn't manually set brightness
            if (!localStorage.getItem('themeBrightness')) {
                const systemBrightness = e.matches ? 'dark' : 'light';
                const currentColor = localStorage.getItem('themeColor') || 'default';
                applyTheme(currentColor, systemBrightness);
            }
        });

        // Brightness toggle click handler
        themeToggle.addEventListener('click', () => {
            const currentTheme = html.getAttribute('data-theme');
            // Determine current brightness
            const currentBrightness = currentTheme.endsWith('-light') || currentTheme === 'light' ? 'light' : 'dark';
            const newBrightness = currentBrightness === 'dark' ? 'light' : 'dark';
            const currentColor = localStorage.getItem('themeColor') || 'default';

            applyTheme(currentColor, newBrightness);
            localStorage.setItem('themeBrightness', newBrightness);
            updateResetButtonVisibility();
        });

        // Color theme button click handlers
        colorThemeBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const newColor = btn.getAttribute('data-color');
                const currentTheme = html.getAttribute('data-theme');
                const currentBrightness = currentTheme.endsWith('-light') || currentTheme === 'light' ? 'light' : 'dark';

                applyTheme(newColor, currentBrightness);
                localStorage.setItem('themeColor', newColor);
                updateResetButtonVisibility();
            });
        });

        // Reset theme button click handler
        resetThemeBtn.addEventListener('click', () => {
            localStorage.removeItem('themeBrightness');
            // Keep the selected color, only reset brightness to system preference
            const currentColor = localStorage.getItem('themeColor') || 'default';
            const systemBrightness = getSystemBrightness();
            applyTheme(currentColor, systemBrightness);
            updateResetButtonVisibility();
        });

        // Update brightness toggle UI
        function updateThemeToggleUI(brightness) {
            const darkOption = themeToggle.querySelector('[data-theme="dark"]');
            const lightOption = themeToggle.querySelector('[data-theme="light"]');

            if (brightness === 'dark') {
                darkOption.classList.add('active');
                lightOption.classList.remove('active');
            } else {
                darkOption.classList.remove('active');
                lightOption.classList.add('active');
            }
        }

        // Update color theme UI
        function updateColorThemeUI(color) {
            colorThemeBtns.forEach(btn => {
                if (btn.getAttribute('data-color') === color) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        // ======================
        // LAYOUT TOGGLE (Portrait/Landscape)
        // ======================

        const layoutToggle = document.getElementById('layoutToggle');
        const body = document.body;

        // Helper function to lock/unlock screen orientation
        async function setScreenOrientation(layout) {
            // Check if Screen Orientation API is supported
            if ('orientation' in screen && 'lock' in screen.orientation) {
                try {
                    if (layout === 'landscape') {
                        // Lock to landscape orientation
                        await screen.orientation.lock('landscape');
                        console.log('Screen orientation locked to landscape');
                    } else {
                        // Unlock orientation for portrait mode
                        screen.orientation.unlock();
                        console.log('Screen orientation unlocked');
                    }
                } catch (error) {
                    // Orientation lock may fail if not in fullscreen or PWA
                    console.log('Screen orientation lock not available:', error.message);
                }
            } else {
                console.log('Screen Orientation API not supported');
            }
        }

        // Get saved layout or default to portrait
        const savedLayout = localStorage.getItem('layout') || 'portrait';
        body.setAttribute('data-layout', savedLayout);
        updateLayoutToggleUI(savedLayout);
        setScreenOrientation(savedLayout);

        // Layout toggle click handler
        layoutToggle.addEventListener('click', () => {
            const currentLayout = body.getAttribute('data-layout') || 'portrait';
            const newLayout = currentLayout === 'portrait' ? 'landscape' : 'portrait';

            body.setAttribute('data-layout', newLayout);
            localStorage.setItem('layout', newLayout);
            updateLayoutToggleUI(newLayout);
            setScreenOrientation(newLayout);
        });

        // Update layout toggle UI based on current layout
        function updateLayoutToggleUI(layout) {
            const portraitOption = layoutToggle.querySelector('[data-layout="portrait"]');
            const landscapeOption = layoutToggle.querySelector('[data-layout="landscape"]');

            if (layout === 'landscape') {
                landscapeOption.classList.add('active');
                portraitOption.classList.remove('active');
            } else {
                portraitOption.classList.add('active');
                landscapeOption.classList.remove('active');
            }
        }

        // Liked Tracks Modal event listeners
        closeLikedTracksModal.addEventListener('click', () => {
            likedTracksModal.classList.remove('active');
        });
        
        likedTracksModal.addEventListener('click', (e) => {
            if (e.target === likedTracksModal) {
                likedTracksModal.classList.remove('active');
            }
        });
        
        clearAllLikesBtn.addEventListener('click', clearAllLikedTracks);
        
        // Copy All Liked Tracks button
        const copyAllLikedBtn = document.getElementById('copyAllLikedBtn');
        copyAllLikedBtn.addEventListener('click', copyAllLikedTracks);
        
        // Download Liked Tracks button
        const downloadLikedBtn = document.getElementById('downloadLikedBtn');
        downloadLikedBtn.addEventListener('click', downloadLikedTracksFile);
        
        // Recent Tracks Modal
        const recentTracksModal = document.getElementById('recentTracksModal');
        const closeRecentTracksModal = document.getElementById('closeRecentTracksModal');
        const clearRecentTracksBtn = document.getElementById('clearRecentTracksBtn');

        closeRecentTracksModal.addEventListener('click', () => {
            recentTracksModal.classList.remove('active');
        });
        
        recentTracksModal.addEventListener('click', (e) => {
            if (e.target === recentTracksModal) {
                recentTracksModal.classList.remove('active');
            }
        });
        
        clearRecentTracksBtn.addEventListener('click', () => {
            console.log('üü¢ Clear Recent Tracks button clicked');
            handleClearRecentTracks();
        });

        // Copy All Recent Tracks button
        const copyAllRecentBtn = document.getElementById('copyAllRecentBtn');
        copyAllRecentBtn.addEventListener('click', copyAllRecentTracks);

        // Download Recent Tracks button
        const downloadRecentBtn = document.getElementById('downloadRecentBtn');
        downloadRecentBtn.addEventListener('click', downloadRecentTracksFile);

        // Modal buttons for Liked Tracks and Recent Tracks
        const modalViewLikedTracksBtn = document.getElementById('modalViewLikedTracksBtn');
        const modalViewRecentTracksBtn = document.getElementById('modalViewRecentTracksBtn');

        if (modalViewLikedTracksBtn) {
            modalViewLikedTracksBtn.addEventListener('click', () => {
                displayLikedTracks();
                nowPlayingModal.classList.remove('active');
                likedTracksModal.classList.add('active');
                pushToNavigationHistory('likedTracksModal');
            });
        }

        if (modalViewRecentTracksBtn) {
            modalViewRecentTracksBtn.addEventListener('click', () => {
                displayRecentTracks();
                nowPlayingModal.classList.remove('active');
                recentTracksModal.classList.add('active');
                pushToNavigationHistory('recentTracksModal');
            });
        }

        // Lyrics Modal event listeners
        const lyricsModal = document.getElementById('lyricsModal');
        const closeLyricsModalBtn = document.getElementById('closeLyricsModal');

        closeLyricsModalBtn.addEventListener('click', closeLyricsModal);

        lyricsModal.addEventListener('click', (e) => {
            if (e.target === lyricsModal) {
                closeLyricsModal();
            }
        });

        // Now Playing Modal event listeners
        const nowPlayingModal = document.getElementById('nowPlayingModal');
        const closeNowPlayingModalBtn = document.getElementById('closeNowPlayingModal');
        const metadataSection = document.getElementById('metadataSection');

        metadataSection.addEventListener('click', openNowPlayingModal);

        closeNowPlayingModalBtn.addEventListener('click', closeNowPlayingModal);

        nowPlayingModal.addEventListener('click', (e) => {
            if (e.target === nowPlayingModal) {
                closeNowPlayingModal();
            }
        });

        // Close playlist modal
        closePlaylistModal.addEventListener('click', () => {
            playlistModal.classList.remove('active');
            currentPlaylist = null;
        });

        // Create playlist button
        createPlaylistBtn.addEventListener('click', () => {
            showPlaylistForm();
        });

        // Create playlist menu button (from hamburger menu)
        document.getElementById('createPlaylistMenuBtn').addEventListener('click', () => {
            hamburgerMenuModal.classList.remove('active');
            showPlaylistForm();
        });

        // View playlists menu button (from hamburger menu)
        document.getElementById('viewPlaylistsBtn').addEventListener('click', () => {
            hamburgerMenuModal.classList.remove('active');
            playlistsModal.classList.add('active');
            pushToNavigationHistory('playlistsModal');
        });

        // Add station button
        document.getElementById('addStationBtn').addEventListener('click', () => {
            showStationForm();
        });

        // Manage Preset Searches button (admin only)
        document.getElementById('managePresetSearchesBtn').addEventListener('click', () => {
            hamburgerMenuModal.classList.remove('active');
            document.getElementById('adminPresetSearchesModal').classList.add('active');
            loadAdminPresetSearches();
        });

        // Close admin preset searches modal
        document.getElementById('closeAdminPresetSearchesModal').addEventListener('click', () => {
            document.getElementById('adminPresetSearchesModal').classList.remove('active');
        });

        // Add new preset search button
        document.getElementById('addNewPresetSearchBtn').addEventListener('click', () => {
            showPresetSearchForm();
        });

        // Manage Curated Playlists button (admin only)
        document.getElementById('manageCuratedPlaylistsBtn').addEventListener('click', () => {
            hamburgerMenuModal.classList.remove('active');
            document.getElementById('adminCuratedPlaylistsModal').classList.add('active');
            loadAdminCuratedPlaylists();
        });

        // Close admin curated playlists modal
        document.getElementById('closeAdminCuratedPlaylistsModal').addEventListener('click', () => {
            document.getElementById('adminCuratedPlaylistsModal').classList.remove('active');
        });

        // Add new curated playlist button
        document.getElementById('addNewCuratedPlaylistBtn').addEventListener('click', () => {
            showCuratedPlaylistForm();
        });

        // Close preset search form modal
        document.getElementById('closePresetSearchFormModal').addEventListener('click', () => {
            document.getElementById('presetSearchFormModal').classList.remove('active');
        });

        // Cancel preset search form
        document.getElementById('cancelPresetSearchFormBtn').addEventListener('click', () => {
            document.getElementById('presetSearchFormModal').classList.remove('active');
        });

        // Preset search form submission
        document.getElementById('presetSearchForm').addEventListener('submit', savePresetSearch);

        // Playlist form
        playlistForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            const name = playlistName.value.trim();
            const description = playlistDescription.value.trim();

            if (!name) return;

            let newPlaylist = null;
            if (editingPlaylistId) {
                await updatePlaylist(editingPlaylistId, name, description);
            } else {
                newPlaylist = await createPlaylist(name, description);
            }

            playlistFormModal.classList.remove('active');
            editingPlaylistId = null;

            // If we have a pending context, return to the playlist selector
            if (pendingPlaylistSelectorContext && newPlaylist) {
                const context = pendingPlaylistSelectorContext;
                pendingPlaylistSelectorContext = null; // Clear the context

                // Reopen the appropriate playlist selector
                if (context.type === 'radio-browser') {
                    showPlaylistSelectorForRadioBrowser(context.station);
                } else if (context.type === 'current-station') {
                    showPlaylistSelectorForCurrentStation();
                } else if (context.type === 'curated-station') {
                    showPlaylistSelectorForCuratedStation(context.station);
                }
            }
        });
        
        // Close playlist form
        closePlaylistFormModal.addEventListener('click', () => {
            playlistFormModal.classList.remove('active');
            editingPlaylistId = null;
            pendingPlaylistSelectorContext = null; // Clear pending context
        });

        cancelPlaylistForm.addEventListener('click', () => {
            playlistFormModal.classList.remove('active');
            editingPlaylistId = null;
            pendingPlaylistSelectorContext = null; // Clear pending context
        });
        
        // Station form
        stationForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            // Get form values
            const name = document.getElementById('stationFormName').value.trim();
            const url = document.getElementById('stationFormUrl').value.trim();
            const url_low = document.getElementById('stationFormUrlLow').value.trim() || null;
            const url_high = document.getElementById('stationFormUrlHigh').value.trim() || null;
            const call_letters = document.getElementById('stationFormCallLetters').value.trim() || null;
            const frequency = document.getElementById('stationFormFrequency').value.trim() || null;
            const website_url = document.getElementById('stationFormWebsiteUrl').value.trim() || null;
            const genresInput = document.getElementById('stationFormGenres').value.trim();
            const description = document.getElementById('stationFormDescription').value.trim() || null;
            let icon_url = document.getElementById('stationFormIconUrl').value.trim() || null;
            
            // Validate required fields
            if (!name || !url) {
                alert('Station name and URL are required!');
                return;
            }
            
            // Check if there's an uploaded image file
            const fileInput = document.getElementById('stationFormIconUpload');
            if (fileInput.files && fileInput.files[0]) {
                try {
                    // Upload image to Supabase Storage
                    const file = fileInput.files[0];
                    const fileExt = file.name.split('.').pop();
                    const fileName = `${Date.now()}-${Math.random().toString(36).substring(2)}.${fileExt}`;
                    const filePath = `station-icons/${fileName}`;
                    
                    console.log('Uploading image to Supabase Storage:', filePath);
                    
                    const { data: uploadData, error: uploadError } = await supabase.storage
                        .from('station-images')
                        .upload(filePath, file, {
                            cacheControl: '3600',
                            upsert: false
                        });
                    
                    if (uploadError) {
                        console.error('Upload error:', uploadError);
                        alert('Failed to upload image: ' + uploadError.message);
                        return;
                    }
                    
                    // Get public URL
                    const { data: urlData } = supabase.storage
                        .from('station-images')
                        .getPublicUrl(filePath);
                    
                    icon_url = urlData.publicUrl;
                    console.log('Image uploaded successfully:', icon_url);
                    
                } catch (error) {
                    console.error('Upload error:', error);
                    alert('Failed to upload image: ' + error.message);
                    return;
                }
            }
            
            // Convert genres string to array if needed
            // If user enters "News,Talk" or "News, Talk", convert to ["News", "Talk"]
            let genres = null;
            if (genresInput) {
                // Split by comma and trim whitespace from each genre
                genres = genresInput.split(',').map(g => g.trim()).filter(g => g.length > 0);
            }
            
            const stationData = {
                name: name,
                url: url,
                url_low: url_low,
                url_high: url_high,
                call_letters: call_letters,
                frequency: frequency,
                website_url: website_url,
                genres: genres, // Now an array like ["News", "Talk"] or null
                description: description,
                icon_url: icon_url
            };
            
            console.log('Form submission - editingStationId:', editingStationId);
            console.log('Form submission - stationData:', stationData);
            
            if (editingStationId) {
                await updateStation(editingStationId, stationData);
            } else {
                await createStation(stationData);
            }
            
            stationFormModal.classList.remove('active');
            editingStationId = null;
        });
        
        // Image upload handlers
        const uploadIconBtn = document.getElementById('uploadIconBtn');
        const stationFormIconUpload = document.getElementById('stationFormIconUpload');
        const iconPreview = document.getElementById('iconPreview');
        const iconPreviewImg = document.getElementById('iconPreviewImg');
        const iconPreviewName = document.getElementById('iconPreviewName');
        const iconPreviewSize = document.getElementById('iconPreviewSize');
        const removeIconBtn = document.getElementById('removeIcon');
        
        uploadIconBtn.addEventListener('click', () => {
            stationFormIconUpload.click();
        });
        
        stationFormIconUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                // Check file size (max 5MB)
                if (file.size > 5 * 1024 * 1024) {
                    alert('Image size must be less than 5MB');
                    e.target.value = '';
                    return;
                }
                
                // Show preview
                const reader = new FileReader();
                reader.onload = (e) => {
                    iconPreviewImg.src = e.target.result;
                    iconPreviewName.textContent = file.name;
                    iconPreviewSize.textContent = `${(file.size / 1024).toFixed(1)} KB`;
                    iconPreview.style.display = 'flex';
                    uploadIconBtn.textContent = '‚úì Image Selected';
                    uploadIconBtn.style.background = 'var(--success-color, #4caf50)';
                };
                reader.readAsDataURL(file);
            }
        });
        
        removeIconBtn.addEventListener('click', () => {
            stationFormIconUpload.value = '';
            iconPreview.style.display = 'none';
            uploadIconBtn.textContent = 'üì∑ Choose Image';
            uploadIconBtn.style.background = '';
        });
        
        // Close station form
        closeStationFormModal.addEventListener('click', () => {
            stationFormModal.classList.remove('active');
            editingStationId = null;
        });
        
        cancelStationForm.addEventListener('click', () => {
            stationFormModal.classList.remove('active');
            editingStationId = null;
        });
        
        // Search stations
        // Search input handler
        stationSearch.addEventListener('input', (e) => {
            console.log('Search input event fired, value:', e.target.value);
            const clearBtn = document.getElementById('clearSearchBtn');
            
            // Show/hide clear button based on input
            if (e.target.value.trim() !== '' || currentGenreFilter !== '') {
                clearBtn.style.display = 'flex';
            } else {
                clearBtn.style.display = 'none';
            }
            
            filterStations(e.target.value);
        });
        
        // Clear search button
        const clearSearchBtn = document.getElementById('clearSearchBtn');
        clearSearchBtn.addEventListener('click', () => {
            // Clear search input
            stationSearch.value = '';
            
            // Reset genre filter to "All Genres"
            currentGenreFilter = '';
            const genreLabel = document.getElementById('genreLabel');
            genreLabel.textContent = 'All Genres';
            
            // Update active state in genre dropdown
            document.querySelectorAll('.filter-dropdown#genreDropdown .filter-option').forEach(opt => {
                if (opt.dataset.genre === '') {
                    opt.classList.add('active');
                } else {
                    opt.classList.remove('active');
                }
            });
            
            // Hide clear button
            clearSearchBtn.style.display = 'none';
            
            // Refilter stations
            filterStations('');
        });
        
        // Genre dropdown toggle
        genreBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            genreDropdown.classList.toggle('active');
            sortDropdown.classList.remove('active'); // Close sort dropdown
        });
        
        // Sort dropdown toggle
        sortBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            sortDropdown.classList.toggle('active');
            genreDropdown.classList.remove('active'); // Close genre dropdown
        });
        
        // Sort option selection
        document.querySelectorAll('.filter-dropdown#sortDropdown .filter-option').forEach(option => {
            option.addEventListener('click', async (e) => {
                e.stopPropagation();
                
                // Update active state
                document.querySelectorAll('.filter-dropdown#sortDropdown .filter-option').forEach(opt => opt.classList.remove('active'));
                option.classList.add('active');
                
                // Update sort method
                currentSortMethod = option.dataset.sort;
                
                // Update button label
                sortLabel.textContent = option.textContent.trim();
                
                // Close dropdown
                sortDropdown.classList.remove('active');
                
                // Apply sort
                await sortStations();
            });
        });
        
        // Quality modal
        // Quality button removed from main UI - now only accessible via Station Info modal
        const qualityModal = document.getElementById('qualityModal');
        const closeQualityModal = document.getElementById('closeQualityModal');

        // Playback mode modal
        const playbackModeBtn = document.getElementById('playbackModeBtn');
        const playbackModeModal = document.getElementById('playbackModeModal');
        const closePlaybackModeModal = document.getElementById('closePlaybackModeModal');
        const currentModeText = document.getElementById('currentMode');
        
        closeQualityModal.addEventListener('click', () => {
            qualityModal.classList.remove('active');
        });
        
        qualityModal.addEventListener('click', (e) => {
            if (e.target === qualityModal) {
                qualityModal.classList.remove('active');
            }
        });
        
        // Quality option selection
        qualityModal.querySelectorAll('.quality-option-modal[data-quality]').forEach(option => {
            option.addEventListener('click', () => {
                // Don't allow selecting disabled options
                if (option.classList.contains('disabled')) {
                    return;
                }
                
                // Check if this is already selected
                if (option.classList.contains('selected')) {
                    qualityModal.classList.remove('active');
                    return;
                }
                
                const wasPlaying = isPlaying;
                const newQuality = option.dataset.quality;
                
                qualityModal.querySelectorAll('.quality-option-modal[data-quality]').forEach(opt => opt.classList.remove('selected'));
                option.classList.add('selected');
                selectedQuality = newQuality;

                // Close modals
                qualityModal.classList.remove('active');
                stationInfoModal.classList.remove('active');

                // If a station is selected, start playing with new quality
                if (currentStation) {
                    console.log(`Switching to ${newQuality} quality...`);
                    updateStatus(`Switching to ${newQuality} quality...`, 'loading');

                    // Stop any current playback
                    if (player) {
                        player.stop();
                    }

                    // Stop metadata-only player so it restarts with new quality URL
                    stopMetadataOnlyPlayer();

                    // Ensure isPlaying is false so the next click will start playing
                    isPlaying = false;

                    // Wait a moment for the stop to complete, then start new stream
                    setTimeout(() => {
                        // Force play by simulating a click
                        playPauseBtn.click();
                    }, 300);
                }
            });
        });

        // Playback mode modal handlers - commented out since button is hidden
        /*
        playbackModeBtn.addEventListener('click', () => {
            playbackModeModal.classList.add('active');
        });

        closePlaybackModeModal.addEventListener('click', () => {
            playbackModeModal.classList.remove('active');
        });

        playbackModeModal.addEventListener('click', (e) => {
            if (e.target === playbackModeModal) {
                playbackModeModal.classList.remove('active');
            }
        });

        // Playback mode option selection
        const modeOptions = playbackModeModal.querySelectorAll('.quality-option-modal[data-mode]');
        console.log('Found', modeOptions.length, 'mode options');
        modeOptions.forEach(option => {
            option.addEventListener('click', () => {
                console.log('Mode option clicked:', option.dataset.mode);

                // Check if this is already selected
                if (option.classList.contains('selected')) {
                    playbackModeModal.classList.remove('active');
                    return;
                }

                const wasPlaying = isPlaying;
                const newMode = option.dataset.mode;

                // Stop current playback
                stopAllPlayers();

                modeOptions.forEach(opt => opt.classList.remove('selected'));
                option.classList.add('selected');
                playbackMode = newMode;

                // Update button text
                const modeNames = {
                    'live': 'Live',
                    'simple': 'Simple'
                };
                if (currentModeText) currentModeText.textContent = modeNames[newMode];

                // Close modal
                playbackModeModal.classList.remove('active');

                // If player was playing, restart with new mode
                if (wasPlaying && currentStation) {
                    console.log(`Switching to ${newMode} mode...`);
                    setTimeout(() => {
                        playPauseBtn.click();
                    }, 200);
                }
            });
        });
        */

        // Close modals on overlay click
        [playlistsModal, browseStationsModal, playlistModal, playlistFormModal, stationFormModal, qualityModal, playbackModeModal, allCuratedPlaylistsModal].forEach(modal => {
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.classList.remove('active');
                }
            });
        });
        
        // ======================
        // METADATA DISPLAY
        // ======================
        
        // Helper function to display station icon
        function displayStationIcon() {
            if (currentStation && currentStation.icon_url) {
                updateArtwork(`<img src="${escapeHtml(currentStation.icon_url)}" alt="${escapeHtml(currentStation.name)}" class="album-art" onerror="this.onerror=null; this.src='${MUSIC_NOTE_DATA_URI}'">`);
            } else {
                updateArtwork(`<div class="album-art" style="padding: 40px;">${MUSIC_NOTE_ICON}</div>`);
            }
            // Reset last fetched track and lyrics to allow fresh fetches when metadata returns
            lastFetchedTrack = { title: null, artist: null };
            lastFetchedLyrics = { title: null, artist: null, lyrics: null, lyricsUrl: null, hasLyrics: false };
        }
        
        // Display metadata
        function displayMetadata(metadata) {
            if (!metadata || !metadata.StreamTitle) {
                metadataDiv.innerHTML = `
                    <div class="now-playing-label">NOW PLAYING</div>
                    <div class="no-metadata">No metadata available</div>
                `;
                displayStationIcon();
                // Reset current track
                currentTrack = { title: null, artist: null, album: null, artworkUrl: null, lyrics: null, lyricsUrl: null, hasLyrics: false };
                // Reset last fetched track and lyrics to allow fresh fetches when metadata returns
                lastFetchedTrack = { title: null, artist: null };
                lastFetchedLyrics = { title: null, artist: null };
                updateLikeButton();
                updateLyricsIndicator();
                // Update media session with station info when no metadata
                if (currentStation) {
                    updateMediaSession(
                        currentStation.name,
                        '',
                        '',
                        currentStation.icon_url
                    );
                }
                return;
            }
            
            const streamTitle = metadata.StreamTitle || '';
            let title = 'Unknown';
            let artist = '';
            let album = '';
            
            // Check if metadata is in structured attribute format: title="...",artist="..."
            // Use non-greedy .*? to handle apostrophes in values like "Don't Stop"
            const titleMatch = streamTitle.match(/title=(?:"(.*?)"|'(.*?)')/i);
            const artistMatch = streamTitle.match(/artist=(?:"(.*?)"|'(.*?)')/i);

            if (titleMatch || artistMatch) {
                // Structured format detected
                title = titleMatch ? (titleMatch[1] || titleMatch[2]).trim() : 'Unknown';
                artist = artistMatch ? (artistMatch[1] || artistMatch[2]).trim() : '';
            } else {
                // Helper function to clean metadata text (remove XML attributes from iHeart and similar stations)
                function cleanMetadataText(text) {
                    if (!text) return '';

                    // First, check if the text starts with text="..." pattern and extract the value
                    // Use non-greedy .*? to handle apostrophes in values like "Don't Stop"
                    const textMatch = text.match(/^text=(?:"(.*?)"|'(.*?)')/i);
                    if (textMatch) {
                        return (textMatch[1] || textMatch[2]).trim();
                    }

                    // Otherwise, remove everything after common attribute patterns like text=", song_spot=", etc.
                    // This matches patterns like: text="..." or attribute="value" or attribute='value'
                    // Use non-greedy .*? to handle apostrophes in attribute values
                    const cleaned = text.replace(/\s+(text|song_spot|spotInstanceId|length|MediaBaseId|TAID|TPID|cartcutId|amgArtworkURL|spEventID|[a-zA-Z_]+)=(?:"(.*?)"|'(.*?)').*$/i, '');
                    return cleaned.trim();
                }
                
                // Traditional format: "Artist - Title"
                if (streamTitle.includes(' - ')) {
                    const parts = streamTitle.split(' - ');
                    artist = cleanMetadataText(parts[0].trim());
                    title = cleanMetadataText(parts[1].trim());
                } else {
                    title = cleanMetadataText(streamTitle);
                }
            }
            
            // Update current track
            currentTrack.title = title;
            currentTrack.artist = artist;
            currentTrack.album = album;

            // Update media session immediately with track info (before album art loads)
            // This ensures the notification shade updates even when app is backgrounded
            updateMediaSession(title, artist, album, currentTrack.artworkUrl || null);

            // Add to recent tracks
            window.addToRecentTracks({
                title: title,
                artist: artist,
                album: album,
                artworkUrl: null, // Will be updated when album art loads
                station: currentStation ? currentStation.name : 'Unknown Station'
            });
            
            metadataDiv.innerHTML = `
                <div class="now-playing-label">NOW PLAYING</div>
                <div class="song-title">${escapeHtml(title)}</div>
                ${artist ? `<div class="artist-name">${escapeHtml(artist)}</div>` : ''}
                ${album ? `<div class="album-name">${escapeHtml(album)}</div>` : ''}
            `;
            
            // Try to fetch album art
            fetchAlbumArt(title, artist);

            // Fetch lyrics for the current track
            fetchLyricsForCurrentTrack();

            // Update Cast metadata if casting
            updateCastMetadata(title, artist, null); // Will update again with artwork when fetched
        }
        
        // Fetch album art from iTunes or MusicBrainz
        let lastFetchedTrack = { title: null, artist: null }; // Track what we last fetched to avoid duplicates

        async function fetchAlbumArt(title, artist) {
            if (!artist || !title) {
                displayStationIcon();
                return;
            }

            // Check if we've already fetched artwork for this exact song
            if (lastFetchedTrack.title === title && lastFetchedTrack.artist === artist) {
                console.log('Skipping duplicate artwork fetch for:', `"${artist}" - "${title}"`);
                return;
            }

            // Update the last fetched track
            lastFetchedTrack = { title, artist };

            const useItunes = document.getElementById('useItunesApi').checked;

            if (useItunes) {
                await fetchAlbumArtItunes(title, artist);
            } else {
                await fetchAlbumArtMusicBrainz(title, artist);
            }
        }
        
        // Fetch album art from iTunes API
        async function fetchAlbumArtItunes(title, artist) {
            try {
                // Clean up artist name - take first artist if multiple
                let cleanArtist = artist.split(/[\/&]|feat\.|ft\./i)[0].trim();
                
                console.log(`Searching iTunes for: "${cleanArtist}" - "${title}"`);
                
                const query = encodeURIComponent(`${cleanArtist} ${title}`);
                const itunesUrl = `https://itunes.apple.com/search?term=${query}&entity=song&limit=1`;
                
                const response = await fetch(itunesUrl);
                const data = await response.json();
                
                if (data.results && data.results.length > 0) {
                    const result = data.results[0];
                    // iTunes returns 100x100 by default, we can get higher res by replacing with 600x600
                    let artUrl = result.artworkUrl100;
                    if (artUrl) {
                        artUrl = artUrl.replace('100x100', '600x600');
                        
                        // Store artwork URL in current track
                        currentTrack.artworkUrl = artUrl;
                        
                        const img = new Image();
                        img.onload = () => {
                            updateArtwork(`<img src="${artUrl}" alt="Album Art" class="album-art">`);
                            updateMediaSession(title, artist, result.collectionName || '', artUrl);
                            // Update Cast with album art
                            updateCastMetadata(title, artist, artUrl);
                            // Update recent tracks with artwork
                            if (currentTrack.title && currentTrack.artist) {
                                window.addToRecentTracks({
                                    title: currentTrack.title,
                                    artist: currentTrack.artist,
                                    album: currentTrack.album,
                                    artworkUrl: artUrl,
                                    station: currentStation ? currentStation.name : 'Unknown Station'
                                });
                            }
                        };
                        img.onerror = () => {
                            displayStationIcon();
                        };
                        img.src = artUrl;
                        return;
                    }
                }
            } catch (error) {
                console.error('Error fetching album art from iTunes:', error);
            }
            
            currentTrack.artworkUrl = null;
            displayStationIcon();
            updateMediaSession(title, artist, '', null);
        }
        
        // Fetch album art from MusicBrainz/Cover Art Archive
        async function fetchAlbumArtMusicBrainz(title, artist) {
            try {
                // Clean up artist name - take first artist if multiple (separated by /, feat., &, etc.)
                let cleanArtist = artist.split(/[\/&]|feat\.|ft\./i)[0].trim();
                
                // Log what we're searching for (helps with debugging)
                console.log(`Searching MusicBrainz for: "${cleanArtist}" - "${title}"`);
                
                const query = encodeURIComponent(`${cleanArtist} ${title}`);
                const mbUrl = `https://musicbrainz.org/ws/2/recording/?query=${query}&fmt=json&limit=1`;
                
                const mbResponse = await fetch(mbUrl);
                const mbData = await mbResponse.json();
                
                if (mbData.recordings && mbData.recordings.length > 0) {
                    const recording = mbData.recordings[0];
                    if (recording.releases && recording.releases.length > 0) {
                        const releaseId = recording.releases[0].id;
                        const artUrl = `https://coverartarchive.org/release/${releaseId}/front-500`;
                        
                        const img = new Image();
                        img.onload = () => {
                            updateArtwork(`<img src="${artUrl}" alt="Album Art" class="album-art">`);
                            updateMediaSession(title, artist, '', artUrl);
                            // Update Cast with album art
                            updateCastMetadata(title, artist, artUrl);
                            // Update recent tracks with artwork
                            if (currentTrack.title && currentTrack.artist) {
                                window.addToRecentTracks({
                                    title: currentTrack.title,
                                    artist: currentTrack.artist,
                                    album: currentTrack.album,
                                    artworkUrl: artUrl,
                                    station: currentStation ? currentStation.name : 'Unknown Station'
                                });
                            }
                        };
                        img.onerror = () => {
                            displayStationIcon();
                        };
                        img.src = artUrl;
                        return;
                    }
                }
            } catch (error) {
                console.error('Error fetching album art from MusicBrainz:', error);
            }
            
            displayStationIcon();
            updateMediaSession(title, artist, '', null);
        }

        // ======================
        // LRCLIB LYRICS API
        // ======================

        // Fetch lyrics using LrcLib API
        async function fetchLrcLibLyrics(title, artist) {
            if (!title || !artist) {
                return null;
            }

            try {
                const params = new URLSearchParams({
                    artist_name: artist,
                    track_name: title
                });

                const url = `https://lrclib.net/api/get?${params}`;
                console.log(`Fetching lyrics from LrcLib: "${artist}" - "${title}"`);

                const response = await fetch(url);

                if (!response.ok) {
                    if (response.status === 404) {
                        console.log('No lyrics found on LrcLib');
                    } else {
                        console.error('LrcLib API request failed:', response.status);
                    }
                    return null;
                }

                const data = await response.json();

                // LrcLib returns plainLyrics and syncedLyrics
                // We'll use plainLyrics for radio streams since we can't sync
                if (data.plainLyrics && data.plainLyrics.trim().length > 0) {
                    return {
                        lyrics: data.plainLyrics,
                        trackName: data.trackName,
                        artistName: data.artistName,
                        albumName: data.albumName
                    };
                }

                return null;
            } catch (error) {
                console.error('Error fetching LrcLib lyrics:', error);
                return null;
            }
        }

        // Fetch and display lyrics for current track
        let lastFetchedLyrics = { title: null, artist: null, lyrics: null, lyricsUrl: null, hasLyrics: false }; // Track what we last fetched to avoid duplicates

        async function fetchLyricsForCurrentTrack() {
            if (!currentTrack.title || !currentTrack.artist) {
                return;
            }

            // Check if we've already fetched lyrics for this exact song
            if (lastFetchedLyrics.title === currentTrack.title && lastFetchedLyrics.artist === currentTrack.artist) {
                console.log('Skipping duplicate lyrics fetch for:', `"${currentTrack.artist}" - "${currentTrack.title}"`);
                // Restore previously fetched lyrics data
                currentTrack.lyrics = lastFetchedLyrics.lyrics;
                currentTrack.lyricsUrl = lastFetchedLyrics.lyricsUrl;
                currentTrack.hasLyrics = lastFetchedLyrics.hasLyrics;
                // Update the lyrics indicator to show the button
                updateLyricsIndicator();
                return;
            }

            try {
                // Fetch lyrics from LrcLib
                const result = await fetchLrcLibLyrics(currentTrack.title, currentTrack.artist);

                if (result && result.lyrics) {
                    currentTrack.lyrics = result.lyrics;
                    currentTrack.lyricsUrl = 'https://lrclib.net'; // Link to LrcLib homepage
                    currentTrack.hasLyrics = true;
                    console.log('Lyrics fetched successfully from LrcLib');
                } else {
                    currentTrack.hasLyrics = false;
                    currentTrack.lyrics = null;
                    currentTrack.lyricsUrl = null;
                }

                // Store the fetched lyrics data to avoid duplicate fetches
                lastFetchedLyrics = {
                    title: currentTrack.title,
                    artist: currentTrack.artist,
                    lyrics: currentTrack.lyrics,
                    lyricsUrl: currentTrack.lyricsUrl,
                    hasLyrics: currentTrack.hasLyrics
                };

                // Update artwork to show lyrics indicator
                updateLyricsIndicator();
            } catch (error) {
                console.error('Error fetching lyrics:', error);
                currentTrack.hasLyrics = false;
                currentTrack.lyrics = null;
                currentTrack.lyricsUrl = null;

                // Store the failed fetch result
                lastFetchedLyrics = {
                    title: currentTrack.title,
                    artist: currentTrack.artist,
                    lyrics: null,
                    lyricsUrl: null,
                    hasLyrics: false
                };

                updateLyricsIndicator();
            }
        }

        // Update lyrics button in metadata section
        function updateLyricsIndicator() {
            // Lyrics button is now in the Now Playing modal, so just remove any old buttons
            const existingButtons = document.querySelectorAll('.lyrics-btn');
            existingButtons.forEach(button => button.remove());

            // Show/hide the discreet lyrics indicator in the metadata section
            const lyricsIndicator = document.getElementById('lyricsIndicator');
            if (lyricsIndicator) {
                const shouldShow = currentTrack.hasLyrics;
                lyricsIndicator.style.display = shouldShow ? 'block' : 'none';
                console.log(`Lyrics indicator ${shouldShow ? 'SHOWN' : 'hidden'} for: "${currentTrack.artist}" - "${currentTrack.title}"`);
            }
        }

        // Show lyrics modal
        function showLyricsModal() {
            if (!currentTrack.hasLyrics) {
                return;
            }

            // Close Now Playing modal if it's open
            closeNowPlayingModal();

            const modal = document.getElementById('lyricsModal');
            const modalTitle = document.getElementById('lyricsModalTitle');
            const lyricsContent = document.getElementById('lyricsContent');

            // Set modal title
            modalTitle.textContent = `${currentTrack.title} - ${currentTrack.artist}`;

            if (currentTrack.lyrics) {
                // Display lyrics
                lyricsContent.innerHTML = `<pre class="lyrics-text">${escapeHtml(currentTrack.lyrics)}</pre>`;

                // Add attribution link
                if (currentTrack.lyricsUrl) {
                    lyricsContent.innerHTML += `<div class="lyrics-attribution">Lyrics from <a href="${currentTrack.lyricsUrl}" target="_blank" rel="noopener noreferrer">LrcLib</a></div>`;
                }
            } else {
                lyricsContent.innerHTML = '<div class="lyrics-error">Lyrics not available for this track.</div>';
            }

            modal.classList.add('active');
            lastOpenedModal = 'lyricsModal';
        }

        // Expose to global scope for onclick handlers
        window.showLyricsModal = showLyricsModal;

        // Close lyrics modal
        function closeLyricsModal() {
            const modal = document.getElementById('lyricsModal');
            modal.classList.remove('active');
        }

        // TheAudioDB API Service
        const AudioDBService = {
            baseUrl: 'https://www.theaudiodb.com/api/v1/json/2',
            cache: new Map(),

            // Search for artist by name
            async searchArtist(artistName) {
                if (!artistName) return null;

                const cacheKey = `artist_${artistName.toLowerCase()}`;
                if (this.cache.has(cacheKey)) {
                    return this.cache.get(cacheKey);
                }

                try {
                    const response = await fetch(`${this.baseUrl}/search.php?s=${encodeURIComponent(artistName)}`);
                    if (!response.ok) return null;

                    const data = await response.json();
                    const artist = data.artists && data.artists.length > 0 ? data.artists[0] : null;

                    this.cache.set(cacheKey, artist);
                    return artist;
                } catch (error) {
                    console.error('Error fetching artist info:', error);
                    return null;
                }
            },

            // Search for track by artist and track name
            async searchTrack(artistName, trackName) {
                if (!artistName || !trackName) return null;

                const cacheKey = `track_${artistName.toLowerCase()}_${trackName.toLowerCase()}`;
                if (this.cache.has(cacheKey)) {
                    return this.cache.get(cacheKey);
                }

                try {
                    const response = await fetch(
                        `${this.baseUrl}/searchtrack.php?s=${encodeURIComponent(artistName)}&t=${encodeURIComponent(trackName)}`
                    );
                    if (!response.ok) return null;

                    const data = await response.json();
                    const track = data.track && data.track.length > 0 ? data.track[0] : null;

                    this.cache.set(cacheKey, track);
                    return track;
                } catch (error) {
                    console.error('Error fetching track info:', error);
                    return null;
                }
            },

            // Get combined info for modal
            async getTrackAndArtistInfo(artistName, trackName) {
                const [artistInfo, trackInfo] = await Promise.all([
                    this.searchArtist(artistName),
                    this.searchTrack(artistName, trackName)
                ]);

                return { artistInfo, trackInfo };
            }
        };

        // Open now playing modal
        async function openNowPlayingModal() {
            const modal = document.getElementById('nowPlayingModal');

            // Update modal content
            document.getElementById('modalSongTitle').textContent = currentTrack.title || '';
            document.getElementById('modalArtistName').textContent = currentTrack.artist || '';
            document.getElementById('modalAlbumName').textContent = currentTrack.album || '';

            // Update like button state
            const modalLikeBtn = document.getElementById('modalLikeBtn');
            const isLiked = await window.isTrackLiked(currentTrack.title, currentTrack.artist);
            if (isLiked) {
                modalLikeBtn.classList.add('liked');
                modalLikeBtn.querySelector('span').textContent = 'Unlike This Song';
            } else {
                modalLikeBtn.classList.remove('liked');
                modalLikeBtn.querySelector('span').textContent = 'Like This Song';
            }

            // Update lyrics button state
            const modalLyricsBtn = document.getElementById('modalLyricsBtn');
            if (currentTrack.hasLyrics) {
                modalLyricsBtn.classList.remove('disabled');
            } else {
                modalLyricsBtn.classList.add('disabled');
            }

            // Show modal immediately with basic info
            modal.classList.add('active');

            // Hide enhanced sections initially
            const loadingIndicator = document.getElementById('audioDbLoadingIndicator');
            const trackDetailsSection = document.getElementById('trackDetailsSection');
            const artistInfoSection = document.getElementById('artistInfoSection');

            trackDetailsSection.style.display = 'none';
            artistInfoSection.style.display = 'none';

            // Fetch enhanced data from TheAudioDB if we have artist and track info
            if (currentTrack.artist && currentTrack.title) {
                loadingIndicator.style.display = 'flex';

                try {
                    const { artistInfo, trackInfo } = await AudioDBService.getTrackAndArtistInfo(
                        currentTrack.artist,
                        currentTrack.title
                    );

                    // Hide loading indicator
                    loadingIndicator.style.display = 'none';

                    // Populate track details if available
                    if (trackInfo) {
                        populateTrackDetails(trackInfo);
                        trackDetailsSection.style.display = 'block';
                    }

                    // Populate artist info if available
                    if (artistInfo) {
                        populateArtistInfo(artistInfo);
                        artistInfoSection.style.display = 'block';
                    }
                } catch (error) {
                    console.error('Error fetching enhanced track/artist info:', error);
                    loadingIndicator.style.display = 'none';
                }
            }
        }

        // Populate track details section
        function populateTrackDetails(trackInfo) {
            const trackDetailsContent = document.getElementById('trackDetailsContent');
            let html = '';

            if (trackInfo.strGenre) {
                html += `<div class="info-row">
                    <span class="info-label">Genre:</span>
                    <span class="info-value"><span class="info-badge">${trackInfo.strGenre}</span></span>
                </div>`;
            }

            if (trackInfo.strMood) {
                html += `<div class="info-row">
                    <span class="info-label">Mood:</span>
                    <span class="info-value"><span class="info-badge">${trackInfo.strMood}</span></span>
                </div>`;
            }

            if (trackInfo.strDescriptionEN) {
                html += `<div class="info-row" style="flex-direction: column;">
                    <span class="info-label">About this track:</span>
                    <p style="margin-top: 8px; line-height: 1.6;">${trackInfo.strDescriptionEN}</p>
                </div>`;
            }

            if (trackInfo.strMusicVid) {
                html += `<div class="info-row" style="margin-top: 10px;">
                    <a href="${trackInfo.strMusicVid}" target="_blank" rel="noopener noreferrer" class="artist-link-btn">
                        Watch Music Video
                    </a>
                </div>`;
            }

            trackDetailsContent.innerHTML = html || '<p style="color: var(--text-tertiary);">No additional track information available.</p>';
        }

        // Populate artist info section
        function populateArtistInfo(artistInfo) {
            const artistThumbnail = document.getElementById('artistThumbnail');
            const artistInfoContent = document.getElementById('artistInfoContent');

            // Show artist thumbnail if available
            if (artistInfo.strArtistThumb) {
                artistThumbnail.src = artistInfo.strArtistThumb;
                artistThumbnail.style.display = 'block';
            } else {
                artistThumbnail.style.display = 'none';
            }

            let html = '';

            // Artist genre and style
            if (artistInfo.strGenre || artistInfo.strStyle) {
                html += '<div class="info-row" style="flex-direction: column;">';
                if (artistInfo.strGenre) {
                    html += `<span class="info-badge">${artistInfo.strGenre}</span>`;
                }
                if (artistInfo.strStyle) {
                    html += `<span class="info-badge">${artistInfo.strStyle}</span>`;
                }
                if (artistInfo.strMood) {
                    html += `<span class="info-badge">${artistInfo.strMood}</span>`;
                }
                html += '</div>';
            }

            // Artist biography
            if (artistInfo.strBiographyEN) {
                html += `<div class="artist-bio">${artistInfo.strBiographyEN}</div>`;
            }

            // Artist links
            const links = [];
            if (artistInfo.strWebsite) {
                links.push({ url: `https://${artistInfo.strWebsite}`, label: 'Website' });
            }
            if (artistInfo.strFacebook) {
                links.push({ url: `https://${artistInfo.strFacebook}`, label: 'Facebook' });
            }

            if (links.length > 0) {
                html += '<div class="artist-links">';
                links.forEach(link => {
                    html += `<a href="${link.url}" target="_blank" rel="noopener noreferrer" class="artist-link-btn">${link.label}</a>`;
                });
                html += '</div>';
            }

            artistInfoContent.innerHTML = html || '<p style="color: var(--text-tertiary);">No artist information available.</p>';
        }

        // Close now playing modal
        function closeNowPlayingModal() {
            const modal = document.getElementById('nowPlayingModal');
            modal.classList.remove('active');
        }

        // Update Media Session API
        function updateMediaSession(title, artist, album, artworkUrl) {
            if ('mediaSession' in navigator) {
                navigator.mediaSession.metadata = new MediaMetadata({
                    title: title || 'Unknown Track',
                    artist: artist || (currentStation ? currentStation.name : 'Radio Stream'),
                    album: album || '',
                    artwork: artworkUrl ? [
                        { src: artworkUrl, sizes: '600x600', type: 'image/jpeg' }
                    ] : (currentStation && currentStation.icon_url ? [
                        { src: currentStation.icon_url, sizes: '512x512', type: 'image/png' }
                    ] : [])
                });
                // Set playback state to ensure notification updates work when backgrounded
                if (isPlaying && !isPaused) {
                    navigator.mediaSession.playbackState = 'playing';
                }
            }
        }
        
        // Setup Media Session handlers
        function setupMediaSessionHandlers() {
            if ('mediaSession' in navigator) {
                navigator.mediaSession.setActionHandler('play', () => {
                    // Always trigger play/pause button when play is pressed
                    // This handles both starting from stopped and resuming from paused
                    if (!isPlaying || isPaused) {
                        playPauseBtn.click();
                    }
                });
                
                navigator.mediaSession.setActionHandler('pause', () => {
                    if (isPlaying && !isPaused) {
                        playPauseBtn.click();
                    }
                });
                
                navigator.mediaSession.setActionHandler('stop', () => {
                    if (isPlaying || isPaused) {
                        isPaused = false;
                        stopAllPlayers();
                        isPlaying = false;
                        updateStatus('Stopped', 'stopped');
                        updatePlayPauseButton(false);
                    }
                });
                
                navigator.mediaSession.setActionHandler('nexttrack', () => {
                    if (stations.length > 0 && currentStation) {
                        const currentIndex = stations.findIndex(s => s.id === currentStation.id);
                        const nextIndex = (currentIndex + 1) % stations.length;
                        selectStation(stations[nextIndex]);
                        setTimeout(() => playPauseBtn.click(), 500);
                    }
                });
                
                navigator.mediaSession.setActionHandler('previoustrack', () => {
                    if (stations.length > 0 && currentStation) {
                        const currentIndex = stations.findIndex(s => s.id === currentStation.id);
                        const prevIndex = currentIndex > 0 ? currentIndex - 1 : stations.length - 1;
                        selectStation(stations[prevIndex]);
                        setTimeout(() => playPauseBtn.click(), 500);
                    }
                });
            }
        }
        
        // ======================
        // PLAYER CONTROLS
        // ======================
        
        // Helper function to detect if URL is HLS stream
        function isHLSStream(url) {
            return url && (url.includes('.m3u8') || url.includes('m3u8'));
        }
        
        // Helper function to stop all players
        function stopAllPlayers() {
            isPaused = false; // Reset pause state when actually stopping
            if (player) {
                try {
                    player.stop();
                } catch (e) {
                    console.error('Error stopping Icecast player:', e);
                }
                player = null;
            }
            
            if (hlsPlayer) {
                try {
                    hlsPlayer.destroy();
                } catch (e) {
                    console.error('Error destroying HLS player:', e);
                }
                hlsPlayer = null;
            }
            
            if (audioElement) {
                try {
                    audioElement.pause();
                    audioElement.src = '';
                } catch (e) {
                    console.error('Error stopping audio element:', e);
                }
            }
            
            if (simpleAudioPlayer) {
                try {
                    simpleAudioPlayer.pause();
                    simpleAudioPlayer.src = '';
                } catch (e) {
                    console.error('Error stopping simple audio player:', e);
                }
            }

            // Stop metadata-only player to stop background metadata fetching
            stopMetadataOnlyPlayer();

            // Update media session playback state to none
            if ('mediaSession' in navigator) {
                navigator.mediaSession.playbackState = 'none';
            }
        }

        // Helper function to parse ID3 frames from HLS metadata
        function parseID3Frames(data) {
            const frames = {};

            try {
                // Validate input data
                if (!data) {
                    console.warn('parseID3Frames: No data provided');
                    return frames;
                }

                // Convert to ArrayBuffer if needed
                let buffer;
                if (data instanceof ArrayBuffer) {
                    buffer = data;
                } else if (data.buffer instanceof ArrayBuffer) {
                    buffer = data.buffer;
                } else if (ArrayBuffer.isView(data)) {
                    buffer = data.buffer;
                } else {
                    console.warn('parseID3Frames: Invalid data type, expected ArrayBuffer or TypedArray');
                    return frames;
                }

                // ID3 tags in HLS are typically in ID3v2 format
                const view = new DataView(buffer);
                let offset = 0;

                // Check for ID3 header
                if (view.byteLength < 10) return frames;

                const header = String.fromCharCode(view.getUint8(0), view.getUint8(1), view.getUint8(2));
                if (header !== 'ID3') return frames;

                // Skip version and flags
                offset = 10;

                // Parse frames
                while (offset < view.byteLength - 10) {
                    // Get frame ID (4 bytes)
                    const frameId = String.fromCharCode(
                        view.getUint8(offset),
                        view.getUint8(offset + 1),
                        view.getUint8(offset + 2),
                        view.getUint8(offset + 3)
                    );

                    if (frameId === '\0\0\0\0') break;

                    // Get frame size (4 bytes, synchsafe integer)
                    const size = (view.getUint8(offset + 4) << 21) |
                                (view.getUint8(offset + 5) << 14) |
                                (view.getUint8(offset + 6) << 7) |
                                view.getUint8(offset + 7);

                    // Skip frame flags (2 bytes)
                    offset += 10;

                    if (size === 0 || offset + size > view.byteLength) break;

                    // Extract frame data (skip encoding byte)
                    const encoding = view.getUint8(offset);
                    let text = '';

                    try {
                        // Skip encoding byte and extract text
                        const textData = new Uint8Array(view.buffer, offset + 1, size - 1);
                        const decoder = new TextDecoder(encoding === 1 ? 'utf-16' : 'utf-8');
                        text = decoder.decode(textData).replace(/\0/g, '').trim();
                    } catch (e) {
                        console.warn('Error decoding ID3 text:', e);
                    }

                    if (text && (frameId === 'TIT2' || frameId === 'TPE1' || frameId === 'TALB' || frameId === 'TCON')) {
                        frames[frameId] = text;
                        console.log(`ID3 ${frameId}:`, text);
                    }

                    offset += size;
                }
            } catch (error) {
                console.error('Error parsing ID3 frames:', error);
            }

            return frames;
        }

        // Helper function to limit concurrent async operations
        async function limitConcurrency(items, limit, asyncFn) {
            const results = [];
            const executing = [];

            for (const [index, item] of items.entries()) {
                const promise = Promise.resolve().then(() => asyncFn(item, index));
                results.push(promise);

                if (limit <= items.length) {
                    const executing_promise = promise.then(() =>
                        executing.splice(executing.indexOf(executing_promise), 1)
                    );
                    executing.push(executing_promise);

                    if (executing.length >= limit) {
                        await Promise.race(executing);
                    }
                }
            }

            return Promise.all(results);
        }

        // Helper function to play HLS stream
        async function playHLSStream(streamUrl) {
            return new Promise((resolve, reject) => {
                // Handle mixed content: HTTP streams on HTTPS pages
                if (window.location.protocol === 'https:' && streamUrl.startsWith('http://')) {
                    // Try to upgrade to HTTPS first (works for domains with SSL)
                    // But for IP addresses, we'll need CORS proxy (handled in retry logic)
                    const httpsUrl = streamUrl.replace('http://', 'https://');
                    console.log('üîí Attempting to upgrade HTTP stream to HTTPS:', streamUrl, '‚Üí', httpsUrl);
                    console.log('Note: If this fails (e.g., IP address), fallback methods will use CORS proxy');
                    streamUrl = httpsUrl;
                }
                
                
                // Create audio element if it doesn't exist
                if (!audioElement) {
                    audioElement = new Audio();
                    audioElement.crossOrigin = 'anonymous';
                    
                    // Set volume from saved settings
                    const savedVolume = localStorage.getItem('volume');
                    audioElement.volume = savedVolume ? parseFloat(savedVolume) : 0.7;
                    
                    console.log('Created new audio element with volume:', audioElement.volume);
                }
                
                // Stop any existing HLS player
                if (hlsPlayer) {
                    try {
                        hlsPlayer.destroy();
                    } catch (e) {
                        console.warn('Error destroying previous HLS player:', e);
                    }
                    hlsPlayer = null;
                }
                
                if (Hls.isSupported()) {
                    
                    hlsPlayer = new Hls({
                        enableWorker: true,
                        lowLatencyMode: true,
                        backBufferLength: 90,
                        maxBufferLength: 30,
                        maxMaxBufferLength: 60,
                        debug: false
                    });
                    
                    hlsPlayer.on(Hls.Events.MANIFEST_PARSED, () => {
                        audioElement.play()
                            .then(() => {
                                isPlaying = true;
                                updateStatus('Playing (HLS Stream)', 'playing');

                                // Display station icon as artwork for HLS streams, but preserve existing artwork
                                if (!currentTrack.artworkUrl) {
                                    if (currentStation && currentStation.icon_url) {
                                        updateArtwork(`<img src="${escapeHtml(currentStation.icon_url)}" alt="${escapeHtml(currentStation.name)}" class="album-art" onerror="this.onerror=null; this.src='${MUSIC_NOTE_DATA_URI}'">`);
                                    } else {
                                        updateArtwork(`<div class="album-art" style="padding: 40px;">${MUSIC_NOTE_ICON}</div>`);
                                    }
                                }
                                
                                metadataDiv.innerHTML = `
                                    <div class="now-playing-label">NOW PLAYING</div>
                                    <div class="song-title">${escapeHtml(currentStation ? currentStation.name : 'HLS Stream')}</div>
                                    <div class="artist-name">Live Stream</div>
                                `;
                                
                                // Update media session with station info for HLS streams
                                if (currentStation) {
                                    updateMediaSession(
                                        currentStation.name,
                                        'Live Stream',
                                        '',
                                        currentStation.icon_url
                                    );
                                }
                                updatePlayPauseButton(true);
                                playPauseBtn.disabled = false;
                                resolve();
                            })
                            .catch((error) => {
                                console.error('‚ùå HLS play() failed:', error);
                                reject(error);
                            });
                    });
                    
                    hlsPlayer.on(Hls.Events.ERROR, (event, data) => {
                        console.error('HLS Error:', data.type, data.details, data);
                        
                        if (data.fatal) {
                            console.error('‚ùå HLS fatal error:', data.type);
                            
                            // Check for mixed content error
                            if (data.details === 'manifestLoadError' && window.location.protocol === 'https:') {
                                console.error('‚ö†Ô∏è Possible mixed content error - HTTP stream on HTTPS page');
                                reject(new Error('Mixed Content: Cannot load HTTP stream on HTTPS page. Try using an HTTPS stream URL.'));
                                return;
                            }
                            
                            switch (data.type) {
                                case Hls.ErrorTypes.NETWORK_ERROR:
                                    console.error('Network error - attempting to recover...');
                                    hlsPlayer.startLoad();
                                    break;
                                case Hls.ErrorTypes.MEDIA_ERROR:
                                    console.error('Media error - attempting to recover...');
                                    hlsPlayer.recoverMediaError();
                                    break;
                                default:
                                    console.error('Unrecoverable error');
                                    reject(new Error(`HLS Error: ${data.type} - ${data.details}`));
                                    break;
                            }
                        }
                    });
                    
                    hlsPlayer.on(Hls.Events.MEDIA_ATTACHED, () => {
                    });

                    // Listen for ID3 metadata from HLS stream
                    hlsPlayer.on(Hls.Events.FRAG_PARSING_METADATA, (event, data) => {

                        // Check if metadata is in frag.title (iHeartRadio format)
                        if (data.frag && data.frag.title) {
                            try {
                                const titleString = data.frag.title;
                                console.log('üìª Frag title string:', titleString);

                                // Parse key-value pairs from the title string
                                // Format: title="...",artist="...",url="..."
                                const titleMatch = titleString.match(/title="([^"]*)"/);
                                const artistMatch = titleString.match(/artist="([^"]*)"/);
                                const urlMatch = titleString.match(/amgArtworkURL="([^"]*)"/);

                                if (titleMatch || artistMatch) {
                                    const title = titleMatch ? titleMatch[1] : 'Unknown Track';
                                    const artist = artistMatch ? artistMatch[1] : '';
                                    const artworkUrl = urlMatch ? urlMatch[1] : null;


                                    // Update the metadata display
                                    metadataDiv.innerHTML = `
                                        <div class="now-playing-label">NOW PLAYING</div>
                                        <div class="song-title">${escapeHtml(title)}</div>
                                        ${artist ? `<div class="artist-name">${escapeHtml(artist)}</div>` : ''}
                                        <button class="like-btn" id="likeBtn" onclick="toggleLikeTrack()">‚ô°</button>
                                    `;

                                    // Update current track info
                                    currentTrack = {
                                        title: title,
                                        artist: artist,
                                        album: '',
                                        artworkUrl: artworkUrl,
                                        lyrics: null,
                                        lyricsUrl: null,
                                        hasLyrics: false
                                    };

                                    // Update like button
                                    updateLikeButton();

                                    // Fetch album art if not provided in metadata
                                    if (artworkUrl) {
                                        // Use artwork from metadata
                                        const albumArt = document.getElementById('albumArt');
                                        if (albumArt) {
                                            albumArt.src = artworkUrl;
                                            albumArt.style.display = 'block';
                                        }
                                        updateMediaSession(title, artist, '', artworkUrl);
                                    } else {
                                        fetchAlbumArt(title, artist);
                                    }

                                    // Fetch lyrics
                                    fetchLyricsForCurrentTrack();

                                    // Track the song play
                                    addToRecentTracks({
                                        title: title,
                                        artist: artist,
                                        album: '',
                                        artworkUrl: artworkUrl,
                                        station: currentStation ? currentStation.name : 'Unknown Station'
                                    });
                                }
                            } catch (error) {
                                console.error('Error parsing HLS frag.title metadata:', error);
                            }
                        }
                        // Fall back to ID3 frames if frag.title is not available
                        else if (data.samples && data.samples.length > 0) {
                            data.samples.forEach(sample => {
                                try {
                                    // Parse ID3 frames
                                    const frames = parseID3Frames(sample.data);

                                    if (frames.TIT2 || frames.TPE1) {
                                        const title = frames.TIT2 || 'Unknown Track';
                                        const artist = frames.TPE1 || '';
                                        const album = frames.TALB || '';


                                        // Update the metadata display
                                        metadataDiv.innerHTML = `
                                            <div class="now-playing-label">NOW PLAYING</div>
                                            <div class="song-title">${escapeHtml(title)}</div>
                                            ${artist ? `<div class="artist-name">${escapeHtml(artist)}</div>` : ''}
                                            ${album ? `<div class="album-name">${escapeHtml(album)}</div>` : ''}
                                            <button class="like-btn" id="likeBtn" onclick="toggleLikeTrack()">‚ô°</button>
                                        `;

                                        // Update current track info
                                        currentTrack = {
                                            title: title,
                                            artist: artist,
                                            album: album,
                                            artworkUrl: null,
                                            lyrics: null,
                                            lyricsUrl: null,
                                            hasLyrics: false
                                        };

                                        // Update like button
                                        updateLikeButton();

                                        // Fetch album art
                                        fetchAlbumArt(title, artist);

                                        // Fetch lyrics
                                        fetchLyricsForCurrentTrack();

                                        // Update media session
                                        updateMediaSession(title, artist, album, null);

                                        // Track the song play
                                        addToRecentTracks({
                                            title: title,
                                            artist: artist,
                                            album: album,
                                            artworkUrl: null,
                                            station: currentStation ? currentStation.name : 'Unknown Station'
                                        });
                                    }
                                } catch (error) {
                                    console.error('Error parsing HLS ID3 metadata:', error);
                                }
                            });
                        }
                    });

                    hlsPlayer.loadSource(streamUrl);
                    hlsPlayer.attachMedia(audioElement);
                    
                } else if (audioElement.canPlayType('application/vnd.apple.mpegurl')) {
                    // Native HLS support (Safari)
                    audioElement.src = streamUrl;

                    // Listen for metadata tracks (Safari native HLS)
                    audioElement.textTracks.addEventListener('addtrack', (e) => {
                        const track = e.track;
                        if (track.kind === 'metadata') {
                            track.mode = 'hidden';

                            track.addEventListener('cuechange', () => {
                                if (track.activeCues && track.activeCues.length > 0) {
                                    const cue = track.activeCues[0];

                                    if (cue.value) {
                                        try {
                                            // Parse metadata from cue
                                            const value = cue.value;
                                            let title, artist, album;

                                            // Check for common metadata formats
                                            if (value.data) {
                                                const frames = parseID3Frames(value.data);
                                                title = frames.TIT2;
                                                artist = frames.TPE1;
                                                album = frames.TALB;
                                            } else if (value.info) {
                                                // Alternative format
                                                title = value.info;
                                            }

                                            if (title || artist) {

                                                // Update metadata display
                                                metadataDiv.innerHTML = `
                                                    <div class="now-playing-label">NOW PLAYING</div>
                                                    <div class="song-title">${escapeHtml(title || 'Unknown Track')}</div>
                                                    ${artist ? `<div class="artist-name">${escapeHtml(artist)}</div>` : ''}
                                                    ${album ? `<div class="album-name">${escapeHtml(album)}</div>` : ''}
                                                    <button class="like-btn" id="likeBtn" onclick="toggleLikeTrack()">‚ô°</button>
                                                `;

                                                // Update current track
                                                currentTrack = {
                                                    title: title || 'Unknown Track',
                                                    artist: artist || '',
                                                    album: album || '',
                                                    artworkUrl: null,
                                                    lyrics: null,
                                                    lyricsUrl: null,
                                                    hasLyrics: false
                                                };

                                                // Update like button
                                                updateLikeButton();

                                                // Fetch album art
                                                fetchAlbumArt(title || 'Unknown Track', artist || '');

                                                // Fetch lyrics
                                                fetchLyricsForCurrentTrack();

                                                // Update media session
                                                updateMediaSession(title || 'Unknown Track', artist || '', album || '', null);

                                                // Track the song play
                                                addToRecentTracks({
                                                    title: title || 'Unknown Track',
                                                    artist: artist || '',
                                                    album: album || '',
                                                    artworkUrl: null,
                                                    station: currentStation ? currentStation.name : 'Unknown Station'
                                                });
                                            }
                                        } catch (error) {
                                            console.error('Error parsing native HLS metadata:', error);
                                        }
                                    }
                                }
                            });
                        }
                    });

                    audioElement.play()
                        .then(() => {
                            isPlaying = true;
                            updateStatus('Playing (HLS Stream)', 'playing');

                            // Display station icon as artwork for HLS streams, but preserve existing artwork
                            if (!currentTrack.artworkUrl) {
                                if (currentStation && currentStation.icon_url) {
                                    updateArtwork(`<img src="${escapeHtml(currentStation.icon_url)}" alt="${escapeHtml(currentStation.name)}" class="album-art" onerror="this.onerror=null; this.src='${MUSIC_NOTE_DATA_URI}'">`);
                                } else {
                                    updateArtwork(`<div class="album-art" style="padding: 40px;">${MUSIC_NOTE_ICON}</div>`);
                                }
                            }

                            metadataDiv.innerHTML = `
                                <div class="now-playing-label">NOW PLAYING</div>
                                <div class="song-title">${escapeHtml(currentStation ? currentStation.name : 'HLS Stream')}</div>
                                <div class="artist-name">Live Stream</div>
                            `;

                            // Update media session with station info for HLS streams
                            if (currentStation) {
                                updateMediaSession(
                                    currentStation.name,
                                    'Live Stream',
                                    '',
                                    currentStation.icon_url
                                );
                            }
                            updatePlayPauseButton(true);
                            playPauseBtn.disabled = false;
                            resolve();
                        })
                        .catch((error) => {
                            console.error('‚ùå Native HLS play() failed:', error);
                            reject(error);
                        });
                } else {
                    console.error('‚ùå HLS not supported in this browser');
                    reject(new Error('HLS not supported in this browser'));
                }
            });
        }
        
        // Function to update button state
        function updatePlayPauseButton(playing) {
            if (playing) {
                playPauseBtn.classList.remove('btn-play');
                playPauseBtn.classList.add('btn-pause');
                playIcon.style.display = 'none';
                pauseIcon.style.display = 'block';
            } else {
                playPauseBtn.classList.remove('btn-pause');
                playPauseBtn.classList.add('btn-play');
                playIcon.style.display = 'block';
                pauseIcon.style.display = 'none';
            }

            // Update station display cursor based on playing state
            updateStationDisplayCursor();
        }

        // Back button handler
        document.getElementById('backBtn').addEventListener('click', () => {
            navigateBack();
        });

        // Play/Pause button handler
        playPauseBtn.addEventListener('click', async () => {
            // If we're casting, control the Cast media session instead of local playback
            if (castSession) {
                const media = castSession.getMediaSession();
                if (media) {
                    const playerState = media.playerState;

                    if (playerState === 'PLAYING' || playerState === 'BUFFERING') {
                        // Pause the cast
                        media.pause(new chrome.cast.media.PauseRequest(),
                            () => {
                                updatePlayPauseButton(false);
                                updateStatus('Paused (Casting)', 'stopped');
                            },
                            (error) => {
                                console.error('Failed to pause Cast:', error);
                            }
                        );
                    } else if (playerState === 'PAUSED') {
                        // Resume the cast
                        media.play(new chrome.cast.media.PlayRequest(),
                            () => {
                                updatePlayPauseButton(true);
                                updateStatus('Casting...', 'playing');
                            },
                            (error) => {
                                console.error('Failed to resume Cast:', error);
                            }
                        );
                    } else {
                    }
                } else {
                }
                return;
            }
            
            // SIMPLE MODE - Stop instead of pause (radio is live content)
            if (playbackMode === 'simple') {
                // If playing, stop both audio and metadata players
                if (isPlaying && simpleAudioPlayer && !simpleAudioPlayer.paused) {
                    simpleAudioPlayer.pause();
                    simpleAudioPlayer.removeAttribute('src'); // Remove source to fully stop
                    simpleAudioPlayer.load(); // Reset the media element
                    stopMetadataOnlyPlayer(); // Stop metadata player to keep in sync
                    isPlaying = false;
                    isPaused = false; // Not paused, fully stopped
                    updateStatus('Stopped', 'stopped');
                    updatePlayPauseButton(false);
                    // Update media session playback state
                    if ('mediaSession' in navigator) {
                        navigator.mediaSession.playbackState = 'none';
                    }
                    return;
                }

                // If stopped/paused, start fresh from live stream
                if (!isPlaying) {
                    console.log('‚ñ∂Ô∏è Starting fresh playback from live stream');
                    // Fall through to load new stream below
                }
                
                // Start new playback in simple mode
                const rawUrl = currentStation 
                    ? (selectedQuality === 'low' && currentStation.url_low ? currentStation.url_low : 
                       selectedQuality === 'high' && currentStation.url_high ? currentStation.url_high : currentStation.url)
                    : null;
                
                if (!rawUrl) {
                    updateStatus('Please select a station', 'error');
                    return;
                }
                
                // Check if CORS proxy should be used
                const useCorsProxy = document.getElementById('globalCorsProxy').checked;

                // Force CORS proxy for HTTP URLs on HTTPS pages (mixed content fix)
                const needsCorsForMixedContent = window.location.protocol === 'https:' && rawUrl.startsWith('http://');

                const streamUrl = (useCorsProxy || needsCorsForMixedContent)
                    ? `https://corsproxy.io/?${encodeURIComponent(rawUrl)}`
                    : rawUrl;

                if (needsCorsForMixedContent && !useCorsProxy) {
                    console.log('üîí Mixed content detected: forcing CORS proxy for HTTP stream on HTTPS page');
                }
                
                playPauseBtn.disabled = true;
                updateStatus('Connecting...', 'loading');
                displayStationIcon();
                metadataDiv.innerHTML = `
                    <div class="now-playing-label">NOW PLAYING</div>
                    <div class="track-info">
                        <div class="track-title">${escapeHtml(currentStation.name)}</div>
                    </div>
                `;
                
                // Create or update simple audio player
                if (!simpleAudioPlayer) {
                    simpleAudioPlayer = new Audio();
                    simpleAudioPlayer.addEventListener('play', () => {
                        isPlaying = true;
                        updateStatus('Playing', 'playing');
                        updatePlayPauseButton(true);
                        playPauseBtn.disabled = false;
                        // Update media session playback state
                        if ('mediaSession' in navigator) {
                            navigator.mediaSession.playbackState = 'playing';
                        }
                    });
                    simpleAudioPlayer.addEventListener('pause', () => {
                        if (isPlaying) {
                            isPlaying = false;
                            updateStatus('Paused', 'stopped');
                            updatePlayPauseButton(false);
                            // Update media session playback state
                            if ('mediaSession' in navigator) {
                                navigator.mediaSession.playbackState = 'paused';
                            }
                        }
                    });
                    simpleAudioPlayer.addEventListener('error', (e) => {
                        // Ignore errors if we're intentionally reloading
                        if (simplePlayerReloading) {
                            console.log('Ignoring error during reload');
                            return;
                        }
                        
                        console.error('Simple player error:', e);
                        console.error('Audio element error code:', simpleAudioPlayer.error?.code);
                        console.error('Audio element error message:', simpleAudioPlayer.error?.message);
                        
                        let errorMsg = 'Error: Unable to play stream';
                        if (simpleAudioPlayer.error) {
                            switch(simpleAudioPlayer.error.code) {
                                case 1: errorMsg += ' (Aborted)'; break;
                                case 2: errorMsg += ' (Network error)'; break;
                                case 3: errorMsg += ' (Decode error)'; break;
                                case 4: errorMsg += ' (Format not supported)'; break;
                            }
                        }
                        
                        if (useCorsProxy) {
                            errorMsg += '. Try disabling CORS proxy in settings.';
                        } else {
                            errorMsg += '. Try enabling CORS proxy in settings.';
                        }
                        
                        updateStatus(errorMsg, 'error');
                        isPlaying = false;
                        updatePlayPauseButton(false);
                        playPauseBtn.disabled = false;
                    });
                }
                
                // Set reloading flag to suppress errors from old source
                simplePlayerReloading = true;
                
                simpleAudioPlayer.src = streamUrl;
                simpleAudioPlayer.load();
                
                // Clear reloading flag after a short delay
                setTimeout(() => {
                    simplePlayerReloading = false;
                }, 500);
                
                // Update Media Session for notification shade
                updateMediaSession(
                    currentStation.name,
                    '',
                    'Simple Mode - No Metadata',
                    currentStation.icon_url
                );

                // Start metadata-only player in background to get live metadata
                startMetadataOnlyPlayerForSimpleMode(rawUrl);

                // Try to play and handle the promise
                simpleAudioPlayer.play().catch(error => {
                    console.error('Play failed:', error);
                    updateStatus('Error: Unable to play stream', 'error');
                    playPauseBtn.disabled = false;
                    simplePlayerReloading = false;
                });
                return;
            }

            // LIVE MODE - Stop and restart for HLS, pause/resume for regular streams
            // If playing, stop HLS completely (or pause for regular streams)
            if (isPlaying && !isPaused) {
                // For HLS streams, always stop completely to prevent metadata drift
                if (hlsPlayer) {
                    stopAllPlayers();
                    isPlaying = false;
                    updateStatus('Stopped', 'stopped');
                    updatePlayPauseButton(false);
                    // Update media session playback state
                    if ('mediaSession' in navigator) {
                        navigator.mediaSession.playbackState = 'none';
                    }
                    return;
                }

                // For regular Icecast/Shoutcast streams, pause is fine
                isPaused = true;
                if (audioElement) {
                    audioElement.pause();
                } else if (player && player.audioElement) {
                    player.audioElement.pause();
                }
                isPlaying = false;
                updateStatus('Paused', 'stopped');
                updatePlayPauseButton(false);
                // Update media session playback state
                if ('mediaSession' in navigator) {
                    navigator.mediaSession.playbackState = 'paused';
                }
                return;
            }

            // If paused (non-HLS only), resume
            if (isPaused) {
                isPaused = false;
                if (audioElement && audioElement.src) {
                    audioElement.play();
                    isPlaying = true;
                    updateStatus('Playing', 'playing');
                    updatePlayPauseButton(true);
                    // Update media session playback state
                    if ('mediaSession' in navigator) {
                        navigator.mediaSession.playbackState = 'playing';
                    }
                    return;
                } else if (player && player.audioElement && player.audioElement.src) {
                    player.audioElement.play();
                    isPlaying = true;
                    updateStatus('Playing', 'playing');
                    updatePlayPauseButton(true);
                    // Update media session playback state
                    if ('mediaSession' in navigator) {
                        navigator.mediaSession.playbackState = 'playing';
                    }
                    return;
                }
            }
            
            // If not playing and not paused, start playing
            const rawUrl = currentStation 
                ? (selectedQuality === 'low' && currentStation.url_low ? currentStation.url_low : 
                   selectedQuality === 'high' && currentStation.url_high ? currentStation.url_high : currentStation.url)
                : null;
            
            if (!rawUrl) {
                updateStatus('Please select a station', 'error');
                return;
            }
            
            // Stop any existing players (reset pause state)
            isPaused = false;
            stopAllPlayers();

            // Cancel any ongoing connection attempts from previous station
            if (currentPlaybackAbortController) {
                currentPlaybackAbortController.abort();
                console.log('Cancelled previous connection attempts');
            }
            currentPlaybackAbortController = new AbortController();

            playPauseBtn.disabled = true;
            updateStatus('Connecting...', 'loading');

            // Only show loading placeholder if we don't already have artwork for the current track
            if (!currentTrack.artworkUrl) {
                updateArtwork(`<div class="album-art-placeholder">üîÑ</div>`);
            }

            metadataDiv.innerHTML = `
                <div class="now-playing-label">NOW PLAYING</div>
                <div class="no-metadata">Loading stream...</div>
            `;
            
            // Check if it's an HLS stream
            if (isHLSStream(rawUrl)) {
                try {
                    await playHLSStream(rawUrl);
                    return;
                } catch (error) {
                    console.error('HLS playback failed:', error);
                    updateStatus('Error: Unable to play HLS stream', 'error');
                    playPauseBtn.disabled = false;
                    updatePlayPauseButton(false);
                    return;
                }
            }
            
            // Regular Icecast/Shoutcast stream handling
            const useCorsProxy = document.getElementById('globalCorsProxy').checked;

            // Define multiple CORS proxy services for fallback
            // ‚ö†Ô∏è IMPORTANT: Public CORS proxies are unreliable and often blocked/rate-limited
            //
            // For production use, consider:
            // 1. Prefer HTTPS radio streams (use Radio Browser search with üîí badge)
            // 2. Self-host a CORS proxy (see: cors-proxy/README.md in this repository)
            // 3. Deploy your own simple proxy on Cloudflare Workers, Vercel, or similar
            //
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // SELF-HOSTED PROXY SETUP (Recommended for reliability!)
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // This repository includes a ready-to-deploy CORS proxy in /cors-proxy
            //
            // Quick Setup:
            // 1. cd cors-proxy && npm install
            // 2. Deploy to Heroku/Railway/Render (see cors-proxy/README.md)
            // 3. Add your proxy URL below as the FIRST item (highest priority)
            //
            // Example after deploying to https://my-proxy.herokuapp.com:
            // const corsProxies = [
            //     { name: 'my-proxy', url: (streamUrl) => `https://my-proxy.herokuapp.com/${streamUrl}` },
            //     ...rest of proxies below as fallbacks
            // ];
            //
            // NOTE: corsProxies is now defined globally (see line ~962) and shared between
            // the main audio player and metadata player to ensure consistency.
            // Using the global definition here.

            // Prioritize Simple Mode for fastest, most reliable playback
            // Metadata will be fetched separately in the background
            const needsMixedContentFix = window.location.protocol === 'https:' && rawUrl.startsWith('http://');

            // Limit to just 3-4 attempts - if a station doesn't work after the first few tries, it won't work
            let attempts = [
                { url: rawUrl, cors: false, metadata: [], description: 'Simple Mode (Direct)' },
                { url: rawUrl, cors: true, corsProxyIndex: 0, metadata: ['icy', 'ogg'], description: 'CORS Proxy + Full Metadata' },
                { url: rawUrl, cors: false, metadata: ['icy', 'ogg'], description: 'Direct + Full Metadata' }
            ];

            // If mixed content fix is needed, try one alternative CORS proxy as a fallback
            if (needsMixedContentFix && corsProxies.length > 1) {
                attempts.push(
                    { url: rawUrl, cors: true, corsProxyIndex: 1, metadata: ['icy', 'ogg'], description: `${corsProxies[1].name} + Full Metadata` }
                );
            }

            if (!useCorsProxy) {
                // If CORS proxy is disabled, prioritize Simple Mode for fastest playback
                attempts = [
                    { url: rawUrl, cors: false, metadata: [], description: 'Simple Mode (Direct)' },
                    { url: rawUrl, cors: false, metadata: ['icy', 'ogg'], description: 'Direct + Full Metadata' },
                    { url: rawUrl, cors: true, corsProxyIndex: 0, metadata: ['icy', 'ogg'], description: 'CORS Proxy + Full Metadata' }
                ];

                // Even with CORS proxy disabled, try one fallback if mixed content fix is needed
                if (needsMixedContentFix && corsProxies.length > 1) {
                    attempts.push(
                        { url: rawUrl, cors: true, corsProxyIndex: 1, metadata: ['icy', 'ogg'], description: `${corsProxies[1].name} + Full Metadata` }
                    );
                }
            }
            
            let lastError = null;
            
            for (let i = 0; i < attempts.length; i++) {
                const attempt = attempts[i];

                // Check if we should abort (user switched to a different station)
                if (currentPlaybackAbortController.signal.aborted) {
                    console.log('Connection attempts aborted - user switched stations');
                    return;
                }

                // Special handling for Simple Mode attempt
                if (attempt.description.startsWith('Simple Mode')) {
                    console.log(`Attempting connection ${i + 1}/${attempts.length} - ${attempt.description}`);

                    // Update metadata area with current attempt
                    metadataDiv.innerHTML = `
                        <div class="now-playing-label">CONNECTING</div>
                        <div class="track-info">
                            <div class="track-title" style="font-size: 14px;">Attempt ${i + 1} of ${attempts.length}</div>
                            <div class="track-artist" style="font-size: 12px; opacity: 0.8;">${attempt.description}...</div>
                            <div class="track-artist" style="font-size: 11px; opacity: 0.6; margin-top: 4px;">Testing HTML5 audio compatibility</div>
                        </div>
                    `;

                    try {
                        updateStatus(`Attempting ${i + 1}/${attempts.length}: ${attempt.description}`, 'loading');
                        displayStationIcon();

                        // Create HTML5 audio player directly
                        const testAudio = new Audio();

                        // Use CORS proxy for HTTP URLs when on HTTPS page (mixed content fix)
                        let simpleUrl = rawUrl;
                        if (window.location.protocol === 'https:' && rawUrl.startsWith('http://')) {
                            const proxyIndex = attempt.corsProxyIndex !== undefined ? attempt.corsProxyIndex : 0;
                            const proxy = corsProxies[proxyIndex];
                            console.log(`üîí Mixed content detected: using ${proxy.name} for HTTP stream on HTTPS page`);
                            simpleUrl = proxy.url(rawUrl);
                        }

                        testAudio.src = simpleUrl;
                        testAudio.preload = 'auto';
                        
                        // Wait for it to load and play
                        await new Promise((resolve, reject) => {
                            const timeoutTimer = setTimeout(() => {
                                testAudio.pause();
                                testAudio.src = '';
                                reject(new Error('Simple mode timeout'));
                            }, 10000);
                            
                            testAudio.addEventListener('canplay', () => {
                                clearTimeout(timeoutTimer);
                                console.log(`Attempt ${i + 1} succeeded with Simple Mode!`);
                                
                                // Now officially switch to Simple mode
                                playbackMode = 'simple';
                                if (currentModeText) currentModeText.textContent = 'Simple';
                                
                                // Set up the real simple audio player
                                if (simpleAudioPlayer) {
                                    simpleAudioPlayer.pause();
                                }
                                simpleAudioPlayer = testAudio;
                                
                                // Add event listeners
                                simpleAudioPlayer.addEventListener('play', () => {
                                    isPlaying = true;
                                    updateStatus('Playing', 'playing');
                                    updatePlayPauseButton(true);
                                    playPauseBtn.disabled = false;
                                });
                                simpleAudioPlayer.addEventListener('pause', () => {
                                    if (isPlaying) {
                                        isPlaying = false;
                                        updateStatus('Paused', 'stopped');
                                        updatePlayPauseButton(false);
                                    }
                                });
                                simpleAudioPlayer.addEventListener('error', (e) => {
                                    if (simplePlayerReloading) {
                                        console.log('Ignoring error during reload');
                                        return;
                                    }
                                    console.error('Simple player error:', e);
                                    updateStatus('Error: Unable to play stream', 'error');
                                    isPlaying = false;
                                    updatePlayPauseButton(false);
                                    playPauseBtn.disabled = false;
                                });
                                
                                // Start playing
                                simpleAudioPlayer.play().then(() => {
                                    metadataDiv.innerHTML = `
                                        <div class="now-playing-label">NOW PLAYING</div>
                                        <div class="track-info">
                                            <div class="track-title">${escapeHtml(currentStation.name)}</div>
                                            <div class="track-artist" style="font-size: 12px; opacity: 0.6;">Fetching metadata...</div>
                                        </div>
                                    `;
                                    isPlaying = true;
                                    updatePlayPauseButton(true);
                                    playPauseBtn.disabled = false;

                                    // Update Media Session for notification shade
                                    updateMediaSession(
                                        currentStation.name,
                                        '',
                                        'Simple Mode',
                                        currentStation.icon_url
                                    );

                                    // Start metadata-only player in background to get live metadata
                                    startMetadataOnlyPlayerForSimpleMode(rawUrl);

                                    resolve();
                                }).catch(reject);
                            }, { once: true });
                            
                            testAudio.addEventListener('error', (e) => {
                                clearTimeout(timeoutTimer);
                                const audioError = testAudio.error;
                                let errorMsg = 'Simple mode failed to load';

                                if (audioError) {
                                    const errorTypes = {
                                        1: 'MEDIA_ERR_ABORTED - Loading was aborted',
                                        2: 'MEDIA_ERR_NETWORK - Network error occurred',
                                        3: 'MEDIA_ERR_DECODE - Decoding error occurred',
                                        4: 'MEDIA_ERR_SRC_NOT_SUPPORTED - Source not supported'
                                    };
                                    errorMsg += ` (${errorTypes[audioError.code] || 'Unknown error code: ' + audioError.code})`;
                                    if (audioError.message) {
                                        errorMsg += `: ${audioError.message}`;
                                    }
                                }

                                console.error('Simple mode error details:', errorMsg);
                                console.error('Stream URL:', simpleUrl);

                                testAudio.pause();
                                testAudio.src = '';
                                reject(new Error(errorMsg));
                            }, { once: true });
                            
                            // Start loading
                            testAudio.load();
                        });
                        
                        console.log(`Attempt ${i + 1} succeeded!`);
                        return; // Success!
                        
                    } catch (error) {
                        console.error(`Attempt ${i + 1}/${attempts.length} failed:`, error.message);
                        
                        if (i < attempts.length - 1) {
                            continue;
                        }
                        lastError = error;
                    }
                    continue;
                }
                
                // Regular IcecastMetadataPlayer attempts
                // Force CORS proxy for HTTP URLs on HTTPS pages to avoid mixed content errors
                let streamUrl;
                const proxyIndex = attempt.corsProxyIndex !== undefined ? attempt.corsProxyIndex : 0;
                const proxy = corsProxies[proxyIndex];

                if (attempt.cors) {
                    streamUrl = proxy.url(attempt.url);
                    console.log(`Using ${proxy.name} for stream`);
                } else if (window.location.protocol === 'https:' && attempt.url.startsWith('http://')) {
                    console.log(`üîí Mixed content detected: forcing ${proxy.name} for HTTP stream on HTTPS page`);
                    streamUrl = proxy.url(attempt.url);
                } else {
                    streamUrl = attempt.url;
                }
                
                console.log(`Attempting connection ${i + 1}/${attempts.length} - ${attempt.description}`);
                
                // Update metadata area with current attempt
                metadataDiv.innerHTML = `
                    <div class="now-playing-label">CONNECTING</div>
                    <div class="track-info">
                        <div class="track-title" style="font-size: 14px;">Attempt ${i + 1} of ${attempts.length}</div>
                        <div class="track-artist" style="font-size: 12px; opacity: 0.8;">${attempt.description}...</div>
                        <div class="track-artist" style="font-size: 11px; opacity: 0.6; margin-top: 4px;">Please wait, trying to connect</div>
                    </div>
                `;
                
                try {
                    if (i > 0) {
                        updateStatus(`Attempting ${i + 1}/${attempts.length}: ${attempt.description}`, 'loading');
                    }
                    
                    player = new IcecastMetadataPlayer(streamUrl, {
                        metadataTypes: attempt.metadata,
                        enableLogging: false,
                        
                        onMetadata: (metadata) => {
                            displayMetadata(metadata);
                        },
                        
                        onPlay: () => {
                            isPlaying = true;
                            const statusMsg = attempt.metadata.length === 0
                                ? 'Playing (no metadata available)'
                                : 'Playing';
                            updateStatus(statusMsg, 'playing');
                            updatePlayPauseButton(true);
                            playPauseBtn.disabled = false;
                            // Update media session with station info when starting stream
                            if (currentStation && attempt.metadata.length === 0) {
                                updateMediaSession(
                                    currentStation.name,
                                    '',
                                    '',
                                    currentStation.icon_url
                                );
                            }
                            // Start periodic metadata fetching to ensure notification updates even in background
                            startMetadataPlayerRefreshInterval();
                        },
                        
                        onStop: () => {
                            // Don't update UI if we're just pausing
                            if (isPaused) {
                                return;
                            }
                            isPlaying = false;
                            updateStatus('Stopped', 'stopped');
                            playPauseBtn.disabled = false;
                            updatePlayPauseButton(false);
                            displayStationIcon();
                            metadataDiv.innerHTML = `
                                <div class="now-playing-label">NOW PLAYING</div>
                                <div class="no-metadata">Select a station to start streaming</div>
                            `;
                        },
                        
                        onError: (error) => {
                            console.error(`Player error on attempt ${i + 1}:`, error);
                        },
                        
                        bufferLength: 3,
                        retryTimeout: 5,
                        retryDelayRate: 0.5,
                        retryDelayMin: 1,
                        retryDelayMax: 10
                    });
                    
                    // Add timeout to prevent hanging on failed attempts (reduced to 8 seconds)
                    const playPromise = player.play();
                    const timeoutPromise = new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Connection timeout')), 8000)
                    );
                    
                    await Promise.race([playPromise, timeoutPromise]);
                    
                    console.log(`Attempt ${i + 1} succeeded!`);
                    return;
                    
                } catch (error) {
                    console.error(`Attempt ${i + 1}/${attempts.length} failed:`, error.message);
                    lastError = error;
                    
                    if (player) {
                        try {
                            player.stop();
                        } catch (e) {}
                    }
                    
                    if (i < attempts.length - 1) {
                        continue;
                    }
                }
            }
            
            console.error('All connection attempts failed');
            console.log('Fallback check - autoFallbackEnabled:', autoFallbackEnabled, 'hasFallbackAttempted:', hasFallbackAttempted, 'playbackMode:', playbackMode);
            
            // Show final error - all attempts including simple mode have failed
            console.log('All attempts (including Simple mode) failed - showing error');
            isPlaying = false;
            
            metadataDiv.innerHTML = `
                <div class="now-playing-label">CONNECTION FAILED</div>
                <div class="track-info">
                    <div class="track-title" style="font-size: 14px;">All ${attempts.length} attempts failed</div>
                    <div class="track-artist" style="font-size: 12px; opacity: 0.8;">Try a different station or check settings</div>
                </div>
            `;
            
            updateStatus('Error: Unable to connect after all attempts', 'error');
            playPauseBtn.disabled = false;
            updatePlayPauseButton(false);
        });
        
        // Allow Enter key to search
        stationSearch.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && filteredStations.length === 1) {
                selectStation(filteredStations[0]);
            }
        });
        
        // ======================
        // VIEW TOGGLE FUNCTIONS
        // ======================
        
        // Toggle station view mode
        function toggleStationView() {
            stationViewMode = stationViewMode === 'list' ? 'grid' : 'list';
            updateStationViewUI();
            renderStationList();
        }
        
        // Update station view toggle UI
        function updateStationViewUI() {
            if (stationViewMode === 'list') {
                stationViewIcon.textContent = '‚äû';
                stationViewText.textContent = 'Grid';
            } else {
                stationViewIcon.textContent = '‚ò∞';
                stationViewText.textContent = 'List';
            }
        }
        
        // Toggle playlist view mode
        function togglePlaylistView() {
            playlistViewMode = playlistViewMode === 'list' ? 'grid' : 'list';
            updatePlaylistViewUI();
            renderPlaylistsList();
        }
        
        // Update playlist view toggle UI
        function updatePlaylistViewUI() {
            if (playlistViewMode === 'list') {
                playlistViewIcon.textContent = '‚äû';
                playlistViewText.textContent = 'Grid';
            } else {
                playlistViewIcon.textContent = '‚ò∞';
                playlistViewText.textContent = 'List';
            }
        }
        
        // Toggle playlist station view mode (for Most Recent, Most Played, and custom playlists)
        function togglePlaylistStationView() {
            playlistStationViewMode = playlistStationViewMode === 'list' ? 'grid' : 'list';
            updatePlaylistStationViewUI();
            renderPlaylistStations();
        }
        
        // Update playlist station view toggle UI
        function updatePlaylistStationViewUI() {
            if (playlistStationViewMode === 'list') {
                playlistStationViewIcon.textContent = '‚äû';
                playlistStationViewText.textContent = 'Grid';
            } else {
                playlistStationViewIcon.textContent = '‚ò∞';
                playlistStationViewText.textContent = 'List';
            }
        }
        
        // Toggle radio database view mode
        function toggleRadioDatabaseView() {
            radioDatabaseViewMode = radioDatabaseViewMode === 'list' ? 'grid' : 'list';
            updateRadioDatabaseViewUI();
            // Re-render current results if any exist
            const stationItems = radioDatabaseResults.querySelectorAll('.station-item');
            if (stationItems.length > 0) {
                // Apply/remove grid view class
                if (radioDatabaseViewMode === 'grid') {
                    radioDatabaseResults.classList.add('grid-view');
                } else {
                    radioDatabaseResults.classList.remove('grid-view');
                }
            }
            // Save state after view mode change
            saveRadioDatabaseState();
        }

        // Update radio database view toggle UI
        function updateRadioDatabaseViewUI() {
            const radioDatabaseViewIcon = document.getElementById('radioDatabaseViewIcon');
            const radioDatabaseViewText = document.getElementById('radioDatabaseViewText');
            if (radioDatabaseViewMode === 'list') {
                radioDatabaseViewIcon.textContent = '‚äû';
                radioDatabaseViewText.textContent = 'Grid';
            } else {
                radioDatabaseViewIcon.textContent = '‚ò∞';
                radioDatabaseViewText.textContent = 'List';
            }
        }

        // Add event listeners for view toggle buttons
        const radioDatabaseViewToggle = document.getElementById('radioDatabaseViewToggle');
        if (radioDatabaseViewToggle) {
            radioDatabaseViewToggle.addEventListener('click', toggleRadioDatabaseView);
        }

        if (stationViewToggle) {
            stationViewToggle.addEventListener('click', toggleStationView);
        }
        if (playlistViewToggle) {
            playlistViewToggle.addEventListener('click', togglePlaylistView);
        }
        if (playlistStationViewToggle) {
            playlistStationViewToggle.addEventListener('click', togglePlaylistStationView);
        }
        
        // ======================
        // INITIALIZATION
        // ======================

        (async () => {
            console.log('=== INITIALIZATION STARTING ===');
            console.log('Supabase initialized:', !!supabase);

            // Check authentication status
            await checkAuth();

            // Initialize quality modal options
            qualityModal.querySelectorAll('.quality-option-modal[data-quality]').forEach(option => {
                if (option.dataset.quality !== 'standard') {
                    option.classList.add('disabled');
                }
            });

            console.log('About to call loadStations()');

            // Load saved settings from localStorage
            const savedPlaybackMode = localStorage.getItem('playbackMode');
            if (savedPlaybackMode) {
                playbackMode = savedPlaybackMode;
                const currentModeElement = document.getElementById('currentMode');
                if (currentModeElement) currentModeElement.textContent = playbackMode === 'live' ? 'Live' : 'Simple';
            }

            const savedQuality = localStorage.getItem('quality');
            if (savedQuality) {
                quality = savedQuality;
                selectedQuality = savedQuality;
            }

            const savedAutoFallback = localStorage.getItem('autoFallback');
            if (savedAutoFallback !== null) {
                autoFallbackEnabled = savedAutoFallback === 'true';
                const checkbox = document.getElementById('autoFallback');
                if (checkbox) checkbox.checked = autoFallbackEnabled;
            }

            // Load Keep Screen Awake setting
            const savedKeepScreenAwake = localStorage.getItem('keepScreenAwake');
            if (savedKeepScreenAwake === 'true') {
                const checkbox = document.getElementById('keepScreenAwake');
                if (checkbox) {
                    checkbox.checked = true;
                    await requestWakeLock();
                }
            }

            // Load Fullscreen setting
            const savedFullscreen = localStorage.getItem('fullscreenMode');
            if (savedFullscreen === 'true') {
                const checkbox = document.getElementById('fullscreenMode');
                if (checkbox) {
                    checkbox.checked = true;
                    // Note: Fullscreen can only be triggered by user interaction
                    // So we don't automatically enter fullscreen on page load
                }
            }

            // Load stations from Supabase on startup
            loadStations();
            loadPlaylists();

            console.log('loadStations() and loadPlaylists() called');

            // Setup Media Session handlers
            setupMediaSessionHandlers();

            // Setup Page Visibility API to handle background/foreground transitions
            document.addEventListener('visibilitychange', () => {
                if (!document.hidden && isPlaying && !isPaused) {
                    // App became visible and is playing - fetch metadata immediately to update notification
                    fetchMetadataOnce();
                }
            });

            // Set initial station display cursor state
            updateStationDisplayCursor();
        })();

        // Close dropdowns when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.station-menu-btn') && 
                !e.target.closest('.station-dropdown') &&
                !e.target.closest('.playlist-menu-btn') &&
                !e.target.closest('.playlist-dropdown') &&
                !e.target.closest('.filter-btn') &&
                !e.target.closest('.filter-dropdown')) {
                document.querySelectorAll('.station-dropdown, .playlist-dropdown, .filter-dropdown').forEach(dropdown => {
                    dropdown.classList.remove('active');
                });
                // Also close any open submenus
                document.querySelectorAll('.dropdown-submenu').forEach(submenu => {
                    submenu.classList.remove('active');
                });
            }
        });
        })(); // End of IIFE
    </script>

    <!-- Service Worker Registration -->
    <script>
        // Register service worker for PWA functionality
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // Use relative path for GitHub Pages subdirectory support
                navigator.serviceWorker.register('./sw.js')
                    .then((registration) => {
                        console.log('ServiceWorker registered:', registration.scope);
                        
                        // Listen for messages from the service worker
                        navigator.serviceWorker.addEventListener('message', (event) => {
                            if (event.data && event.data.type === 'CACHE_CLEARED') {
                                console.log('Service worker cache cleared successfully');
                            }
                        });
                        
                        // Check for updates
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    // New service worker available, prompt user to refresh
                                    if (confirm('New version available! Reload to update?')) {
                                        newWorker.postMessage({ type: 'SKIP_WAITING' });
                                        window.location.reload();
                                    }
                                }
                            });
                        });
                    })
                    .catch((error) => {
                        console.log('ServiceWorker registration failed:', error);
                    });
                
                // Handle service worker updates
                let refreshing;
                navigator.serviceWorker.addEventListener('controllerchange', () => {
                    if (refreshing) return;
                    refreshing = true;
                    window.location.reload();
                });
            });
        }
        
        // Install prompt handling
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            // Prevent the mini-infobar from appearing
            e.preventDefault();
            deferredPrompt = e;
            
            // Optionally, show an install button
            console.log('App can be installed');
        });
        
        window.addEventListener('appinstalled', () => {
            console.log('PWA was installed');
            deferredPrompt = null;
        });
    </script>
</body>
</html>
