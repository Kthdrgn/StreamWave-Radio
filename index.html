<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Stream radio stations with live metadata and album art">
    <meta name="theme-color" content="#667eea">
    <title>StreamWave Radio</title>
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    
    <!-- iOS specific tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Radio Player">
    <link rel="apple-touch-icon" href="icons/icon-192x192.png">
    
    <!-- Favicon -->
    <link rel="icon" type="image/png" sizes="32x32" href="icons/icon-192x192.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/icon-192x192.png">
    
    <!-- CACHE CONTROL: Prevent aggressive caching of API data -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    
    <!-- Load the icecast-metadata-player library from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/icecast-metadata-player@1.17.13/build/icecast-metadata-player-1.17.13.main.min.js"></script>
    
    <!-- Google Cast SDK -->
    <script src="https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1"></script>
    
    <!-- Load HLS.js for m3u8 stream support -->
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    
    <!-- Load Supabase client library -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <!-- Load authentication module -->
    <script src="radio-auth.js"></script>

    <!-- Modular CSS -->
    <link rel="stylesheet" href="css/styles.css">
    
</head>
<body>
    <div class="player-container">
        <!-- LEFT COLUMN: Artwork (only visible in landscape mode) -->
        <div class="tv-left-column">
            <div class="artwork-container" id="artworkContainer">
                <img src="icons/icon-512x512.png" alt="StreamWave Radio" class="album-art" style="padding: 40px; opacity: 0.5;">
            </div>
        </div>

        <!-- RIGHT COLUMN: Everything else -->
        <div class="tv-right-column">
            <!-- Hamburger Menu Icon (above artwork) -->
            <div class="hamburger-menu-wrapper">
                <div class="hamburger-menu-container">
                    <button id="overviewBtn" class="hamburger-btn overview-btn" title="Overview">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <rect x="3" y="3" width="8" height="8" rx="1.5" stroke-width="2" fill="none"/>
                            <rect x="13" y="3" width="8" height="8" rx="1.5" stroke-width="2" fill="none"/>
                            <rect x="3" y="13" width="8" height="8" rx="1.5" stroke-width="2" fill="none"/>
                            <rect x="13" y="13" width="8" height="8" rx="1.5" stroke-width="2" fill="none"/>
                        </svg>
                    </button>
                    <button id="hamburgerMenuBtn" class="hamburger-btn" title="Menu">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M4 6H20M4 12H20M4 18H20" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                    </button>
                </div>
            </div>

            <!-- Album artwork (visible in portrait mode) -->
            <div class="artwork-container portrait-artwork" id="artworkContainerPortrait">
                <img src="icons/icon-512x512.png" alt="StreamWave Radio" class="album-art" style="padding: 40px; opacity: 0.5;">
            </div>

            <!-- Metadata display -->
            <div class="metadata-section" id="metadataSection">
                <div class="now-playing-label">NOW PLAYING</div>
                <div class="no-metadata">Select a station to start streaming</div>
            </div>

            <!-- Player controls -->
            <div class="controls">
                <div class="controls-buttons">
                    <button id="playPauseBtn" class="control-icon-btn btn-play" disabled>
                        <svg class="play-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M16.6582 9.28638C18.098 10.1862 18.8178 10.6361 19.0647 11.2122C19.2803 11.7152 19.2803 12.2847 19.0647 12.7878C18.8178 13.3638 18.098 13.8137 16.6582 14.7136L9.896 18.94C8.29805 19.9387 7.49907 20.4381 6.83973 20.385C6.26501 20.3388 5.73818 20.0469 5.3944 19.584C5 19.053 5 18.1108 5 16.2264V7.77357C5 5.88919 5 4.94701 5.3944 4.41598C5.73818 3.9531 6.26501 3.66111 6.83973 3.6149C7.49907 3.5619 8.29805 4.06126 9.896 5.05998L16.6582 9.28638Z" stroke-width="2" stroke-linejoin="round"/>
                        </svg>
                        <svg class="pause-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="display: none;">
                            <path d="M2 12C2 7.28595 2 4.92893 3.46447 3.46447C4.92893 2 7.28595 2 12 2C16.714 2 19.0711 2 20.5355 3.46447C22 4.92893 22 7.28595 22 12C22 16.714 22 19.0711 20.5355 20.5355C19.0711 22 16.714 22 12 22C7.28595 22 4.92893 22 3.46447 20.5355C2 19.0711 2 16.714 2 12Z" stroke-width="1.5"/>
                        </svg>
                    </button>
                </div>
                <!-- Playback mode button commented out - handled automatically -->
                <!-- <button id="playbackModeBtn" class="quality-btn" title="Toggle playback mode">
                    <span id="currentMode">Live</span>
                    <span style="font-size: 10px;">‚ñº</span>
                </button> -->
                <!-- Quality button removed - now accessible via Station Info modal -->
            </div>

            <!-- Status indicator -->
            <div class="status-indicator">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">Not connected</span>
            </div>

            <!-- Currently playing station display -->
            <div id="stationDisplay" class="station-display" style="display: flex;">
                <img id="stationDisplayIcon" class="station-display-icon" src="icons/icon-512x512.png" alt="StreamWave Radio" style="display: block;">
                <div class="station-display-info">
                    <div id="stationDisplayName" class="station-display-name">StreamWave Radio</div>
                    <div id="stationDisplayDetails" class="station-display-details" style="display: block;">Select a station to begin</div>
                </div>
                <div class="station-display-change">BROWSE</div>
            </div>
        </div><!-- Close tv-right-column -->
    </div><!-- Close player-container -->
    
    <!-- Settings Modal -->
    <div id="settingsModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Settings</h2>
                <button class="modal-close" id="closeSettingsModal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="settings-content">
                    <div class="setting-item">
                        <label class="setting-label">Theme</label>
                        <div class="theme-toggle-container">
                            <button class="theme-toggle-btn" id="themeToggle">
                                <span class="theme-option" data-theme="dark">
                                    <span class="theme-icon">üåô</span>
                                    <span class="theme-name">Dark</span>
                                </span>
                                <span class="theme-option" data-theme="light">
                                    <span class="theme-icon">‚òÄÔ∏è</span>
                                    <span class="theme-name">Light</span>
                                </span>
                                <span class="theme-slider"></span>
                            </button>
                        </div>
                        <div class="setting-description">
                            Switch between dark and light theme.
                        </div>
                        <button class="reset-theme-btn" id="resetThemeBtn" style="display: none;">
                            üîÑ Reset to System Theme
                        </button>
                    </div>

                    <div class="setting-item">
                        <label class="setting-label">Layout</label>
                        <div class="layout-toggle-container">
                            <button class="layout-toggle-btn" id="layoutToggle">
                                <span class="layout-option" data-layout="portrait">
                                    <span class="layout-icon">üì±</span>
                                    <span class="layout-name">Portrait</span>
                                </span>
                                <span class="layout-option" data-layout="landscape">
                                    <span class="layout-icon">üñ•Ô∏è</span>
                                    <span class="layout-name">Landscape</span>
                                </span>
                                <span class="layout-slider"></span>
                            </button>
                        </div>
                        <div class="setting-description">
                            Switch between portrait and landscape layout (large artwork on left).
                        </div>
                    </div>

                    <div class="setting-item">
                        <label class="setting-label">CORS Proxy</label>
                        <div class="form-checkbox">
                            <input type="checkbox" id="globalCorsProxy" checked>
                            <label for="globalCorsProxy" style="cursor: pointer;">Use CORS Proxy</label>
                        </div>
                        <div class="setting-description">
                            Enable this if streams fail to load. Uses a proxy to bypass CORS restrictions.
                        </div>
                    </div>

                    <div class="setting-item">
                        <label class="setting-label">Auto-Fallback Mode</label>
                        <div class="form-checkbox">
                            <input type="checkbox" id="autoFallback" checked>
                            <label for="autoFallback" style="cursor: pointer;">Auto-switch to Simple Mode if Live fails</label>
                        </div>
                        <div class="setting-description">
                            Automatically try Simple Mode (without metadata) if Live Mode fails to connect.
                        </div>
                    </div>

                    <div class="setting-item">
                        <label class="setting-label">Album Artwork</label>
                        <div class="form-checkbox">
                            <input type="checkbox" id="useItunesApi" checked>
                            <label for="useItunesApi" style="cursor: pointer;">Use iTunes API for Artwork</label>
                        </div>
                        <div class="setting-description">
                            Automatically fetch album artwork from iTunes when available.
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Overview/Home Modal -->
    <div id="overviewModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 900px;">
            <div class="modal-header">
                <h2 class="modal-title">StreamWave Radio</h2>
                <button class="modal-close" id="closeOverviewModal">&times;</button>
            </div>
            <div class="modal-body">
                <!-- Playlists Carousel -->
                <div class="carousel-section">
                    <h3 class="carousel-title">Your Playlists</h3>
                    <div class="carousel-container">
                        <button class="carousel-btn carousel-prev" id="playlistsPrev">‚Äπ</button>
                        <div class="carousel-track" id="playlistsTrack"></div>
                        <button class="carousel-btn carousel-next" id="playlistsNext">‚Ä∫</button>
                    </div>
                </div>

                <!-- Most Recent Stations Carousel -->
                <div class="carousel-section">
                    <h3 class="carousel-title">Most Recent Stations</h3>
                    <div class="carousel-container">
                        <button class="carousel-btn carousel-prev" id="recentPrev">‚Äπ</button>
                        <div class="carousel-track" id="recentTrack"></div>
                        <button class="carousel-btn carousel-next" id="recentNext">‚Ä∫</button>
                    </div>
                </div>

                <!-- Most Played Stations List -->
                <div class="carousel-section">
                    <h3 class="carousel-title">Most Played Stations</h3>
                    <div class="stations-list" id="playedStationsList"></div>
                </div>

                <!-- Explore Section -->
                <div id="exploreSection" style="display: none;">
                    <!-- Explore Header -->
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px; margin-top: 10px;">
                        <h2 style="font-size: 24px; font-weight: 700; color: var(--text-primary); margin: 0;">Explore new stations</h2>
                        <button id="playRandomStationBtn" class="btn" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 10px 20px; font-size: 14px; font-weight: 600; border: none; border-radius: 8px; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);">
                            üé≤ Play Random Station
                        </button>
                    </div>

                    <!-- Because You Listened Carousel -->
                    <div class="carousel-section" id="becauseListenedSection" style="display: none;">
                        <h3 class="carousel-title" id="becauseListenedTitle">Because you listened to...</h3>
                        <div class="carousel-container">
                            <button class="carousel-btn carousel-prev" id="becauseListenedPrev">‚Äπ</button>
                            <div class="carousel-track" id="becauseListenedTrack"></div>
                            <button class="carousel-btn carousel-next" id="becauseListenedNext">‚Ä∫</button>
                        </div>
                    </div>

                    <!-- Because You Like Carousel -->
                    <div class="carousel-section" id="becauseLikeSection" style="display: none;">
                        <h3 class="carousel-title" id="becauseLikeTitle">Because you like...</h3>
                        <div class="carousel-container">
                            <button class="carousel-btn carousel-prev" id="becauseLikePrev">‚Äπ</button>
                            <div class="carousel-track" id="becauseLikeTrack"></div>
                            <button class="carousel-btn carousel-next" id="becauseLikeNext">‚Ä∫</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Quality Modal -->
    <div id="qualityModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 350px;">
            <div class="modal-header">
                <h2 class="modal-title">Stream Quality</h2>
                <button class="modal-close" id="closeQualityModal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="quality-options-modal">
                    <div class="quality-option-modal" data-quality="low">
                        <div class="quality-option-main">
                            <span class="quality-option-icon">üîâ</span>
                            <span class="quality-option-name">Low Quality</span>
                        </div>
                        <div class="quality-option-desc">Best for slower connections</div>
                    </div>
                    <div class="quality-option-modal selected" data-quality="standard">
                        <div class="quality-option-main">
                            <span class="quality-option-icon">üîä</span>
                            <span class="quality-option-name">Standard Quality</span>
                        </div>
                        <div class="quality-option-desc">Balanced quality and bandwidth</div>
                    </div>
                    <div class="quality-option-modal" data-quality="high">
                        <div class="quality-option-main">
                            <span class="quality-option-icon">üìª</span>
                            <span class="quality-option-name">High Quality</span>
                        </div>
                        <div class="quality-option-desc">Best audio quality (requires fast connection)</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Playback Mode Modal -->
    <div id="playbackModeModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <h2 class="modal-title">Playback Mode</h2>
                <button class="modal-close" id="closePlaybackModeModal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="quality-options-modal">
                    <div class="quality-option-modal selected" data-mode="live">
                        <div class="quality-option-main">
                            <span class="quality-option-icon">üì°</span>
                            <span class="quality-option-name">Live Mode</span>
                        </div>
                        <div class="quality-option-desc">Real-time metadata & album art. No pause/resume.</div>
                    </div>
                    <div class="quality-option-modal" data-mode="simple">
                        <div class="quality-option-main">
                            <span class="quality-option-icon">‚ñ∂Ô∏è</span>
                            <span class="quality-option-name">Simple Mode</span>
                        </div>
                        <div class="quality-option-desc">Stop/restart playback (live stream). No metadata updates. Works with more streams.</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Hamburger Menu Modal -->
    <div id="hamburgerMenuModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 350px;">
            <div class="modal-header">
                <h2 class="modal-title">Menu</h2>
                <button class="modal-close" id="closeHamburgerMenuModal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="menu-options">
                    <!-- Browse Stations Button -->
                    <button class="menu-option-btn" id="browseMenuBtn">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M11 6C13.7614 6 16 8.23858 16 11M16.6588 16.6549L21 21M19 11C19 15.4183 15.4183 19 11 19C6.58172 19 3 15.4183 3 11C3 6.58172 6.58172 3 11 3C15.4183 3 19 6.58172 19 11Z" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                        <span>Curated Stations</span>
                    </button>

                    <!-- Radio Database Button -->
                    <button class="menu-option-btn" id="radioDatabaseBtn">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22Z" stroke-width="2"/>
                            <path d="M8 12C8 9.79086 9.79086 8 12 8C14.2091 8 16 9.79086 16 12C16 14.2091 14.2091 16 12 16C9.79086 16 8 14.2091 8 12Z" stroke-width="2"/>
                            <path d="M12 15L12 19" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                        <span>Radio Browser Database</span>
                    </button>

                    <!-- My Playlists Button -->
                    <button class="menu-option-btn" id="viewPlaylistsBtn">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M8 6H21M8 12H21M8 18H21M3 6H3.01M3 12H3.01M3 18H3.01" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                        <span>My Playlists</span>
                    </button>

                    <!-- Add Playlist Button -->
                    <button class="menu-option-btn" id="createPlaylistMenuBtn">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 5V19M5 12H19" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                        <span>Add Playlist</span>
                    </button>

                    <!-- Divider -->
                    <div class="menu-divider"></div>

                    <button class="menu-option-btn" id="settingsMenuBtn">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="12" cy="12" r="3" stroke-width="1.5"/>
                            <path opacity="0.5" d="M13.7654 2.15224C13.3978 2 12.9319 2 12 2C11.0681 2 10.6022 2 10.2346 2.15224C9.74457 2.35523 9.35522 2.74458 9.15223 3.23463C9.05957 3.45834 9.0233 3.7185 9.00911 4.09799C8.98826 4.65568 8.70226 5.17189 8.21894 5.45093C7.73564 5.72996 7.14559 5.71954 6.65219 5.45876C6.31645 5.2813 6.07301 5.18262 5.83294 5.15102C5.30704 5.08178 4.77518 5.22429 4.35436 5.5472C4.03874 5.78938 3.80577 6.1929 3.33983 6.99993C2.87389 7.80697 2.64092 8.21048 2.58899 8.60491C2.51976 9.1308 2.66227 9.66266 2.98518 10.0835C3.13256 10.2756 3.3397 10.437 3.66119 10.639C4.1338 10.936 4.43789 11.4419 4.43786 12C4.43783 12.5581 4.13375 13.0639 3.66118 13.3608C3.33965 13.5629 3.13248 13.7244 2.98508 13.9165C2.66217 14.3373 2.51966 14.8691 2.5889 15.395C2.64082 15.7894 2.87379 16.193 3.33973 17C3.80568 17.807 4.03865 18.2106 4.35426 18.4527C4.77508 18.7756 5.30694 18.9181 5.83284 18.8489C6.07289 18.8173 6.31632 18.7186 6.65204 18.5412C7.14547 18.2804 7.73556 18.27 8.2189 18.549C8.70224 18.8281 8.98826 19.3443 9.00911 19.9021C9.02331 20.2815 9.05957 20.5417 9.15223 20.7654C9.35522 21.2554 9.74457 21.6448 10.2346 21.8478C10.6022 22 11.0681 22 12 22C12.9319 22 13.3978 22 13.7654 21.8478C14.2554 21.6448 14.6448 21.2554 14.8477 20.7654C14.9404 20.5417 14.9767 20.2815 14.9909 19.902C15.0117 19.3443 15.2977 18.8281 15.781 18.549C16.2643 18.2699 16.8544 18.2804 17.3479 18.5412C17.6836 18.7186 17.927 18.8172 18.167 18.8488C18.6929 18.9181 19.2248 18.7756 19.6456 18.4527C19.9612 18.2105 20.1942 17.807 20.6601 16.9999C21.1261 16.1929 21.3591 15.7894 21.411 15.395C21.4802 14.8691 21.3377 14.3372 21.0148 13.9164C20.8674 13.7243 20.6602 13.5628 20.3387 13.3608C19.8662 13.0639 19.5621 12.558 19.5621 11.9999C19.5621 11.4418 19.8662 10.9361 20.3387 10.6392C20.6603 10.4371 20.8675 10.2757 21.0149 10.0835C21.3378 9.66273 21.4803 9.13087 21.4111 8.60497C21.3592 8.21055 21.1262 7.80703 20.6602 7C20.1943 6.19297 19.9613 5.78945 19.6457 5.54727C19.2249 5.22436 18.693 5.08185 18.1671 5.15109C17.9271 5.18269 17.6837 5.28136 17.3479 5.4588C16.8545 5.71959 16.2644 5.73002 15.7811 5.45096C15.2977 5.17191 15.0117 4.65566 14.9909 4.09794C14.9767 3.71848 14.9404 3.45833 14.8477 3.23463C14.6448 2.74458 14.2554 2.35523 13.7654 2.15224Z" stroke-width="1.5"/>
                        </svg>
                        <span>Settings</span>
                    </button>

                    <!-- Add Station Button -->
                    <button class="menu-option-btn" id="addStationBtn">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 5V19M5 12H19" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                        <span>Add Station</span>
                    </button>

                    <!-- Auth Button -->
                    <button class="menu-option-btn" id="authBtn">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="authIcon">
                            <path d="M16 7C16 9.20914 14.2091 11 12 11C9.79086 11 8 9.20914 8 7C8 4.79086 9.79086 3 12 3C14.2091 3 16 4.79086 16 7Z" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M12 14C8.13401 14 5 17.134 5 21H19C19 17.134 15.866 14 12 14Z" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                        <span id="authBtnText">Sign In</span>
                    </button>
                    <!-- Chromecast button temporarily disabled - needs styling work -->
                    <!-- <google-cast-launcher id="castButton" class="menu-option-btn cast-menu-btn" title="Cast to Chromecast">
                        <span>Chromecast</span>
                    </google-cast-launcher> -->
                </div>
            </div>
        </div>
    </div>

    <!-- Liked Tracks Modal -->
    <div id="likedTracksModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Liked Tracks</h2>
                <button class="modal-close" id="closeLikedTracksModal">&times;</button>
            </div>
            <div class="modal-body">
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button class="clear-all-likes-btn" id="clearAllLikesBtn" style="display: none;">
                        Clear All
                    </button>
                    <button class="copy-all-btn" id="copyAllLikedBtn" style="display: none;">
                        <svg width="16" height="16" viewBox="0 0 256 256" style="vertical-align: middle; margin-right: 6px;">
                            <path fill="currentColor" d="M216 32H88a16 16 0 0 0-16 16v40H40a16 16 0 0 0-16 16v120a16 16 0 0 0 16 16h128a16 16 0 0 0 16-16v-40h32a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16zm-48 192H40V104h128zm48-48h-32V104a16 16 0 0 0-16-16H88V48h128z"/>
                        </svg>
                        Copy
                    </button>
                    <button class="copy-all-btn" id="downloadLikedBtn" style="display: none;">
                        <svg width="16" height="16" viewBox="0 0 256 256" style="vertical-align: middle; margin-right: 6px;">
                            <path fill="currentColor" d="M208 144a15.78 15.78 0 0 1 10.42 4L234 163.6a16 16 0 0 1 0 24.79l-15.58 15.59A15.78 15.78 0 0 1 208 208h-48v16a8 8 0 0 1-8 8H40a8 8 0 0 1-8-8v-16H8a8 8 0 0 1 0-16h24v-64H8a8 8 0 0 1 0-16h24V48a8 8 0 0 1 8-8h112a8 8 0 0 1 8 8v64h48zm-16 48h16v-32h-16zm-16-112a8 8 0 0 0-8-8h-64a8 8 0 0 0 0 16h64a8 8 0 0 0 8-8zm0 48v-32H48v32zm0 16H48v32h128zm0 48v-16H48v16zm32-32h16l-16-16z"/>
                        </svg>
                        Download
                    </button>
                </div>
                <div class="liked-tracks-list" id="likedTracksList">
                    <div class="empty-state">
                        <div class="empty-state-icon">‚ô°</div>
                        <div class="empty-state-text">No liked tracks yet. Like a track while listening to save it here!</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Recent Tracks Modal -->
    <div id="recentTracksModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Recently Played Tracks</h2>
                <button class="modal-close" id="closeRecentTracksModal">&times;</button>
            </div>
            <div class="modal-body">
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button class="clear-all-likes-btn" id="clearRecentTracksBtn" style="display: none;">
                        Clear All
                    </button>
                    <button class="copy-all-btn" id="copyAllRecentBtn" style="display: none;">
                        <svg width="16" height="16" viewBox="0 0 256 256" style="vertical-align: middle; margin-right: 6px;">
                            <path fill="currentColor" d="M216 32H88a16 16 0 0 0-16 16v40H40a16 16 0 0 0-16 16v120a16 16 0 0 0 16 16h128a16 16 0 0 0 16-16v-40h32a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16zm-48 192H40V104h128zm48-48h-32V104a16 16 0 0 0-16-16H88V48h128z"/>
                        </svg>
                        Copy
                    </button>
                    <button class="copy-all-btn" id="downloadRecentBtn" style="display: none;">
                        <svg width="16" height="16" viewBox="0 0 256 256" style="vertical-align: middle; margin-right: 6px;">
                            <path fill="currentColor" d="M208 144a15.78 15.78 0 0 1 10.42 4L234 163.6a16 16 0 0 1 0 24.79l-15.58 15.59A15.78 15.78 0 0 1 208 208h-48v16a8 8 0 0 1-8 8H40a8 8 0 0 1-8-8v-16H8a8 8 0 0 1 0-16h24v-64H8a8 8 0 0 1 0-16h24V48a8 8 0 0 1 8-8h112a8 8 0 0 1 8 8v64h48zm-16 48h16v-32h-16zm-16-112a8 8 0 0 0-8-8h-64a8 8 0 0 0 0 16h64a8 8 0 0 0 8-8zm0 48v-32H48v32zm0 16H48v32h128zm0 48v-16H48v16zm32-32h16l-16-16z"/>
                        </svg>
                        Download
                    </button>
                </div>
                <div class="liked-tracks-list" id="recentTracksList">
                    <div class="empty-state">
                        <div class="empty-state-icon">üïê</div>
                        <div class="empty-state-text">No recent tracks yet. Start listening to see your recently played tracks here!</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Lyrics Modal -->
    <div id="lyricsModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title" id="lyricsModalTitle">Lyrics</h2>
                <button class="modal-close" id="closeLyricsModal">&times;</button>
            </div>
            <div class="modal-body">
                <div id="lyricsContent" class="lyrics-content">
                    <div class="lyrics-loading">Loading lyrics...</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Now Playing Details Modal -->
    <div id="nowPlayingModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Now Playing</h2>
                <button class="modal-close" id="closeNowPlayingModal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="now-playing-details">
                    <!-- Track Info -->
                    <div class="modal-track-info">
                        <div class="modal-song-title" id="modalSongTitle">-</div>
                        <div class="modal-artist-name" id="modalArtistName">-</div>
                        <div class="modal-album-name" id="modalAlbumName">-</div>
                    </div>

                    <!-- Action Buttons -->
                    <div class="track-actions">
                        <button class="track-action-btn" id="modalLyricsBtn" onclick="showLyricsModal()">
                            <span class="action-icon">‚ô™</span>
                            <div class="action-text">
                                <div class="action-label">Lyrics</div>
                                <div class="action-description">View song lyrics</div>
                            </div>
                        </button>

                        <button class="track-action-btn" id="modalLikeBtn" onclick="toggleLikeTrack()">
                            <span class="action-icon">‚ô°</span>
                            <div class="action-text">
                                <div class="action-label">Like Track</div>
                                <div class="action-description">Save to your favorites</div>
                            </div>
                        </button>

                        <button class="track-action-btn" id="modalViewLikedTracksBtn">
                            <span class="action-icon">‚ô•</span>
                            <div class="action-text">
                                <div class="action-label">Liked Tracks</div>
                                <div class="action-description">View all your favorites</div>
                            </div>
                        </button>

                        <button class="track-action-btn" id="modalViewRecentTracksBtn">
                            <span class="action-icon">üïê</span>
                            <div class="action-text">
                                <div class="action-label">Recently Played</div>
                                <div class="action-description">View playback history</div>
                            </div>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Station Info Modal -->
    <div id="stationInfoModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Station Information</h2>
                <button class="modal-close" id="closeStationInfoModal">&times;</button>
            </div>
            <div class="modal-body">
                <!-- Add to Playlist Button -->
                <button id="addCurrentStationToPlaylistBtn" class="menu-option-btn" style="margin-bottom: 12px;">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path d="M12 5V19M5 12H19" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    <span>Add station to playlist</span>
                </button>

                <!-- Select Quality Button -->
                <button id="selectQualityBtn" class="menu-option-btn" style="margin-bottom: 12px;">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path d="M3 7V17M7 4V20M11 9V15M15 6V18M19 10V14" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    <span>Select Quality</span>
                </button>

                <!-- Station info will go here -->
            </div>
        </div>
    </div>

    <!-- Playlists Modal -->
    <div id="playlistsModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">My Playlists</h2>
                <button class="modal-close" id="closePlaylistsModal">&times;</button>
            </div>
            <div class="modal-body">
                <!-- Playlists Section -->
                <div class="playlists-section" id="playlistsSection">
                    <div class="section-header">
                        <h3 class="section-title">Playlists</h3>
                        <div style="display: flex; gap: 10px;">
                            <button class="view-toggle-btn" id="playlistViewToggle">
                                <span id="playlistViewIcon">‚äû</span>
                                <span id="playlistViewText">Grid</span>
                            </button>
                            <button class="create-playlist-btn" id="createPlaylistBtn">
                                + New Playlist
                            </button>
                        </div>
                    </div>
                    <div class="playlists-list" id="playlistsList"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Browse Stations Modal -->
    <div id="browseStationsModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Curated Stations</h2>
                <button class="modal-close" id="closeBrowseStationsModal">&times;</button>
            </div>
            <div class="modal-body">
                <!-- Search -->
                <div class="search-controls">
                    <div class="search-input-container">
                        <input 
                            type="text" 
                            id="stationSearch" 
                            class="search-input" 
                            placeholder="Search stations..."
                        >
                        <button class="clear-search-btn" id="clearSearchBtn" style="display: none;" title="Clear search and filters">
                            ‚úï
                        </button>
                    </div>
                </div>
                
                <!-- Filter Controls -->
                <div class="filter-controls">
                    <div class="filter-container">
                        <button class="filter-btn" id="genreBtn">
                            <span class="filter-btn-label" id="genreLabel">All Genres</span>
                            <span>‚ñº</span>
                        </button>
                        <div class="filter-dropdown" id="genreDropdown">
                            <div class="filter-option active" data-genre="">
                                <span class="filter-option-icon">üéµ</span>
                                <span>All Genres</span>
                            </div>
                        </div>
                    </div>
                    <div class="filter-container">
                        <button class="filter-btn" id="sortBtn">
                            <span class="filter-btn-label" id="sortLabel">Name (A-Z)</span>
                            <span>‚ñº</span>
                        </button>
                        <div class="filter-dropdown" id="sortDropdown">
                            <div class="filter-option active" data-sort="name-asc">
                                <span class="filter-option-icon">üî§</span>
                                <span>Name (A-Z)</span>
                            </div>
                            <div class="filter-option" data-sort="name-desc">
                                <span class="filter-option-icon">üî§</span>
                                <span>Name (Z-A)</span>
                            </div>
                            <div class="filter-option" data-sort="most-played">
                                <span class="filter-option-icon">üî•</span>
                                <span>Most Played</span>
                            </div>
                            <div class="filter-option" data-sort="recent">
                                <span class="filter-option-icon">üïê</span>
                                <span>Recently Played</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Stations Section -->
                <div class="section-header">
                    <h3 class="section-title">All Stations</h3>
                    <div style="display: flex; gap: 10px;">
                        <button class="view-toggle-btn" id="stationViewToggle">
                            <span id="stationViewIcon">‚äû</span>
                            <span id="stationViewText">Grid</span>
                        </button>
                    </div>
                </div>
                <div class="station-list" id="stationList"></div>
            </div>
        </div>
    </div>
    
    <!-- Playlist Detail Modal -->
    <div id="playlistModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title" id="playlistModalTitle">Playlist</h2>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <button class="view-toggle-btn" id="playlistStationViewToggle">
                        <span id="playlistStationViewIcon">‚äû</span>
                        <span id="playlistStationViewText">Grid</span>
                    </button>
                    <button class="modal-close" id="closePlaylistModal">&times;</button>
                </div>
            </div>
            <div class="modal-body">
                <button class="back-btn" id="backToStations">
                    ‚Üê Back to Stations
                </button>
                <div class="station-list" id="playlistStationList"></div>
            </div>
        </div>
    </div>
    
    <!-- Create/Edit Playlist Modal -->
    <div id="playlistFormModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title" id="playlistFormTitle">Create Playlist</h2>
                <button class="modal-close" id="closePlaylistFormModal">&times;</button>
            </div>
            <div class="modal-body">
                <form id="playlistForm">
                    <div class="form-group">
                        <label class="form-label" for="playlistName">Playlist Name</label>
                        <input 
                            type="text" 
                            id="playlistName" 
                            class="form-input" 
                            placeholder="My Favorite Stations"
                            required
                        >
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="playlistDescription">Description (Optional)</label>
                        <textarea 
                            id="playlistDescription" 
                            class="form-textarea" 
                            placeholder="A collection of my favorite stations..."
                        ></textarea>
                    </div>
                    <div class="form-actions">
                        <button type="button" class="form-btn form-btn-secondary" id="cancelPlaylistForm">
                            Cancel
                        </button>
                        <button type="submit" class="form-btn form-btn-primary">
                            Save Playlist
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>
    
    <!-- Station Form Modal (for add/edit station) -->
    <div id="stationFormModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title" id="stationFormTitle">Add Station</h2>
                <button class="modal-close" id="closeStationFormModal">&times;</button>
            </div>
            <div class="modal-body">
                <form id="stationForm">
                    <div class="form-group">
                        <label class="form-label" for="stationName">Station Name</label>
                        <input 
                            type="text" 
                            id="stationFormName" 
                            class="form-input" 
                            placeholder="Station Name"
                            required
                        >
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="stationUrl">Stream URL</label>
                        <input 
                            type="url" 
                            id="stationFormUrl" 
                            class="form-input" 
                            placeholder="https://stream.example.com/radio"
                            required
                        >
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="stationUrlLow">Low Quality URL (Optional)</label>
                        <input 
                            type="url" 
                            id="stationFormUrlLow" 
                            class="form-input" 
                            placeholder="https://stream.example.com/radio-low"
                        >
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="stationUrlHigh">High Quality URL (Optional)</label>
                        <input 
                            type="url" 
                            id="stationFormUrlHigh" 
                            class="form-input" 
                            placeholder="https://stream.example.com/radio-high"
                        >
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="stationCallLetters">Call Letters (Optional)</label>
                        <input 
                            type="text" 
                            id="stationFormCallLetters" 
                            class="form-input" 
                            placeholder="WXYZ"
                        >
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="stationFrequency">Frequency (Optional)</label>
                        <input 
                            type="text" 
                            id="stationFormFrequency" 
                            class="form-input" 
                            placeholder="95.5 FM"
                        >
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="stationWebsiteUrl">Website URL (Optional)</label>
                        <input 
                            type="url" 
                            id="stationFormWebsiteUrl" 
                            class="form-input" 
                            placeholder="https://station.example.com"
                        >
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="stationGenres">Genres</label>
                        <input 
                            type="text" 
                            id="stationFormGenres" 
                            class="form-input" 
                            placeholder="Rock, Pop, Jazz"
                        >
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="stationDescription">Description (Optional)</label>
                        <textarea 
                            id="stationFormDescription" 
                            class="form-input" 
                            placeholder="A brief description of the station..."
                            rows="3"
                            style="resize: vertical; font-family: inherit;"
                        ></textarea>
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="stationIconUpload">Station Artwork</label>
                        <div style="display: flex; flex-direction: column; gap: 10px;">
                            <div id="iconPreview" style="display: none; align-items: center; gap: 10px; padding: 10px; background: var(--input-bg); border-radius: 8px;">
                                <img id="iconPreviewImg" src="" alt="Preview" style="width: 60px; height: 60px; border-radius: 8px; object-fit: cover;">
                                <div style="flex: 1;">
                                    <div id="iconPreviewName" style="font-size: 14px; color: var(--text-primary); font-weight: 500;"></div>
                                    <div id="iconPreviewSize" style="font-size: 12px; color: var(--text-secondary);"></div>
                                </div>
                                <button type="button" id="removeIcon" class="form-btn form-btn-secondary" style="padding: 6px 12px; font-size: 12px;">Remove</button>
                            </div>
                            <input 
                                type="file" 
                                id="stationFormIconUpload" 
                                accept="image/*"
                                style="display: none;"
                            >
                            <button type="button" id="uploadIconBtn" class="form-btn form-btn-secondary" style="width: 100%;">
                                üì∑ Choose Image
                            </button>
                            <input 
                                type="url" 
                                id="stationFormIconUrl" 
                                class="form-input" 
                                placeholder="Or paste image URL"
                            >
                        </div>
                    </div>
                    <div class="form-actions">
                        <button type="button" class="form-btn form-btn-secondary" id="cancelStationForm">
                            Cancel
                        </button>
                        <button type="submit" class="form-btn form-btn-primary">
                            Save Station
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Radio Database Modal -->
    <div id="radioDatabaseModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header">
                <h2 class="modal-title">Radio Database Search</h2>
                <button class="modal-close" id="closeRadioDatabaseModal">&times;</button>
            </div>
            <div class="modal-body">
                <!-- Search Interface -->
                <div style="margin-bottom: 20px;">
                    <div class="form-group">
                        <input
                            type="text"
                            id="radioDatabaseSearchInput"
                            class="form-input"
                            placeholder="Search by station name, country, language, or tag..."
                        >
                    </div>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-top: 10px;">
                        <select id="radioDatabaseCountry" class="form-input" style="flex: 1; min-width: 150px;">
                            <option value="">All Countries</option>
                        </select>

                        <select id="radioDatabaseLanguage" class="form-input" style="flex: 1; min-width: 150px;">
                            <option value="">All Languages</option>
                        </select>

                        <select id="radioDatabaseTag" class="form-input" style="flex: 1; min-width: 150px;">
                            <option value="">All Tags</option>
                        </select>

                        <select id="radioDatabaseSort" class="form-input" style="flex: 1; min-width: 150px;">
                            <option value="votes">Most Popular</option>
                            <option value="name">Name (A-Z)</option>
                            <option value="clickcount">Most Clicked</option>
                            <option value="bitrate">Highest Bitrate</option>
                            <option value="changetimestamp">Recently Updated</option>
                        </select>
                        <button id="radioDatabaseSearchBtn" class="form-btn form-btn-primary" style="padding: 0 20px;">
                            Search
                        </button>
                    </div>
                </div>

                <!-- Loading Indicator -->
                <div id="radioDatabaseLoading" style="display: none; text-align: center; padding: 40px;">
                    <div style="font-size: 18px; color: var(--text-secondary);">Searching...</div>
                </div>

                <!-- Error Message -->
                <div id="radioDatabaseError" style="display: none; padding: 20px; background: var(--error-bg, #fee); border-radius: 12px; color: var(--error-text, #c00); margin-bottom: 20px;">
                </div>

                <!-- Results Container -->
                <div id="radioDatabaseResults" style="max-height: 500px; overflow-y: auto;">
                    <div style="text-align: center; padding: 40px; color: var(--text-secondary);">
                        Enter search criteria and click Search to find radio stations from around the world
                    </div>
                </div>

                <!-- Pagination Controls -->
                <div id="radioDatabasePagination" style="display: none; margin-top: 20px; padding-top: 20px; border-top: 1px solid var(--border-color); justify-content: space-between; align-items: center;">
                    <button id="radioDatabasePrevBtn" class="form-btn form-btn-secondary" style="padding: 8px 16px;" disabled>
                        ‚Üê Previous
                    </button>
                    <div id="radioDatabasePageInfo" style="color: var(--text-secondary); font-size: 14px;">
                        Page 1
                    </div>
                    <button id="radioDatabaseNextBtn" class="form-btn form-btn-secondary" style="padding: 8px 16px;">
                        Next ‚Üí
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Playlist Selector Modal for Radio Browser -->
    <div id="playlistSelectorModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h2 class="modal-title" id="playlistSelectorTitle">Add to Playlist</h2>
                <button class="modal-close" id="closePlaylistSelectorModal">&times;</button>
            </div>
            <div class="modal-body">
                <div id="playlistSelectorList" style="max-height: 400px; overflow-y: auto;">
                    <!-- Playlists will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // ======================
        // GLOBAL VARIABLES
        // ======================

        // LrcLib API - No access token needed

        let supabase;
        let player = null;
        let hlsPlayer = null;
        let audioElement = null;
        let simpleAudioPlayer = null;
        let metadataOnlyPlayer = null; // Silent player for metadata during Chromecast
        let metadataOnlyPlayerUrl = null; // Track the URL currently being used by metadata-only player
        let metadataOnlyPlayerIntentionalStop = false; // Track if stop was intentional
        let metadataOnlyPlayerRetryCount = 0; // Track consecutive restart attempts
        let metadataOnlyPlayerMaxRetries = 5; // Maximum number of restart attempts
        let metadataOnlyPlayerRetryTimeoutId = null; // Track pending retry timeout
        let metadataOnlyPlayerErrorCount = 0; // Track consecutive errors from onError handler
        let metadataOnlyPlayerMaxErrors = 3; // Maximum errors before giving up
        let metadataOnlyPlayerWaitingTimeoutId = null; // Track timeout for stuck 'waiting' state
        let metadataOnlyPlayerWaitingTimeout = 30000; // 30 seconds timeout for waiting state
        let metadataOnlyPlayerRefreshIntervalId = null; // Track periodic refresh interval
        let metadataOnlyPlayerRefreshInterval = 10000; // Refresh metadata player every 10 seconds to keep in sync
        let currentPlaybackAbortController = null; // For cancelling ongoing connection attempts

        // CORS proxy configuration (shared between audio player and metadata player)
        const corsProxies = [
            // Self-hosted CORS proxies (highest priority):
            { name: 'cloudflare-worker', url: (streamUrl) => `https://streamwave-cors-proxy.keith-e-dragon.workers.dev/${streamUrl}` },
            { name: 'streamwave-render', url: (streamUrl) => `https://streamwave-radio.onrender.com/${streamUrl}` },

            // Public fallback proxies (may be unreliable or rate-limited)
            { name: 'corsproxy.io', url: (streamUrl) => `https://corsproxy.io/?${encodeURIComponent(streamUrl)}` },
            { name: 'api.allorigins.win', url: (streamUrl) => `https://api.allorigins.win/raw?url=${encodeURIComponent(streamUrl)}` },
            { name: 'cors-anywhere (public)', url: (streamUrl) => `https://cors-anywhere.herokuapp.com/${streamUrl}` }
        ];
        let isPlaying = false;
        let isPaused = false;
        let simplePlayerReloading = false; // Flag to suppress errors during stream switching
        let currentStation = null;
        let stations = [];
        let filteredStations = [];
        let playlists = [];
        let currentPlaylist = null;
        let lastOpenedModal = null;

        // Radio Database pagination
        let radioDatabaseCurrentPage = 1;
        let radioDatabaseItemsPerPage = 50;
        let radioDatabaseTotalResults = 0;
        let currentTrack = {
            title: null,
            artist: null,
            album: null,
            artworkUrl: null,
            lyrics: null,
            lyricsUrl: null,
            hasLyrics: false
        };
        let likedTracks = [];
        let recentTracks = [];
        let autoFallbackEnabled = true;
        let hasFallbackAttempted = false;
        let editingStationId = null;
        let editingPlaylistId = null;
        let currentSortMethod = 'name-asc';
        let currentGenreFilter = '';
        let stationViewMode = 'list';
        let playlistViewMode = 'list';
        let playlistStationViewMode = 'list';
        
        // Settings
        let playbackMode = 'live'; // 'live' or 'simple'
        let quality = 'standard'; // 'high' or 'standard'
        let selectedQuality = 'standard'; // Current quality selection for streams
        
        // ======================
        // DOM Elements
        // ======================

        // Hamburger Menu
        const overviewBtn = document.getElementById('overviewBtn');
        const hamburgerMenuBtn = document.getElementById('hamburgerMenuBtn');
        const hamburgerMenuModal = document.getElementById('hamburgerMenuModal');
        const closeHamburgerMenuModal = document.getElementById('closeHamburgerMenuModal');
        const settingsMenuBtn = document.getElementById('settingsMenuBtn');
        const browseMenuBtn = document.getElementById('browseMenuBtn');

        // Station Display
        const stationDisplay = document.getElementById('stationDisplay');
        const stationDisplayIcon = document.getElementById('stationDisplayIcon');
        const stationDisplayName = document.getElementById('stationDisplayName');

        // Modals
        const playlistsModal = document.getElementById('playlistsModal');
        const closePlaylistsModal = document.getElementById('closePlaylistsModal');
        const browseStationsModal = document.getElementById('browseStationsModal');
        const closeBrowseStationsModal = document.getElementById('closeBrowseStationsModal');
        const settingsModal = document.getElementById('settingsModal');
        const closeSettingsModal = document.getElementById('closeSettingsModal');
        const authBtn = document.getElementById('authBtn');
        const overviewModal = document.getElementById('overviewModal');
        const closeOverviewModal = document.getElementById('closeOverviewModal');
        const stationInfoModal = document.getElementById('stationInfoModal');
        const closeStationInfoModal = document.getElementById('closeStationInfoModal');

        const stationList = document.getElementById('stationList');
        const stationSearch = document.getElementById('stationSearch');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const playIcon = playPauseBtn.querySelector('.play-icon');
        const pauseIcon = playPauseBtn.querySelector('.pause-icon');
        const artworkContainer = document.getElementById('artworkContainer');
        const artworkContainerPortrait = document.getElementById('artworkContainerPortrait');

        // Helper function to update both artwork containers
        function updateArtwork(html) {
            artworkContainer.innerHTML = html;
            artworkContainerPortrait.innerHTML = html;
        }
        const metadataDiv = document.getElementById('metadataSection');
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        
        // Playlist elements
        const playlistsSection = document.getElementById('playlistsSection');
        const playlistsList = document.getElementById('playlistsList');
        const createPlaylistBtn = document.getElementById('createPlaylistBtn');
        const playlistModal = document.getElementById('playlistModal');
        const closePlaylistModal = document.getElementById('closePlaylistModal');
        const playlistModalTitle = document.getElementById('playlistModalTitle');
        const backToStations = document.getElementById('backToStations');
        const playlistStationList = document.getElementById('playlistStationList');
        
        // Sort and genre filter elements
        const genreBtn = document.getElementById('genreBtn');
        const genreDropdown = document.getElementById('genreDropdown');
        const genreLabel = document.getElementById('genreLabel');
        const sortBtn = document.getElementById('sortBtn');
        const sortDropdown = document.getElementById('sortDropdown');
        const sortLabel = document.getElementById('sortLabel');
        
        // View toggle elements
        const stationViewToggle = document.getElementById('stationViewToggle');
        const stationViewIcon = document.getElementById('stationViewIcon');
        const stationViewText = document.getElementById('stationViewText');
        const playlistViewToggle = document.getElementById('playlistViewToggle');
        const playlistViewIcon = document.getElementById('playlistViewIcon');
        const playlistViewText = document.getElementById('playlistViewText');
        const playlistStationViewToggle = document.getElementById('playlistStationViewToggle');
        const playlistStationViewIcon = document.getElementById('playlistStationViewIcon');
        const playlistStationViewText = document.getElementById('playlistStationViewText');
        
        // Playlist form elements
        const playlistFormModal = document.getElementById('playlistFormModal');
        const closePlaylistFormModal = document.getElementById('closePlaylistFormModal');
        const playlistFormTitle = document.getElementById('playlistFormTitle');
        const playlistForm = document.getElementById('playlistForm');
        const playlistName = document.getElementById('playlistName');
        const playlistDescription = document.getElementById('playlistDescription');
        const cancelPlaylistForm = document.getElementById('cancelPlaylistForm');
        
        // Liked tracks elements
        const likedTracksModal = document.getElementById('likedTracksModal');
        const closeLikedTracksModal = document.getElementById('closeLikedTracksModal');
        const likedTracksList = document.getElementById('likedTracksList');
        const clearAllLikesBtn = document.getElementById('clearAllLikesBtn');

        // Radio Database elements
        const radioDatabaseBtn = document.getElementById('radioDatabaseBtn');
        const radioDatabaseModal = document.getElementById('radioDatabaseModal');
        const closeRadioDatabaseModal = document.getElementById('closeRadioDatabaseModal');
        const radioDatabaseSearchInput = document.getElementById('radioDatabaseSearchInput');
        const radioDatabaseCountry = document.getElementById('radioDatabaseCountry');
        const radioDatabaseLanguage = document.getElementById('radioDatabaseLanguage');
        const radioDatabaseTag = document.getElementById('radioDatabaseTag');
        const radioDatabaseSort = document.getElementById('radioDatabaseSort');
        const radioDatabaseSearchBtn = document.getElementById('radioDatabaseSearchBtn');
        const radioDatabaseLoading = document.getElementById('radioDatabaseLoading');
        const radioDatabaseError = document.getElementById('radioDatabaseError');
        const radioDatabaseResults = document.getElementById('radioDatabaseResults');
        const radioDatabasePagination = document.getElementById('radioDatabasePagination');
        const radioDatabasePrevBtn = document.getElementById('radioDatabasePrevBtn');
        const radioDatabaseNextBtn = document.getElementById('radioDatabaseNextBtn');
        const radioDatabasePageInfo = document.getElementById('radioDatabasePageInfo');

        // Playlist Selector Modal elements
        const playlistSelectorModal = document.getElementById('playlistSelectorModal');
        const closePlaylistSelectorModal = document.getElementById('closePlaylistSelectorModal');
        const playlistSelectorTitle = document.getElementById('playlistSelectorTitle');
        const playlistSelectorList = document.getElementById('playlistSelectorList');

        // ======================
        // LIKED TRACKS FUNCTIONS
        // ======================

        // Note: loadLikedTracks, saveLikedTracks, addLikedTrack, removeLikedTrack
        // are now provided by radio-auth.js and available as window functions
        // They automatically handle both guest (localStorage) and authenticated (Supabase) modes
        
        // Check if current track is liked
        async function isCurrentTrackLiked() {
            if (!currentTrack.title || !currentTrack.artist) return false;
            return await window.isTrackLiked(currentTrack.title, currentTrack.artist);
        }
        
        // Toggle like for current track
        async function toggleLikeTrack() {
            if (!currentTrack.title || !currentTrack.artist) return;

            const isLiked = await window.isTrackLiked(currentTrack.title, currentTrack.artist);

            if (isLiked) {
                // Unlike - need to find the track object first
                const likedTracks = await window.loadLikedTracks();
                const track = likedTracks.find(t =>
                    t.title === currentTrack.title && t.artist === currentTrack.artist
                );
                if (track) {
                    await window.removeLikedTrack(track);
                }
            } else {
                // Like - use addLikedTrack from radio-auth.js
                await window.addLikedTrack({
                    title: currentTrack.title,
                    artist: currentTrack.artist,
                    album: currentTrack.album || '',
                    artworkUrl: currentTrack.artworkUrl || '',
                    station: currentStation ? currentStation.name : 'Unknown Station'
                });
            }

            await updateLikeButton();

            // Close the Now Playing modal after liking/unliking
            closeNowPlayingModal();
        }

        // Update like button state
        async function updateLikeButton() {
            // Update modal like button if it exists
            const modalLikeBtn = document.getElementById('modalLikeBtn');

            if (!currentTrack.title || !currentTrack.artist) {
                if (modalLikeBtn) {
                    modalLikeBtn.classList.add('disabled');
                    modalLikeBtn.querySelector('.action-icon').textContent = '‚ô°';
                }
                return;
            }

            if (modalLikeBtn) {
                modalLikeBtn.classList.remove('disabled');
            }

            const isLiked = await isCurrentTrackLiked();
            if (modalLikeBtn) {
                if (isLiked) {
                    modalLikeBtn.classList.add('liked');
                    modalLikeBtn.querySelector('.action-icon').textContent = '‚ô•';
                } else {
                    modalLikeBtn.classList.remove('liked');
                    modalLikeBtn.querySelector('.action-icon').textContent = '‚ô°';
                }
            }
        }
        
        // ======================
        // RECENT TRACKS MANAGEMENT
        // ======================

        // Note: loadRecentTracks, saveRecentTracks, addToRecentTracks, clearAllRecentTracks
        // are now provided by radio-auth.js and available as window functions
        // They automatically handle both guest (localStorage) and authenticated (Supabase) modes

        const MAX_RECENT_TRACKS = 15;
        
        // Display recent tracks in modal
        async function displayRecentTracks() {
            const rawTracks = await window.loadRecentTracks();
            const recentTracks = rawTracks.map(t => window.normalizeTrack(t));
            const recentTracksList = document.getElementById('recentTracksList');
            const clearRecentTracksBtn = document.getElementById('clearRecentTracksBtn');
            const copyAllRecentBtn = document.getElementById('copyAllRecentBtn');
            const downloadRecentBtn = document.getElementById('downloadRecentBtn');

            if (recentTracks.length === 0) {
                recentTracksList.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üïê</div>
                        <div class="empty-state-text">No recent tracks yet. Start listening to see your recently played tracks here!</div>
                    </div>
                `;
                clearRecentTracksBtn.style.display = 'none';
                copyAllRecentBtn.style.display = 'none';
                downloadRecentBtn.style.display = 'none';
            } else {
                clearRecentTracksBtn.style.display = 'block';
                copyAllRecentBtn.style.display = 'block';
                downloadRecentBtn.style.display = 'block';
                recentTracksList.innerHTML = recentTracks.map((track, index) => {
                    const date = new Date(track.timestamp);
                    const timeAgo = getTimeAgo(date);

                    return `
                        <div class="liked-track-item">
                            ${track.artworkUrl ?
                                `<img class="liked-track-art" src="${track.artworkUrl}" alt="${escapeHtml(track.title)}">` :
                                `<div class="liked-track-art">‚ô™</div>`
                            }
                            <div class="liked-track-info">
                                <div class="liked-track-title">${escapeHtml(track.title)}</div>
                                <div class="liked-track-artist">${escapeHtml(track.artist)}</div>
                                <div class="liked-track-meta">
                                    ${escapeHtml(track.station)} ‚Ä¢ ${timeAgo}
                                </div>
                            </div>
                            <button class="copy-track-btn" onclick="copySingleTrack('${escapeHtml(track.artist)}', '${escapeHtml(track.title)}', this)">
                                <svg width="14" height="14" viewBox="0 0 256 256" style="vertical-align: middle;">
                                    <path fill="currentColor" d="M216 32H88a16 16 0 0 0-16 16v40H40a16 16 0 0 0-16 16v120a16 16 0 0 0 16 16h128a16 16 0 0 0 16-16v-40h32a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16zm-48 192H40V104h128zm48-48h-32V104a16 16 0 0 0-16-16H88V48h128z"/>
                                </svg>
                            </button>
                        </div>
                    `;
                }).join('');
            }
        }
        
        // Clear all recent tracks
        async function clearAllRecentTracks() {
            if (confirm('Are you sure you want to clear all recently played tracks?')) {
                await window.clearAllRecentTracks();
                await displayRecentTracks();
            }
        }
        
        // ======================
        // COPY TRACK FUNCTIONS
        // ======================
        
        // Copy single track to clipboard
        async function copySingleTrack(artist, title, buttonElement) {
            const text = `${artist} - ${title}`;
            
            try {
                await navigator.clipboard.writeText(text);
                
                // Visual feedback - replace icon with checkmark
                const originalHTML = buttonElement.innerHTML;
                buttonElement.innerHTML = '<svg width="14" height="14" viewBox="0 0 256 256" style="vertical-align: middle;"><path fill="currentColor" d="M229.66 77.66l-128 128a8 8 0 0 1-11.32 0l-56-56a8 8 0 0 1 11.32-11.32L96 188.69 218.34 66.34a8 8 0 0 1 11.32 11.32z"/></svg>';
                buttonElement.classList.add('copied');
                
                setTimeout(() => {
                    buttonElement.innerHTML = originalHTML;
                    buttonElement.classList.remove('copied');
                }, 2000);
            } catch (err) {
                console.error('Failed to copy:', err);
                alert('Failed to copy to clipboard');
            }
        }
        
        // Copy all liked tracks to clipboard
        async function copyAllLikedTracks() {
            const likedTracks = await window.loadLikedTracks();

            if (likedTracks.length === 0) {
                alert('No liked tracks to copy');
                return;
            }

            const text = likedTracks.map(track =>
                `${track.artist} - ${track.title}`
            ).join('\n');

            try {
                await navigator.clipboard.writeText(text);

                // Visual feedback
                const btn = document.getElementById('copyAllLikedBtn');
                const originalHTML = btn.innerHTML;
                btn.innerHTML = '<svg width="16" height="16" viewBox="0 0 256 256" style="vertical-align: middle; margin-right: 6px;"><path fill="currentColor" d="M229.66 77.66l-128 128a8 8 0 0 1-11.32 0l-56-56a8 8 0 0 1 11.32-11.32L96 188.69 218.34 66.34a8 8 0 0 1 11.32 11.32z"/></svg>Copied!';
                btn.style.background = 'rgba(76, 175, 80, 0.3)';
                btn.style.borderColor = 'rgba(76, 175, 80, 0.5)';
                btn.style.color = '#4caf50';

                setTimeout(() => {
                    btn.innerHTML = originalHTML;
                    btn.style.background = '';
                    btn.style.borderColor = '';
                    btn.style.color = '';
                }, 2000);
            } catch (err) {
                console.error('Failed to copy:', err);
                alert('Failed to copy to clipboard');
            }
        }
        
        // Copy all recent tracks to clipboard
        async function copyAllRecentTracks() {
            const recentTracks = await window.loadRecentTracks();

            if (recentTracks.length === 0) {
                alert('No recent tracks to copy');
                return;
            }

            const text = recentTracks.map(track =>
                `${track.artist} - ${track.title}`
            ).join('\n');

            try {
                await navigator.clipboard.writeText(text);

                // Visual feedback
                const btn = document.getElementById('copyAllRecentBtn');
                const originalHTML = btn.innerHTML;
                btn.innerHTML = '<svg width="16" height="16" viewBox="0 0 256 256" style="vertical-align: middle; margin-right: 6px;"><path fill="currentColor" d="M229.66 77.66l-128 128a8 8 0 0 1-11.32 0l-56-56a8 8 0 0 1 11.32-11.32L96 188.69 218.34 66.34a8 8 0 0 1 11.32 11.32z"/></svg>Copied!';
                btn.style.background = 'rgba(76, 175, 80, 0.3)';
                btn.style.borderColor = 'rgba(76, 175, 80, 0.5)';
                btn.style.color = '#4caf50';

                setTimeout(() => {
                    btn.innerHTML = originalHTML;
                    btn.style.background = '';
                    btn.style.borderColor = '';
                    btn.style.color = '';
                }, 2000);
            } catch (err) {
                console.error('Failed to copy:', err);
                alert('Failed to copy to clipboard');
            }
        }
        
        // Download liked tracks as text file
        async function downloadLikedTracksFile() {
            const likedTracks = await window.loadLikedTracks();

            if (likedTracks.length === 0) {
                alert('No liked tracks to download');
                return;
            }

            const text = likedTracks.map(track =>
                `${track.artist} - ${track.title}`
            ).join('\n');

            // Create blob and download
            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `liked-tracks-${new Date().toISOString().split('T')[0]}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            // Visual feedback
            const btn = document.getElementById('downloadLikedBtn');
            const originalHTML = btn.innerHTML;
            btn.innerHTML = '<svg width="16" height="16" viewBox="0 0 256 256" style="vertical-align: middle; margin-right: 6px;"><path fill="currentColor" d="M229.66 77.66l-128 128a8 8 0 0 1-11.32 0l-56-56a8 8 0 0 1 11.32-11.32L96 188.69 218.34 66.34a8 8 0 0 1 11.32 11.32z"/></svg>Downloaded!';
            btn.style.background = 'rgba(76, 175, 80, 0.3)';
            btn.style.borderColor = 'rgba(76, 175, 80, 0.5)';
            btn.style.color = '#4caf50';

            setTimeout(() => {
                btn.innerHTML = originalHTML;
                btn.style.background = '';
                btn.style.borderColor = '';
                btn.style.color = '';
            }, 2000);
        }
        
        // Download recent tracks as text file
        async function downloadRecentTracksFile() {
            const recentTracks = await window.loadRecentTracks();

            if (recentTracks.length === 0) {
                alert('No recent tracks to download');
                return;
            }

            const text = recentTracks.map(track =>
                `${track.artist} - ${track.title}`
            ).join('\n');

            // Create blob and download
            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `recent-tracks-${new Date().toISOString().split('T')[0]}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            // Visual feedback
            const btn = document.getElementById('downloadRecentBtn');
            const originalHTML = btn.innerHTML;
            btn.innerHTML = '<svg width="16" height="16" viewBox="0 0 256 256" style="vertical-align: middle; margin-right: 6px;"><path fill="currentColor" d="M229.66 77.66l-128 128a8 8 0 0 1-11.32 0l-56-56a8 8 0 0 1 11.32-11.32L96 188.69 218.34 66.34a8 8 0 0 1 11.32 11.32z"/></svg>Downloaded!';
            btn.style.background = 'rgba(76, 175, 80, 0.3)';
            btn.style.borderColor = 'rgba(76, 175, 80, 0.5)';
            btn.style.color = '#4caf50';

            setTimeout(() => {
                btn.innerHTML = originalHTML;
                btn.style.background = '';
                btn.style.borderColor = '';
                btn.style.color = '';
            }, 2000);
        }
        
        // Display liked tracks in modal
        async function displayLikedTracks() {
            const rawTracks = await window.loadLikedTracks();
            const likedTracks = rawTracks.map(t => window.normalizeTrack(t));
            const copyAllLikedBtn = document.getElementById('copyAllLikedBtn');
            const downloadLikedBtn = document.getElementById('downloadLikedBtn');

            if (likedTracks.length === 0) {
                likedTracksList.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">‚ô°</div>
                        <div class="empty-state-text">No liked tracks yet. Like a track while listening to save it here!</div>
                    </div>
                `;
                clearAllLikesBtn.style.display = 'none';
                copyAllLikedBtn.style.display = 'none';
                downloadLikedBtn.style.display = 'none';
            } else {
                clearAllLikesBtn.style.display = 'block';
                copyAllLikedBtn.style.display = 'block';
                downloadLikedBtn.style.display = 'block';
                likedTracksList.innerHTML = rawTracks.map((track, index) => {
                    const normalizedTrack = window.normalizeTrack(track);
                    const date = new Date(normalizedTrack.timestamp);
                    const timeAgo = getTimeAgo(date);

                    return `
                        <div class="liked-track-item" data-track-index="${index}">
                            ${normalizedTrack.artworkUrl ?
                                `<img class="liked-track-art" src="${normalizedTrack.artworkUrl}" alt="${escapeHtml(normalizedTrack.title)}">` :
                                `<div class="liked-track-art">‚ô™</div>`
                            }
                            <div class="liked-track-info">
                                <div class="liked-track-title">${escapeHtml(normalizedTrack.title)}</div>
                                <div class="liked-track-artist">${escapeHtml(normalizedTrack.artist)}</div>
                                <div class="liked-track-meta">
                                    ${escapeHtml(normalizedTrack.station)} ‚Ä¢ ${timeAgo}
                                </div>
                            </div>
                            <div class="track-actions">
                                <button class="copy-track-btn" onclick="copySingleTrack('${escapeHtml(normalizedTrack.artist)}', '${escapeHtml(normalizedTrack.title)}', this)">
                                    <svg width="14" height="14" viewBox="0 0 256 256" style="vertical-align: middle;">
                                        <path fill="currentColor" d="M216 32H88a16 16 0 0 0-16 16v40H40a16 16 0 0 0-16 16v120a16 16 0 0 0 16 16h128a16 16 0 0 0 16-16v-40h32a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16zm-48 192H40V104h128zm48-48h-32V104a16 16 0 0 0-16-16H88V48h128z"/>
                                    </svg>
                                </button>
                                <button class="unlike-btn" onclick="unlikeTrack(${index})">√ó</button>
                            </div>
                        </div>
                    `;
                }).join('');
            }
        }
        
        // Unlike a track by index
        async function unlikeTrack(index) {
            const likedTracks = await window.loadLikedTracks();
            const track = likedTracks[index];
            if (track) {
                await window.removeLikedTrack(track);
                await displayLikedTracks();
                await updateLikeButton();
            }
        }

        // Clear all liked tracks
        async function clearAllLikedTracks() {
            if (confirm('Are you sure you want to clear all liked tracks? This cannot be undone.')) {
                await window.clearAllLikedTracks();
                await displayLikedTracks();
                await updateLikeButton();
            }
        }
        
        // Helper function to get time ago string
        function getTimeAgo(date) {
            const seconds = Math.floor((new Date() - date) / 1000);
            
            const intervals = {
                year: 31536000,
                month: 2592000,
                week: 604800,
                day: 86400,
                hour: 3600,
                minute: 60
            };
            
            for (const [unit, secondsInUnit] of Object.entries(intervals)) {
                const interval = Math.floor(seconds / secondsInUnit);
                if (interval >= 1) {
                    return `${interval} ${unit}${interval === 1 ? '' : 's'} ago`;
                }
            }
            
            return 'Just now';
        }

        
        // Station form elements
        const stationFormModal = document.getElementById('stationFormModal');
        const closeStationFormModal = document.getElementById('closeStationFormModal');
        const stationFormTitle = document.getElementById('stationFormTitle');
        const stationForm = document.getElementById('stationForm');
        const cancelStationForm = document.getElementById('cancelStationForm');
        
        // ======================
        // SUPABASE INITIALIZATION
        // ======================

        // Use the Supabase client initialized by radio-auth.js
        // radio-auth.js sets up window.supabaseClient, window.currentUser, etc.
        supabase = window.supabaseClient;

        // Check authentication status on load
        if (window.checkAuth) {
            window.checkAuth();
        }

        // ======================
        // RADIO BROWSER API FUNCTIONS
        // ======================

        const RADIO_BROWSER_API_BASE = 'https://de1.api.radio-browser.info/json';

        // Load countries, languages, and tags for the dropdowns
        async function loadRadioBrowserFilters() {
            try {
                // Load top countries
                const countriesRes = await fetch(`${RADIO_BROWSER_API_BASE}/countries?order=stationcount&reverse=true&limit=50`);
                const countries = await countriesRes.json();

                countries.forEach(country => {
                    if (country.name && country.stationcount > 0) {
                        const option = document.createElement('option');
                        option.value = country.name;
                        option.textContent = `${country.name} (${country.stationcount})`;
                        radioDatabaseCountry.appendChild(option);
                    }
                });

                // Load top languages
                const languagesRes = await fetch(`${RADIO_BROWSER_API_BASE}/languages?order=stationcount&reverse=true&limit=50`);
                const languages = await languagesRes.json();

                languages.forEach(lang => {
                    if (lang.name && lang.stationcount > 0) {
                        const option = document.createElement('option');
                        option.value = lang.name;
                        option.textContent = `${lang.name} (${lang.stationcount})`;
                        radioDatabaseLanguage.appendChild(option);
                    }
                });

                // Load top tags
                const tagsRes = await fetch(`${RADIO_BROWSER_API_BASE}/tags?order=stationcount&reverse=true&limit=100`);
                const tags = await tagsRes.json();

                tags.forEach(tag => {
                    if (tag.name && tag.stationcount > 0) {
                        const option = document.createElement('option');
                        option.value = tag.name;
                        option.textContent = `${tag.name} (${tag.stationcount})`;
                        radioDatabaseTag.appendChild(option);
                    }
                });
            } catch (error) {
                console.error('Error loading Radio Browser filters:', error);
            }
        }

        // Search Radio Browser API
        async function searchRadioBrowser(page = 1) {
            const searchTerm = radioDatabaseSearchInput.value.trim();
            const country = radioDatabaseCountry.value;
            const language = radioDatabaseLanguage.value;
            const tag = radioDatabaseTag.value;
            const sortBy = radioDatabaseSort.value;

            // Update current page
            radioDatabaseCurrentPage = page;

            // Build query parameters
            const params = new URLSearchParams();
            if (searchTerm) params.append('name', searchTerm);
            if (country) params.append('country', country);
            if (language) params.append('language', language);
            if (tag) params.append('tag', tag);

            // Pagination
            params.append('limit', radioDatabaseItemsPerPage.toString());
            params.append('offset', ((page - 1) * radioDatabaseItemsPerPage).toString());

            // Sorting
            params.append('order', sortBy);
            params.append('reverse', 'true');
            params.append('hidebroken', 'true');

            // Show loading
            radioDatabaseLoading.style.display = 'block';
            radioDatabaseError.style.display = 'none';
            radioDatabaseResults.innerHTML = '';
            radioDatabasePagination.style.display = 'none';

            try {
                const response = await fetch(`${RADIO_BROWSER_API_BASE}/stations/search?${params.toString()}`);

                if (!response.ok) {
                    throw new Error('Failed to fetch stations');
                }

                const results = await response.json();

                // Hide loading
                radioDatabaseLoading.style.display = 'none';

                if (results.length === 0) {
                    radioDatabaseResults.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: var(--text-secondary);">
                            No stations found. Try different search criteria.
                        </div>
                    `;
                    radioDatabasePagination.style.display = 'none';
                    return;
                }

                // Update total results (estimate based on returned results)
                radioDatabaseTotalResults = results.length;

                // Render results
                renderRadioBrowserResults(results);

                // Update pagination controls
                updateRadioDatabasePagination(results.length);
            } catch (error) {
                console.error('Error searching Radio Browser:', error);
                radioDatabaseLoading.style.display = 'none';
                radioDatabaseError.style.display = 'block';
                radioDatabaseError.textContent = 'Error searching radio stations. Please try again.';
                radioDatabasePagination.style.display = 'none';
            }
        }

        // Update pagination controls
        function updateRadioDatabasePagination(resultsCount) {
            if (resultsCount === 0) {
                radioDatabasePagination.style.display = 'none';
                return;
            }

            radioDatabasePagination.style.display = 'flex';

            // Update page info
            radioDatabasePageInfo.textContent = `Page ${radioDatabaseCurrentPage}`;

            // Update Previous button
            radioDatabasePrevBtn.disabled = radioDatabaseCurrentPage === 1;

            // Update Next button - disable if we got fewer results than the limit (meaning we're on the last page)
            radioDatabaseNextBtn.disabled = resultsCount < radioDatabaseItemsPerPage;

            // Scroll results container to top
            radioDatabaseResults.scrollTop = 0;
        }

        // Render Radio Browser search results
        function renderRadioBrowserResults(results) {
            // Check if current user is admin
            console.log('üîç Checking admin status...');
            console.log('window.currentUser:', window.currentUser);
            console.log('window.currentUser.email:', window.currentUser?.email);
            const isAdmin = window.currentUser && window.currentUser.email === 'keith.e.dragon@gmail.com';
            console.log('isAdmin:', isAdmin);

            radioDatabaseResults.innerHTML = results.map(station => {
                const favicon = station.favicon || '';
                const country = station.country || 'Unknown';
                const language = station.language || 'Unknown';
                const tags = station.tags ? station.tags.split(',').slice(0, 3).join(', ') : '';
                const votes = station.votes || 0;
                const bitrate = station.bitrate || 0;

                return `
                    <div class="station-card" data-station='${JSON.stringify(station).replace(/'/g, '&apos;')}' style="margin-bottom: 12px; padding: 16px; border: 2px solid var(--border-color); border-radius: 12px; background: var(--card-bg); cursor: pointer; transition: border-color 0.2s;">
                        <div style="display: flex; align-items: start; gap: 12px;">
                            <div style="flex-shrink: 0; width: 50px; height: 50px; border-radius: 8px; overflow: hidden; background: var(--input-bg); display: flex; align-items: center; justify-content: center;">
                                ${favicon ? `<img src="${favicon}" alt="${station.name}" style="width: 100%; height: 100%; object-fit: cover;" onerror="this.onerror=null; this.src='icons/icon-512x512.png'">` : '<img src="icons/icon-512x512.png" alt="Radio" style="width: 100%; height: 100%; object-fit: cover;">'}
                            </div>
                            <div style="flex: 1; min-width: 0;">
                                <div style="font-weight: 600; font-size: 16px; color: var(--text-primary); margin-bottom: 4px;">${station.name}</div>
                                <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 6px;">
                                    ${country} ${language !== 'Unknown' ? `‚Ä¢ ${language}` : ''} ${bitrate > 0 ? `‚Ä¢ ${bitrate}kbps` : ''}
                                </div>
                                ${tags ? `<div style="font-size: 12px; color: var(--text-secondary);">${tags}</div>` : ''}
                            </div>
                            <div style="display: flex; gap: 8px; align-items: center; flex-direction: column;">
                                <button
                                    class="radio-db-add-btn"
                                    data-station='${JSON.stringify(station).replace(/'/g, '&apos;')}'
                                    title="Add to My Stations"
                                    style="padding: 8px 12px; border: 2px solid var(--border-color); border-radius: 8px; background: var(--card-bg); cursor: pointer; font-size: 14px; color: var(--text-primary);"
                                >
                                    ‚ûï
                                </button>
                                ${isAdmin ? `
                                <button
                                    class="radio-db-curate-btn"
                                    data-station='${JSON.stringify(station).replace(/'/g, '&apos;')}'
                                    title="Add to Curated Stations"
                                    style="padding: 6px 10px; border: 2px solid var(--border-color); border-radius: 8px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); cursor: pointer; font-size: 11px; color: var(--text-primary); white-space: nowrap;"
                                >
                                    ‚≠ê Curate
                                </button>
                                ` : ''}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            // Add click event listeners to station cards
            document.querySelectorAll('.station-card').forEach(card => {
                card.addEventListener('click', (e) => {
                    const station = JSON.parse(card.getAttribute('data-station'));
                    playRadioBrowserStation(station);
                });
            });

            // Add event listeners to add buttons
            document.querySelectorAll('.radio-db-add-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const station = JSON.parse(btn.getAttribute('data-station'));
                    showPlaylistSelectorForRadioBrowser(station);
                });
            });

            // Add event listeners to curate buttons (admin only)
            document.querySelectorAll('.radio-db-curate-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const station = JSON.parse(btn.getAttribute('data-station'));
                    showStationFormForCuration(station);
                });
            });
        }

        // Play a station from Radio Browser
        async function playRadioBrowserStation(station) {
            try {
                // Add station to external_stations table (or get existing ID)
                const externalStationId = await addExternalStation(station);

                // Convert Radio Browser station to our station format
                const ourStation = {
                    id: null, // Temporary ID for backwards compatibility
                    name: station.name,
                    url: station.url_resolved || station.url,
                    icon_url: station.favicon || '',
                    genres: station.tags ? station.tags.split(',').map(t => t.trim()) : [],
                    call_letters: '',
                    frequency: '',
                    is_external: true,
                    external_id: externalStationId
                };

                // Close the radio database modal
                radioDatabaseModal.classList.remove('active');

                // Select and play the station
                selectStation(ourStation);
                setTimeout(() => {
                    playPauseBtn.click();
                }, 100);

                // Track the station play in history
                await trackStationClick(null, externalStationId);
            } catch (error) {
                console.error('Error playing radio browser station:', error);
                alert('Failed to play station. Please try again.');
            }
        }

        // Show playlist selector for adding a Radio Browser station
        async function showPlaylistSelectorForRadioBrowser(station) {
            if (!window.currentUser || !window.currentUser.id) {
                alert('Please sign in to add stations to playlists');
                return;
            }

            try {
                // Ensure playlists are loaded
                if (playlists.length === 0) {
                    await loadPlaylists();
                }

                if (playlists.length === 0) {
                    alert('You have no playlists. Create a playlist first!');
                    return;
                }

                // Update modal title
                playlistSelectorTitle.textContent = `Add "${station.name}" to Playlist`;

                // Render playlist options
                playlistSelectorList.innerHTML = playlists.map(playlist => `
                    <div
                        class="playlist-selector-item"
                        data-playlist-id="${playlist.id}"
                        data-station='${JSON.stringify(station).replace(/'/g, '&apos;')}'
                        style="padding: 16px; margin-bottom: 8px; border: 2px solid var(--border-color); border-radius: 12px; background: var(--card-bg); cursor: pointer; transition: all 0.2s;"
                        onmouseover="this.style.borderColor='var(--accent-color)'; this.style.background='var(--hover-bg, var(--card-bg))';"
                        onmouseout="this.style.borderColor='var(--border-color)'; this.style.background='var(--card-bg)';"
                    >
                        <div style="font-weight: 600; font-size: 16px; color: var(--text-primary);">${playlist.name}</div>
                        ${playlist.description ? `<div style="font-size: 13px; color: var(--text-secondary); margin-top: 4px;">${playlist.description}</div>` : ''}
                    </div>
                `).join('');

                // Add click listeners to playlist items
                document.querySelectorAll('.playlist-selector-item').forEach(item => {
                    item.addEventListener('click', async () => {
                        const playlistId = item.getAttribute('data-playlist-id');
                        const stationData = JSON.parse(item.getAttribute('data-station'));

                        try {
                            // Add station to external_stations table first
                            const externalStationId = await addExternalStation(stationData);

                            // Add to the selected playlist
                            await addStationToPlaylist(playlistId, null, externalStationId);

                            const selectedPlaylist = playlists.find(p => p.id === playlistId);
                            alert(`Successfully added "${stationData.name}" to playlist "${selectedPlaylist.name}"!`);

                            // Close modal
                            playlistSelectorModal.classList.remove('active');
                        } catch (error) {
                            console.error('Error adding station to playlist:', error);
                            alert('Failed to add station to playlist. Please try again.');
                        }
                    });
                });

                // Show modal
                playlistSelectorModal.classList.add('active');
            } catch (error) {
                console.error('Error showing playlist selector:', error);
                alert('Failed to load playlists. Please try again.');
            }
        }

        // Show playlist selector for the current playing station
        async function showPlaylistSelectorForCurrentStation() {
            if (!currentStation) {
                alert('No station is currently selected');
                return;
            }

            if (!window.currentUser || !window.currentUser.id) {
                alert('Please sign in to add stations to playlists');
                return;
            }

            try {
                // Ensure playlists are loaded
                if (playlists.length === 0) {
                    await loadPlaylists();
                }

                if (playlists.length === 0) {
                    alert('You have no playlists. Create a playlist first!');
                    return;
                }

                // Update modal title
                playlistSelectorTitle.textContent = `Add "${currentStation.name}" to Playlist`;

                // Determine if this is an external station or curated station
                const isExternal = currentStation.is_external || false;
                const stationId = isExternal ? null : currentStation.id;
                const externalId = isExternal ? currentStation.external_id : null;

                // Render playlist options
                playlistSelectorList.innerHTML = playlists.map(playlist => `
                    <div
                        class="playlist-selector-item"
                        data-playlist-id="${playlist.id}"
                        data-station-id="${stationId || ''}"
                        data-external-id="${externalId || ''}"
                        data-is-external="${isExternal}"
                        style="padding: 16px; margin-bottom: 8px; border: 2px solid var(--border-color); border-radius: 12px; background: var(--card-bg); cursor: pointer; transition: all 0.2s;"
                        onmouseover="this.style.borderColor='var(--accent-color)'; this.style.background='var(--hover-bg, var(--card-bg))';"
                        onmouseout="this.style.borderColor='var(--border-color)'; this.style.background='var(--card-bg)';"
                    >
                        <div style="font-weight: 600; font-size: 16px; color: var(--text-primary);">${playlist.name}</div>
                        ${playlist.description ? `<div style="font-size: 13px; color: var(--text-secondary); margin-top: 4px;">${playlist.description}</div>` : ''}
                    </div>
                `).join('');

                // Add click listeners to playlist items
                document.querySelectorAll('.playlist-selector-item').forEach(item => {
                    item.addEventListener('click', async () => {
                        const playlistId = item.getAttribute('data-playlist-id');
                        const isExt = item.getAttribute('data-is-external') === 'true';
                        const stId = item.getAttribute('data-station-id');
                        const extId = item.getAttribute('data-external-id');

                        try {
                            // Add to the selected playlist
                            if (isExt) {
                                // External station - use external_id
                                await addStationToPlaylist(playlistId, null, extId);
                            } else {
                                // Curated station - use station_id
                                await addStationToPlaylist(playlistId, stId);
                            }

                            const selectedPlaylist = playlists.find(p => p.id === playlistId);
                            alert(`Successfully added "${currentStation.name}" to playlist "${selectedPlaylist.name}"!`);

                            // Close modal
                            playlistSelectorModal.classList.remove('active');
                        } catch (error) {
                            console.error('Error adding station to playlist:', error);
                            alert('Failed to add station to playlist. Please try again.');
                        }
                    });
                });

                // Show modal
                playlistSelectorModal.classList.add('active');
            } catch (error) {
                console.error('Error showing playlist selector:', error);
                alert('Failed to load playlists. Please try again.');
            }
        }

        // Legacy function - kept for backwards compatibility if needed
        async function addRadioBrowserStationToDatabase(station) {
            console.warn('addRadioBrowserStationToDatabase is deprecated. Use showPlaylistSelectorForRadioBrowser instead.');
            showPlaylistSelectorForRadioBrowser(station);
        }

        // ======================
        // DATABASE FUNCTIONS
        // ======================

        // ======================
        // EXTERNAL STATIONS (RADIO-BROWSER.INFO)
        // ======================

        // Add a Radio Browser station to external_stations table
        async function addExternalStation(station) {
            try {
                const externalStation = {
                    source: 'radio-browser',
                    external_id: station.stationuuid,
                    name: station.name,
                    url: station.url,
                    url_resolved: station.url_resolved,
                    favicon: station.favicon,
                    genres: station.tags ? station.tags.split(',').map(t => t.trim()).filter(t => t) : [],
                    country: station.country || null,
                    country_code: station.countrycode || null,
                    language: station.language || null,
                    bitrate: station.bitrate || null,
                    votes: station.votes || 0,
                    click_count: station.clickcount || 0,
                    codec: station.codec || null,
                    homepage: station.homepage || null,
                    metadata: {
                        state: station.state,
                        hls: station.hls,
                        lastcheckok: station.lastcheckok,
                        lastchecktime: station.lastchecktime
                    }
                };

                // Check if station already exists
                const { data: existing, error: checkError } = await supabase
                    .from('external_stations')
                    .select('id')
                    .eq('source', 'radio-browser')
                    .eq('external_id', station.stationuuid)
                    .maybeSingle();

                if (checkError && checkError.code !== 'PGRST116') {
                    console.error('Error checking existing station:', checkError);
                    throw checkError;
                }

                if (existing) {
                    console.log('External station already exists, returning existing ID:', existing.id);
                    return existing.id;
                }

                // Insert new external station
                const { data, error } = await supabase
                    .from('external_stations')
                    .insert([externalStation])
                    .select('id')
                    .single();

                if (error) {
                    console.error('Error adding external station:', error);
                    throw error;
                }

                console.log('External station added successfully:', data.id);
                return data.id;
            } catch (error) {
                console.error('Error in addExternalStation:', error);
                throw error;
            }
        }

        // Get external station by ID
        async function getExternalStation(externalStationId) {
            try {
                const { data, error } = await supabase
                    .from('external_stations')
                    .select('*')
                    .eq('id', externalStationId)
                    .single();

                if (error) throw error;

                // Convert to station format
                return {
                    id: data.id,
                    name: data.name,
                    url: data.url_resolved || data.url,
                    icon_url: data.icon_url || data.favicon || '',
                    genres: data.genres || [],
                    call_letters: '',
                    frequency: '',
                    country: data.country,
                    is_external: true,
                    external_id: data.id
                };
            } catch (error) {
                console.error('Error getting external station:', error);
                return null;
            }
        }

        // ======================
        // STATION HISTORY TRACKING
        // ======================
        
        // Generate a simple anonymous user ID for tracking
        // Track station click (works in both guest and authenticated mode)
        // Supports both internal stations (numeric ID) and external stations (UUID or object)
        async function trackStationClick(stationId, externalStationId = null) {
            // Skip tracking for temporary stations that don't have an ID
            if (!stationId && !externalStationId) {
                console.log('Skipping tracking for temporary station (no ID)');
                return;
            }

            if (window.isGuestMode) {
                // Guest mode - use localStorage only
                trackStationClickLocal(stationId, externalStationId);
            } else {
                // Authenticated - save to Supabase
                try {
                    const insertData = {
                        user_id: window.currentUser.id,
                        clicked_at: new Date().toISOString()
                    };

                    // Add either station_id or external_station_id
                    if (externalStationId) {
                        insertData.external_station_id = externalStationId;
                    } else {
                        insertData.station_id = stationId;
                    }

                    const { error } = await supabase
                        .from('station_history')
                        .insert(insertData);

                    if (error) {
                        console.error('Error tracking station click:', error);
                        trackStationClickLocal(stationId, externalStationId); // Fallback to local
                    } else {
                        console.log('Station click tracked successfully');
                    }
                } catch (error) {
                    console.error('Error tracking station click:', error);
                    trackStationClickLocal(stationId, externalStationId); // Fallback to local
                }
            }
        }

        // Track station click in local storage (guest mode or fallback)
        function trackStationClickLocal(stationId, externalStationId = null) {
            try {
                let history = JSON.parse(localStorage.getItem('station_history') || '[]');
                const record = {
                    clicked_at: new Date().toISOString()
                };

                // Add either station_id or external_station_id
                if (externalStationId) {
                    record.external_station_id = externalStationId;
                } else {
                    record.station_id = stationId;
                }

                history.push(record);
                if (history.length > 500) {
                    history = history.slice(-500);
                }
                localStorage.setItem('station_history', JSON.stringify(history));
            } catch (error) {
                console.error('Error tracking station click locally:', error);
            }
        }
        
        // Get most recent stations (works in both guest and authenticated mode)
        // Includes both internal and external (radio-browser) stations
        async function getMostRecentStations(limit = 10) {
            if (window.isGuestMode || !window.currentUser) {
                // Guest mode or not authenticated - use localStorage
                return getMostRecentStationsLocal(limit);
            } else {
                // Authenticated - use Supabase
                try {
                    const { data, error } = await supabase
                        .from('station_history')
                        .select('station_id, external_station_id, clicked_at, external_stations(*), radio_stations(*)')
                        .eq('user_id', window.currentUser.id)
                        .order('clicked_at', { ascending: false })
                        .limit(limit * 3);

                    if (error) throw error;

                    const recentStations = [];
                    const seenKeys = new Set();

                    for (const record of data) {
                        // Create unique key for internal or external station
                        const key = record.external_station_id
                            ? `ext-${record.external_station_id}`
                            : `int-${record.station_id}`;

                        if (!seenKeys.has(key)) {
                            seenKeys.add(key);

                            let station = null;
                            if (record.external_station_id && record.external_stations) {
                                // External station from radio-browser
                                const ext = record.external_stations;
                                station = {
                                    id: ext.id,
                                    name: ext.name,
                                    url: ext.url_resolved || ext.url,
                                    icon_url: ext.icon_url || ext.favicon || '',
                                    genres: ext.genres || [],
                                    call_letters: '',
                                    frequency: '',
                                    country: ext.country,
                                    is_external: true,
                                    external_id: ext.id
                                };
                            } else if (record.station_id) {
                                // Internal station
                                station = stations.find(s => s.id === record.station_id);
                            }

                            if (station) {
                                recentStations.push(station);
                                if (recentStations.length >= limit) break;
                            }
                        }
                    }

                    return recentStations;

                } catch (error) {
                    console.error('Error getting recent stations from database:', error);
                    return getMostRecentStationsLocal(limit);
                }
            }
        }
        
        // Get most recent stations from local storage (fallback)
        function getMostRecentStationsLocal(limit = 10) {
            try {
                const history = JSON.parse(localStorage.getItem('station_history') || '[]');
                
                const uniqueStationIds = [];
                const seenIds = new Set();
                
                for (let i = history.length - 1; i >= 0; i--) {
                    const stationId = history[i].station_id;
                    if (!seenIds.has(stationId)) {
                        seenIds.add(stationId);
                        uniqueStationIds.push(stationId);
                        if (uniqueStationIds.length >= limit) break;
                    }
                }
                
                return stations.filter(s => uniqueStationIds.includes(s.id))
                    .sort((a, b) => uniqueStationIds.indexOf(a.id) - uniqueStationIds.indexOf(b.id));
                
            } catch (error) {
                console.error('Error getting recent stations from local storage:', error);
                return [];
            }
        }
        
        // Get most played stations (works in both guest and authenticated mode)
        async function getMostPlayedStations(limit = 10) {
            if (window.isGuestMode || !window.currentUser) {
                // Guest mode or not authenticated - use localStorage
                return getMostPlayedStationsLocal(limit);
            } else {
                // Authenticated - use Supabase
                try {
                    const { data, error } = await supabase
                        .from('station_history')
                        .select('station_id')
                        .eq('user_id', window.currentUser.id);

                    if (error) throw error;

                    const counts = {};
                    data.forEach(record => {
                        counts[record.station_id] = (counts[record.station_id] || 0) + 1;
                    });

                    // Sort by count and get top station IDs (as numbers)
                    const sortedStationIds = Object.keys(counts)
                        .map(id => parseInt(id))
                        .sort((a, b) => counts[b] - counts[a])
                        .slice(0, limit);

                    return stations.filter(s => sortedStationIds.includes(s.id))
                        .sort((a, b) => counts[b.id] - counts[a.id]);

                } catch (error) {
                    console.error('Error getting most played stations from database:', error);
                    return getMostPlayedStationsLocal(limit);
                }
            }
        }
        
        // Get most played stations from local storage (fallback)
        function getMostPlayedStationsLocal(limit = 10) {
            try {
                const history = JSON.parse(localStorage.getItem('station_history') || '[]');

                const counts = {};
                history.forEach(record => {
                    counts[record.station_id] = (counts[record.station_id] || 0) + 1;
                });

                // Sort by count and get top station IDs (as numbers)
                const sortedStationIds = Object.keys(counts)
                    .map(id => parseInt(id))
                    .sort((a, b) => counts[b] - counts[a])
                    .slice(0, limit);

                return stations.filter(s => sortedStationIds.includes(s.id))
                    .sort((a, b) => counts[b.id] - counts[a.id]);

            } catch (error) {
                console.error('Error getting most played stations from local storage:', error);
                return [];
            }
        }

        // Fetch current metadata from a station's stream
        async function fetchStationCurrentMetadata(station) {
            return new Promise((resolve) => {
                // Timeout after 10 seconds
                const timeout = setTimeout(() => {
                    if (tempPlayer) {
                        try {
                            tempPlayer.stop();
                        } catch (e) {
                            console.log('Error stopping temp player:', e);
                        }
                    }
                    resolve(null);
                }, 10000);

                let tempPlayer = null;
                let metadataReceived = false;

                try {
                    // Get the standard quality URL
                    const rawUrl = station.url_standard || station.url;
                    if (!rawUrl) {
                        clearTimeout(timeout);
                        resolve(null);
                        return;
                    }

                    // Use CORS proxy (Cloudflare Worker)
                    const streamUrl = corsProxies[0].url(rawUrl);

                    tempPlayer = new IcecastMetadataPlayer(streamUrl, {
                        metadataTypes: ['icy', 'ogg'],
                        enableLogging: false,

                        onMetadata: (metadata) => {
                            if (metadataReceived) return; // Only process first metadata
                            metadataReceived = true;

                            clearTimeout(timeout);

                            // Stop and cleanup the player
                            if (tempPlayer) {
                                try {
                                    tempPlayer.stop();
                                } catch (e) {
                                    console.log('Error stopping temp player:', e);
                                }
                            }

                            // Parse metadata
                            if (metadata && metadata.StreamTitle) {
                                const streamTitle = metadata.StreamTitle;
                                let title = 'Unknown';
                                let artist = '';

                                // Helper function to clean metadata text (remove XML attributes from iHeart and similar stations)
                                function cleanMetadataText(text) {
                                    if (!text) return '';

                                    // First, check if the text starts with text="..." pattern and extract the value
                                    const textMatch = text.match(/^text=["']([^"']+)["']/i);
                                    if (textMatch) {
                                        return textMatch[1].trim();
                                    }

                                    // Otherwise, remove everything after common attribute patterns like text=", song_spot=", etc.
                                    // This matches patterns like: text="..." or attribute="value" or attribute='value'
                                    const cleaned = text.replace(/\s+(text|song_spot|spotInstanceId|length|MediaBaseId|TAID|TPID|cartcutId|amgArtworkURL|spEventID|[a-zA-Z_]+)=["'][^"']*["'].*$/i, '');
                                    return cleaned.trim();
                                }

                                // Check for structured format
                                const titleMatch = streamTitle.match(/title=["']([^"']+)["']/i);
                                const artistMatch = streamTitle.match(/artist=["']([^"']+)["']/i);

                                if (titleMatch || artistMatch) {
                                    title = titleMatch ? titleMatch[1].trim() : 'Unknown';
                                    artist = artistMatch ? artistMatch[1].trim() : '';
                                } else if (streamTitle.includes(' - ')) {
                                    const parts = streamTitle.split(' - ');
                                    artist = cleanMetadataText(parts[0].trim());
                                    title = cleanMetadataText(parts[1].trim());
                                } else {
                                    title = cleanMetadataText(streamTitle);
                                }

                                resolve({ title, artist });
                            } else {
                                resolve(null);
                            }
                        },

                        onError: (error) => {
                            clearTimeout(timeout);
                            if (tempPlayer) {
                                try {
                                    tempPlayer.stop();
                                } catch (e) {
                                    console.log('Error stopping temp player:', e);
                                }
                            }
                            resolve(null);
                        }
                    });

                    // Mute and start playback
                    if (tempPlayer.audioElement) {
                        tempPlayer.audioElement.volume = 0;
                        tempPlayer.audioElement.muted = true;
                        tempPlayer.play().catch(() => {
                            clearTimeout(timeout);
                            resolve(null);
                        });
                    } else {
                        setTimeout(() => {
                            if (tempPlayer && tempPlayer.audioElement) {
                                tempPlayer.audioElement.volume = 0;
                                tempPlayer.audioElement.muted = true;
                                tempPlayer.play().catch(() => {
                                    clearTimeout(timeout);
                                    resolve(null);
                                });
                            }
                        }, 500);
                    }
                } catch (error) {
                    clearTimeout(timeout);
                    console.log('Error fetching station metadata:', error);
                    resolve(null);
                }
            });
        }
        
        // Load stations from Supabase
        async function loadStations(forceRefresh = false) {
            try {
                console.log('loadStations called');
                const { data, error } = await supabase
                    .from('radio_stations')
                    .select('*')
                    .order('name');
                
                if (error) throw error;
                
                stations = data || [];
                console.log('Loaded stations:', stations.length);
                
                // Populate genre filter dropdown
                populateGenreFilter();
                
                // Re-apply search filter if there's a search term
                const searchTerm = stationSearch ? stationSearch.value.trim() : '';
                if (searchTerm) {
                    console.log('Applying search filter:', searchTerm);
                    filterStations(searchTerm);
                } else {
                    console.log('No search term, setting filteredStations');
                    filteredStations = [...stations];
                    renderStationList();
                }
                
                // Clear service worker cache if force refresh
                if (forceRefresh && 'serviceWorker' in navigator && navigator.serviceWorker.controller) {
                    navigator.serviceWorker.controller.postMessage({
                        type: 'CLEAR_CACHE'
                    });
                }
                
            } catch (error) {
                console.error('Error loading stations:', error);
                updateStatus('Error loading stations', 'error');
            }
        }
        
        // Load playlists from Supabase
        async function loadPlaylists(forceRefresh = false) {
            try {
                const { data, error } = await supabase
                    .from('playlists')
                    .select('*, playlist_items(count)')
                    .order('sort_order', { ascending: true, nullsFirst: false })
                    .order('created_at', { ascending: false });
                
                if (error) throw error;
                
                playlists = data || [];
                renderPlaylistsList();
                
                // Clear service worker cache if force refresh
                if (forceRefresh && 'serviceWorker' in navigator && navigator.serviceWorker.controller) {
                    navigator.serviceWorker.controller.postMessage({
                        type: 'CLEAR_CACHE'
                    });
                }
                
            } catch (error) {
                console.error('Error loading playlists:', error);
            }
        }
        
        // Load playlist stations (includes both internal and external stations)
        async function loadPlaylistStations(playlistId) {
            try {
                const { data, error } = await supabase
                    .from('playlist_items')
                    .select('*, radio_stations(*), external_stations(*)')
                    .eq('playlist_id', playlistId)
                    .order('created_at');

                if (error) throw error;

                playlistStations = data.map(item => {
                    if (item.external_stations) {
                        // External station from radio-browser
                        const ext = item.external_stations;
                        return {
                            id: ext.id,
                            name: ext.name,
                            url: ext.url_resolved || ext.url,
                            icon_url: ext.icon_url || ext.favicon || '',
                            genres: ext.genres || [],
                            call_letters: '',
                            frequency: '',
                            country: ext.country,
                            is_external: true,
                            external_id: ext.id
                        };
                    } else {
                        // Internal station
                        return item.radio_stations;
                    }
                });
                renderPlaylistStations();

            } catch (error) {
                console.error('Error loading playlist stations:', error);
            }
        }

        // Load overview modal with carousels
        async function loadOverviewModal() {
            // Load recent stations
            const recentStations = await getMostRecentStations(10);
            renderCarousel('recentTrack', recentStations, 'station');

            // Load most played stations
            const playedStations = await getMostPlayedStations(10);
            await renderMostPlayedList(playedStations);

            // Load playlists with their stations for collage
            await loadPlaylists();

            // Load stations for each playlist (for artwork collage)
            const playlistsWithStations = await Promise.all(playlists.map(async (playlist) => {
                try {
                    const { data, error } = await supabase
                        .from('playlist_items')
                        .select('*, radio_stations(*), external_stations(*)')
                        .eq('playlist_id', playlist.id)
                        .order('created_at')
                        .limit(4); // Only need first 4 for collage

                    if (error) throw error;

                    const stationsData = data ? data.map(item => {
                        if (item.external_stations) {
                            // External station from radio-browser
                            const ext = item.external_stations;
                            return {
                                id: ext.id,
                                name: ext.name,
                                url: ext.url_resolved || ext.url,
                                icon_url: ext.icon_url || ext.favicon || '',
                                genres: ext.genres || [],
                                call_letters: '',
                                frequency: '',
                                country: ext.country,
                                is_external: true,
                                external_id: ext.id
                            };
                        } else {
                            // Internal station
                            return item.radio_stations;
                        }
                    }) : [];

                    return {
                        ...playlist,
                        stations: stationsData
                    };
                } catch (error) {
                    console.error('Error loading playlist stations:', error);
                    return {
                        ...playlist,
                        stations: []
                    };
                }
            }));

            renderCarousel('playlistsTrack', playlistsWithStations, 'playlist');

            // Setup carousel navigation
            setupCarouselNavigation('recent', 'recentTrack', 'recentPrev', 'recentNext');
            setupCarouselNavigation('playlists', 'playlistsTrack', 'playlistsPrev', 'playlistsNext');

            // Load Explore section
            await loadExploreSection(recentStations, playedStations);
        }

        // Shuffle array using Fisher-Yates algorithm
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Load Explore section with genre-based recommendations
        async function loadExploreSection(recentStations, playedStations) {
            const exploreSection = document.getElementById('exploreSection');
            const becauseListenedSection = document.getElementById('becauseListenedSection');
            const becauseLikeSection = document.getElementById('becauseLikeSection');

            let hasExploreContent = false;

            // "Because you listened to" - based on most recent station
            if (recentStations && recentStations.length > 0) {
                const mostRecentStation = recentStations[0];
                if (mostRecentStation.genres && mostRecentStation.genres.length > 0) {
                    const genre = Array.isArray(mostRecentStation.genres) ? mostRecentStation.genres[0] : mostRecentStation.genres;

                    // Find stations with the same genre (excluding the recent station itself)
                    const filteredStations = stations.filter(station => {
                        if (station.id === mostRecentStation.id) return false;
                        if (!station.genres) return false;

                        if (Array.isArray(station.genres)) {
                            return station.genres.some(g =>
                                g.toLowerCase() === genre.toLowerCase()
                            );
                        } else if (typeof station.genres === 'string') {
                            return station.genres.toLowerCase().includes(genre.toLowerCase());
                        }
                        return false;
                    });
                    // Shuffle and take up to 10 stations
                    const sameGenreStations = shuffleArray(filteredStations).slice(0, 10);

                    if (sameGenreStations.length > 0) {
                        document.getElementById('becauseListenedTitle').textContent = `Because you listened to ${genre}`;
                        renderCarousel('becauseListenedTrack', sameGenreStations, 'station');
                        setupCarouselNavigation('becauseListened', 'becauseListenedTrack', 'becauseListenedPrev', 'becauseListenedNext');
                        becauseListenedSection.style.display = 'block';
                        hasExploreContent = true;
                    }
                }
            }

            // "Because you like" - based on most played station
            if (playedStations && playedStations.length > 0) {
                const mostPlayedStation = playedStations[0];
                if (mostPlayedStation.genres && mostPlayedStation.genres.length > 0) {
                    const genre = Array.isArray(mostPlayedStation.genres) ? mostPlayedStation.genres[0] : mostPlayedStation.genres;

                    // Find stations with the same genre (excluding the most played station itself and any from "Because you listened")
                    const filteredStations = stations.filter(station => {
                        if (station.id === mostPlayedStation.id) return false;
                        if (!station.genres) return false;

                        if (Array.isArray(station.genres)) {
                            return station.genres.some(g =>
                                g.toLowerCase() === genre.toLowerCase()
                            );
                        } else if (typeof station.genres === 'string') {
                            return station.genres.toLowerCase().includes(genre.toLowerCase());
                        }
                        return false;
                    });
                    // Shuffle and take up to 10 stations
                    const sameGenreStations = shuffleArray(filteredStations).slice(0, 10);

                    if (sameGenreStations.length > 0) {
                        document.getElementById('becauseLikeTitle').textContent = `Because you like ${genre}`;
                        renderCarousel('becauseLikeTrack', sameGenreStations, 'station');
                        setupCarouselNavigation('becauseLike', 'becauseLikeTrack', 'becauseLikePrev', 'becauseLikeNext');
                        becauseLikeSection.style.display = 'block';
                        hasExploreContent = true;
                    }
                }
            }

            // Show/hide the entire explore section based on whether we have any content
            exploreSection.style.display = hasExploreContent ? 'block' : 'none';
        }

        // Render carousel items
        function renderCarousel(trackId, items, type) {
            const track = document.getElementById(trackId);

            if (!items || items.length === 0) {
                track.innerHTML = '<div class="carousel-empty">No items to display</div>';
                return;
            }

            track.innerHTML = items.map((item, index) => {
                if (type === 'station') {
                    return `
                        <div class="carousel-item" data-station-id="${item.id}" data-station-index="${index}" data-is-external="${item.is_external || false}">
                            <div class="carousel-item-image">
                                ${item.icon_url ? `<img src="${escapeHtml(item.icon_url)}" alt="${escapeHtml(item.name)}" onerror="this.onerror=null; this.src='icons/icon-512x512.png'">` : '<span class="carousel-item-icon">üìª</span>'}
                            </div>
                            <div class="carousel-item-content">
                                <div class="carousel-item-title">${escapeHtml(item.name)}</div>
                            </div>
                        </div>
                    `;
                } else if (type === 'playlist') {
                    // Create a collage of station artworks
                    const stations = item.stations || [];
                    const stationIcons = stations.filter(s => s && s.icon_url).slice(0, 4);

                    let imageContent;
                    if (stationIcons.length === 0) {
                        // No stations with icons - show emoji
                        imageContent = '<span class="carousel-item-icon">üìã</span>';
                    } else if (stationIcons.length === 1) {
                        // Single station - show its icon
                        imageContent = `<img src="${escapeHtml(stationIcons[0].icon_url)}" alt="Playlist" onerror="this.onerror=null; this.src='icons/icon-512x512.png'">`;
                    } else {
                        // Multiple stations - create collage
                        imageContent = `
                            <div class="playlist-collage">
                                ${stationIcons.map(s => `
                                    <div class="playlist-collage-item">
                                        <img src="${escapeHtml(s.icon_url)}" alt="${escapeHtml(s.name)}" onerror="this.onerror=null; this.src='icons/icon-512x512.png'">
                                    </div>
                                `).join('')}
                            </div>
                        `;
                    }

                    return `
                        <div class="carousel-item" data-playlist-id="${item.id}">
                            <div class="carousel-item-image">
                                ${imageContent}
                            </div>
                            <div class="carousel-item-content">
                                <div class="carousel-item-title">${escapeHtml(item.name)}</div>
                            </div>
                        </div>
                    `;
                }
            }).join('');

            // Add click handlers
            track.querySelectorAll('.carousel-item').forEach(item => {
                item.addEventListener('click', () => {
                    if (type === 'station') {
                        const stationIndex = parseInt(item.dataset.stationIndex);
                        const station = items[stationIndex];
                        if (station) {
                            selectStation(station);
                            overviewModal.classList.remove('active');
                        }
                    } else if (type === 'playlist') {
                        const playlistId = item.dataset.playlistId; // Don't parseInt - IDs are UUIDs (strings)
                        openPlaylist(playlistId);
                        overviewModal.classList.remove('active');
                    }
                });
            });
        }

        // Render Most Played Stations as a list with currently playing song
        async function renderMostPlayedList(stations) {
            const listContainer = document.getElementById('playedStationsList');

            if (!stations || stations.length === 0) {
                listContainer.innerHTML = '<div class="stations-list-empty">No stations to display</div>';
                return;
            }

            // First render the list with loading states
            listContainer.innerHTML = stations.map((station, index) => {
                return `
                    <div class="station-list-item" data-station-id="${station.id}" data-station-index="${index}">
                        <div class="station-list-icon">
                            ${station.icon_url ? `<img src="${escapeHtml(station.icon_url)}" alt="${escapeHtml(station.name)}" onerror="this.onerror=null; this.src='icons/icon-512x512.png'">` : '<span class="station-list-icon-emoji">üìª</span>'}
                        </div>
                        <div class="station-list-content">
                            <div class="station-list-name">${escapeHtml(station.name)}</div>
                            <div class="station-list-metadata-loading">Loading current track...</div>
                        </div>
                    </div>
                `;
            }).join('');

            // Add click handlers
            listContainer.querySelectorAll('.station-list-item').forEach(item => {
                item.addEventListener('click', () => {
                    const stationIndex = parseInt(item.dataset.stationIndex);
                    const station = stations[stationIndex];
                    if (station) {
                        selectStation(station);
                        overviewModal.classList.remove('active');
                    }
                });
            });

            // Fetch metadata for each station in parallel
            stations.forEach(async (station, index) => {
                const metadata = await fetchStationCurrentMetadata(station);

                // Update the station's metadata display
                const stationElement = listContainer.querySelector(`[data-station-id="${station.id}"]`);
                if (!stationElement) return;

                const contentDiv = stationElement.querySelector('.station-list-content');
                if (!contentDiv) return;

                // Remove loading message
                const loadingDiv = contentDiv.querySelector('.station-list-metadata-loading');
                if (loadingDiv) {
                    loadingDiv.remove();
                }

                if (metadata && (metadata.title || metadata.artist)) {
                    // Add metadata display
                    const metadataDiv = document.createElement('div');
                    metadataDiv.className = 'station-list-metadata';
                    metadataDiv.innerHTML = `
                        <div class="station-list-now-playing">
                            ${metadata.artist ? `${escapeHtml(metadata.artist)} - ` : ''}${escapeHtml(metadata.title || 'Unknown')}
                        </div>
                    `;
                    contentDiv.appendChild(metadataDiv);
                } else {
                    // No metadata available
                    const emptyDiv = document.createElement('div');
                    emptyDiv.className = 'station-list-metadata-empty';
                    emptyDiv.textContent = 'No track info available';
                    contentDiv.appendChild(emptyDiv);
                }
            });
        }

        // Setup carousel navigation
        function setupCarouselNavigation(name, trackId, prevBtnId, nextBtnId) {
            const track = document.getElementById(trackId);
            const prevBtn = document.getElementById(prevBtnId);
            const nextBtn = document.getElementById(nextBtnId);

            const scrollAmount = 200; // pixels to scroll

            prevBtn.addEventListener('click', () => {
                track.scrollBy({ left: -scrollAmount, behavior: 'smooth' });
            });

            nextBtn.addEventListener('click', () => {
                track.scrollBy({ left: scrollAmount, behavior: 'smooth' });
            });

            // Update button states based on scroll position
            const updateButtonStates = () => {
                const hasOverflow = track.scrollWidth > track.clientWidth;

                if (!hasOverflow) {
                    // No scrolling needed - disable both buttons
                    prevBtn.disabled = true;
                    nextBtn.disabled = true;
                    return;
                }

                const isAtStart = track.scrollLeft <= 0;
                const isAtEnd = track.scrollLeft + track.clientWidth >= track.scrollWidth - 1;

                prevBtn.disabled = isAtStart;
                nextBtn.disabled = isAtEnd;
            };

            track.addEventListener('scroll', updateButtonStates);

            // Wait for DOM to be fully rendered before checking button states
            setTimeout(updateButtonStates, 100);
        }

        // Create playlist
        async function createPlaylist(name, description) {
            try {
                console.log('Creating playlist with:', { name, description });

                // Ensure user is authenticated
                if (!window.currentUser || !window.currentUser.id) {
                    throw new Error('You must be signed in to create playlists. Please sign in and try again.');
                }

                // Get the max sort_order to add new playlist at the end
                const maxSortOrder = playlists.length > 0
                    ? Math.max(...playlists.map(p => p.sort_order || 0))
                    : -1;

                const { data, error } = await supabase
                    .from('playlists')
                    .insert([{
                        name,
                        description,
                        sort_order: maxSortOrder + 1,
                        user_id: window.currentUser.id
                    }])
                    .select();
                
                if (error) {
                    console.error('Supabase error:', error);
                    console.error('Error details:', JSON.stringify(error, null, 2));
                    throw error;
                }
                
                console.log('Playlist created successfully:', data);
                await loadPlaylists(true); // Force refresh to bypass cache
                alert('Playlist created successfully!');
                return data && data.length > 0 ? data[0] : null;
                
            } catch (error) {
                console.error('Error creating playlist:', error);
                alert(`Failed to create playlist: ${error.message || 'Unknown error'}\n\nCheck browser console for details.`);
                return null;
            }
        }
        
        // Update playlist
        async function updatePlaylist(id, name, description) {
            try {
                console.log('Updating playlist:', { id, name, description });
                
                const { data, error } = await supabase
                    .from('playlists')
                    .update({ name, description })
                    .eq('id', id)
                    .select();
                
                if (error) {
                    console.error('Supabase error:', error);
                    console.error('Error details:', JSON.stringify(error, null, 2));
                    throw error;
                }
                
                console.log('Playlist updated successfully:', data);
                await loadPlaylists(true); // Force refresh to bypass cache
                alert('Playlist updated successfully!');
                
            } catch (error) {
                console.error('Error updating playlist:', error);
                alert(`Failed to update playlist: ${error.message || 'Unknown error'}\n\nCheck browser console for details.`);
            }
        }
        
        // Delete playlist
        async function deletePlaylist(id) {
            try {
                // First delete all playlist items
                await supabase
                    .from('playlist_items')
                    .delete()
                    .eq('playlist_id', id);
                
                // Then delete the playlist
                const { error } = await supabase
                    .from('playlists')
                    .delete()
                    .eq('id', id);
                
                if (error) throw error;
                
                await loadPlaylists(true); // Force refresh to bypass cache
                
            } catch (error) {
                console.error('Error deleting playlist:', error);
                alert('Failed to delete playlist');
            }
        }
        
        // Add station to playlist (supports both internal and external stations)
        async function addStationToPlaylist(playlistId, stationId, externalStationId = null) {
            try {
                // Check if station is already in playlist
                let existingQuery = supabase
                    .from('playlist_items')
                    .select('id')
                    .eq('playlist_id', playlistId);

                if (externalStationId) {
                    existingQuery = existingQuery.eq('external_station_id', externalStationId);
                } else {
                    existingQuery = existingQuery.eq('station_id', stationId);
                }

                const { data: existing } = await existingQuery.maybeSingle();

                if (existing) {
                    alert('Station is already in this playlist');
                    return;
                }

                // Insert with either station_id or external_station_id
                const insertData = { playlist_id: playlistId };
                if (externalStationId) {
                    insertData.external_station_id = externalStationId;
                } else {
                    insertData.station_id = stationId;
                }

                const { error } = await supabase
                    .from('playlist_items')
                    .insert([insertData]);

                if (error) throw error;

                await loadPlaylists(true); // Force refresh to bypass cache

            } catch (error) {
                console.error('Error adding station to playlist:', error);
                alert('Failed to add station to playlist');
            }
        }
        
        // Remove station from playlist
        async function removeStationFromPlaylist(playlistId, stationId) {
            try {
                const { error } = await supabase
                    .from('playlist_items')
                    .delete()
                    .eq('playlist_id', playlistId)
                    .eq('station_id', stationId);
                
                if (error) throw error;
                
                await loadPlaylistStations(playlistId);
                await loadPlaylists(true); // Force refresh to bypass cache
                
            } catch (error) {
                console.error('Error removing station from playlist:', error);
                alert('Failed to remove station from playlist');
            }
        }
        
        // Create station
        async function createStation(stationData) {
            try {
                console.log('Creating station with:', stationData);
                
                const { data, error } = await supabase
                    .from('radio_stations')
                    .insert([stationData])
                    .select();
                
                if (error) {
                    console.error('Supabase error:', error);
                    console.error('Error details:', JSON.stringify(error, null, 2));
                    throw error;
                }
                
                console.log('Station created successfully:', data);
                await loadStations(true); // Force refresh to bypass cache
                alert('Station created successfully!');
                return data && data.length > 0 ? data[0] : null;
                
            } catch (error) {
                console.error('Error creating station:', error);
                alert(`Failed to create station: ${error.message || 'Unknown error'}\n\nCheck browser console for details.`);
                return null;
            }
        }
        
        // Update station
        async function updateStation(id, stationData) {
            try {
                console.log('Updating station:', { id, stationData });
                
                const { data, error } = await supabase
                    .from('radio_stations')
                    .update(stationData)
                    .eq('id', id)
                    .select();
                
                if (error) {
                    console.error('Supabase error:', error);
                    console.error('Error details:', JSON.stringify(error, null, 2));
                    throw error;
                }
                
                console.log('Station updated successfully:', data);
                await loadStations(true); // Force refresh to bypass cache
                alert('Station updated successfully!');
                
            } catch (error) {
                console.error('Error updating station:', error);
                console.error('Error message:', error.message);
                console.error('Error details:', error.details);
                console.error('Error hint:', error.hint);
                alert(`Failed to update station: ${error.message || 'Unknown error'}\n\nCheck browser console for details.`);
            }
        }
        
        // Delete station
        async function deleteStation(id) {
            try {
                // First delete from all playlists
                await supabase
                    .from('playlist_items')
                    .delete()
                    .eq('station_id', id);
                
                // Then delete the station
                const { error } = await supabase
                    .from('radio_stations')
                    .delete()
                    .eq('id', id);
                
                if (error) throw error;
                
                await loadStations(true); // Force refresh to bypass cache
                await loadPlaylists(true); // Force refresh to bypass cache
                
            } catch (error) {
                console.error('Error deleting station:', error);
                alert('Failed to delete station');
            }
        }
        
        // ======================
        // UI FUNCTIONS
        // ======================
        
        // Render playlists list
        async function renderPlaylistsList() {
            // Apply grid view class if in grid mode
            if (playlistViewMode === 'grid') {
                playlistsList.classList.add('grid-view');
            } else {
                playlistsList.classList.remove('grid-view');
            }

            // Start with empty content (history buttons moved to main page)
            let htmlContent = '';

            if (playlists.length === 0) {
                htmlContent += `
                    <div class="empty-state">
                        <div class="empty-state-icon">üìù</div>
                        <div class="empty-state-text">No custom playlists yet. Create one to organize your favorite stations!</div>
                    </div>
                `;
            } else {
                // Load stations for each playlist (for artwork collage)
                const playlistsWithStations = await Promise.all(playlists.map(async (playlist) => {
                    try {
                        const { data, error } = await supabase
                            .from('playlist_items')
                            .select('*, radio_stations(*)')
                            .eq('playlist_id', playlist.id)
                            .order('created_at')
                            .limit(4); // Only need first 4 for collage

                        if (error) throw error;

                        return {
                            ...playlist,
                            stations: data ? data.map(item => item.radio_stations) : []
                        };
                    } catch (error) {
                        console.error('Error loading playlist stations:', error);
                        return {
                            ...playlist,
                            stations: []
                        };
                    }
                }));

                htmlContent += playlistsWithStations.map(playlist => {
                    const count = playlist.playlist_items?.[0]?.count || 0;

                    // Create a collage of station artworks (same logic as carousel)
                    const stations = playlist.stations || [];
                    const stationIcons = stations.filter(s => s && s.icon_url).slice(0, 4);

                    let iconContent;
                    if (stationIcons.length === 0) {
                        // No stations with icons - show emoji
                        iconContent = 'üéµ';
                    } else if (stationIcons.length === 1) {
                        // Single station - show its icon as image
                        iconContent = `<img src="${escapeHtml(stationIcons[0].icon_url)}" alt="Playlist" onerror="this.onerror=null; this.src='icons/icon-512x512.png'">`;
                    } else {
                        // Multiple stations - create collage
                        iconContent = `
                            <div class="playlist-collage">
                                ${stationIcons.map(s => `
                                    <div class="playlist-collage-item">
                                        <img src="${escapeHtml(s.icon_url)}" alt="${escapeHtml(s.name)}" onerror="this.onerror=null; this.src='icons/icon-512x512.png'">
                                    </div>
                                `).join('')}
                            </div>
                        `;
                    }

                    return `
                        <div class="playlist-item" data-id="${playlist.id}" draggable="true">
                            <div class="playlist-drag-handle">‚ãÆ‚ãÆ</div>
                            <div class="playlist-icon">${iconContent}</div>
                            <div class="playlist-info">
                                <div class="playlist-name">${escapeHtml(playlist.name)}</div>
                                <div class="playlist-count">${count} ${count === 1 ? 'station' : 'stations'}</div>
                            </div>
                            <button class="playlist-menu-btn" data-id="${playlist.id}">‚ãÆ</button>
                            <div class="playlist-dropdown">
                                <div class="dropdown-item" data-action="view" data-playlist-id="${playlist.id}">
                                    <span>üìª</span> View Playlist
                                </div>
                                <div class="dropdown-item" data-action="edit" data-playlist-id="${playlist.id}">
                                    <span>‚úèÔ∏è</span> Rename
                                </div>
                                <div class="dropdown-divider"></div>
                                <div class="dropdown-item danger" data-action="delete" data-playlist-id="${playlist.id}">
                                    <span>üóëÔ∏è</span> Delete
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
            }

            playlistsList.innerHTML = htmlContent;
            
            // Add event listeners for playlist items
            document.querySelectorAll('.playlist-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    if (!e.target.closest('.playlist-menu-btn') && !e.target.closest('.playlist-dropdown')) {
                        const id = item.dataset.id;
                        openPlaylist(id);
                    }
                });
            });
            
            // Setup drag and drop for reordering playlists
            setupPlaylistDragAndDrop();
            
            // Add event listeners for playlist menu buttons
            document.querySelectorAll('.playlist-menu-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const dropdown = btn.nextElementSibling;
                    
                    // Close all other dropdowns
                    document.querySelectorAll('.playlist-dropdown').forEach(d => {
                        if (d !== dropdown) d.classList.remove('active');
                    });
                    
                    dropdown.classList.toggle('active');
                });
            });
            
            // Add event listeners for dropdown items
            document.querySelectorAll('.playlist-dropdown .dropdown-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const action = item.dataset.action;
                    const playlistId = item.dataset.playlistId;
                    
                    if (!action || !playlistId) return;
                    
                    // Close dropdown
                    item.closest('.playlist-dropdown').classList.remove('active');
                    
                    if (action === 'view') {
                        openPlaylist(playlistId);
                    } else if (action === 'edit') {
                        editPlaylist(playlistId);
                    } else if (action === 'delete') {
                        confirmDeletePlaylist(playlistId);
                    }
                });
            });
        }
        
        // Setup drag and drop for playlist reordering
        function setupPlaylistDragAndDrop() {
            const playlistItems = document.querySelectorAll('.playlist-item');
            let draggedElement = null;
            let draggedIndex = null;
            
            playlistItems.forEach((item, index) => {
                // Drag start
                item.addEventListener('dragstart', (e) => {
                    draggedElement = item;
                    draggedIndex = index;
                    item.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/html', item.innerHTML);
                });
                
                // Drag end
                item.addEventListener('dragend', (e) => {
                    item.classList.remove('dragging');
                    // Remove drag-over class from all items
                    document.querySelectorAll('.playlist-item').forEach(i => {
                        i.classList.remove('drag-over');
                    });
                });
                
                // Drag over
                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    
                    if (item !== draggedElement) {
                        item.classList.add('drag-over');
                    }
                });
                
                // Drag leave
                item.addEventListener('dragleave', (e) => {
                    item.classList.remove('drag-over');
                });
                
                // Drop
                item.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    item.classList.remove('drag-over');
                    
                    if (draggedElement !== item) {
                        // Get the indices
                        const dropIndex = Array.from(playlistItems).indexOf(item);
                        
                        // Reorder the playlists array
                        const movedPlaylist = playlists.splice(draggedIndex, 1)[0];
                        playlists.splice(dropIndex, 0, movedPlaylist);
                        
                        // Update sort orders and save to database
                        await updatePlaylistOrder();
                        
                        // Re-render the list
                        renderPlaylistsList();
                    }
                });
            });
        }
        
        // Update playlist order in database
        async function updatePlaylistOrder() {
            try {
                // Update each playlist with its new sort_order
                const updates = playlists.map((playlist, index) => {
                    return supabase
                        .from('playlists')
                        .update({ sort_order: index })
                        .eq('id', playlist.id);
                });
                
                await Promise.all(updates);
                console.log('Playlist order updated successfully');
                
            } catch (error) {
                console.error('Error updating playlist order:', error);
                alert('Failed to save playlist order');
            }
        }
        
        // Render station list
        function renderStationList() {
            console.log('renderStationList called', {
                stationList: stationList,
                filteredStationsLength: filteredStations.length,
                stationsLength: stations.length
            });
            
            if (!stationList) {
                console.error('stationList element not found!');
                return;
            }
            
            // Apply grid view class if in grid mode
            if (stationViewMode === 'grid') {
                stationList.classList.add('grid-view');
            } else {
                stationList.classList.remove('grid-view');
            }
            
            if (filteredStations.length === 0) {
                stationList.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üìª</div>
                        <div class="empty-state-text">
                            ${stations.length === 0 ? 'No stations yet. Add one to get started!' : 'No stations found.'}
                        </div>
                    </div>
                `;
                return;
            }
            
            stationList.innerHTML = filteredStations.map(station => {
                // Handle genres as array or string
                const genresDisplay = station.genres && Array.isArray(station.genres)
                    ? station.genres.join(', ')
                    : (station.genres || 'No genres');
                
                // Build station details (call letters and frequency)
                const detailsParts = [];
                if (station.call_letters) {
                    detailsParts.push(station.call_letters);
                }
                if (station.frequency) {
                    detailsParts.push(station.frequency);
                }
                const detailsDisplay = detailsParts.length > 0 ? detailsParts.join(' ‚Ä¢ ') : '';

                // Check if current user is admin
                const isAdmin = window.currentUser && window.currentUser.email && window.currentUser.email.split('@')[0] === 'keith.e.dragon';

                return `
                <div class="station-item ${currentStation?.id === station.id ? 'selected' : ''}" data-id="${station.id}">
                    ${station.icon_url ?
                        `<img src="${station.icon_url}" class="station-icon" alt="${escapeHtml(station.name)}" onerror="this.onerror=null; this.src='icons/icon-512x512.png'">` :
                        `<div class="station-icon">üìª</div>`
                    }
                    <div class="station-info">
                        <div class="station-name">${escapeHtml(station.name)}</div>
                        ${detailsDisplay ? `<div class="station-details">${escapeHtml(detailsDisplay)}</div>` : ''}
                        <div class="station-genres">${escapeHtml(genresDisplay)}</div>
                    </div>
                    <button class="station-menu-btn" data-id="${station.id}">‚ãÆ</button>
                    <div class="station-dropdown">
                        <div class="dropdown-submenu">
                            <div class="dropdown-item">
                                <span>‚ûï</span> Add to Playlist
                            </div>
                            <div class="dropdown-submenu-content">
                                ${playlists.length === 0 ? 
                                    `<div class="dropdown-item" data-action="create-playlist">
                                        <span>üìù</span> Create Playlist
                                    </div>` :
                                    playlists.map(playlist => `
                                        <div class="dropdown-item" data-action="add-to-playlist" data-playlist-id="${playlist.id}" data-station-id="${station.id}">
                                            ${escapeHtml(playlist.name)}
                                        </div>
                                    `).join('')
                                }
                            </div>
                        </div>
                        ${isAdmin ? `
                        <div class="dropdown-divider"></div>
                        <div class="dropdown-item" data-action="edit-station" data-station-id="${station.id}">
                            <span>‚úèÔ∏è</span> Edit Station
                        </div>
                        <div class="dropdown-item danger" data-action="delete-station" data-station-id="${station.id}">
                            <span>üóëÔ∏è</span> Delete Station
                        </div>
                        ` : ''}
                    </div>
                </div>
            `;
            }).join('');
            
            // Add event listeners
            document.querySelectorAll('.station-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    if (!e.target.closest('.station-menu-btn') && !e.target.closest('.station-dropdown')) {
                        const id = parseInt(item.dataset.id);
                        const station = stations.find(s => s.id === id);
                        selectStation(station);
                    }
                });
            });
            
            // Add event listeners for menu buttons
            document.querySelectorAll('.station-menu-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const dropdown = btn.nextElementSibling;
                    
                    // Close all other dropdowns
                    document.querySelectorAll('.station-dropdown').forEach(d => {
                        if (d !== dropdown) d.classList.remove('active');
                    });
                    
                    dropdown.classList.toggle('active');
                });
            });
            
            // Add hover/click listeners for submenus (mobile support)
            document.querySelectorAll('.dropdown-submenu').forEach(submenu => {
                // Support click for mobile
                submenu.addEventListener('click', (e) => {
                    if (e.target.closest('.dropdown-item') && !e.target.dataset.action) {
                        e.stopPropagation();
                        submenu.classList.toggle('active');
                    }
                });
                
                // Close submenu when clicking on backdrop (mobile)
                submenu.addEventListener('click', (e) => {
                    if (e.target === submenu && submenu.classList.contains('active')) {
                        submenu.classList.remove('active');
                    }
                });
            });
            
            // Add event listeners for dropdown actions
            document.querySelectorAll('.station-dropdown .dropdown-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const action = item.dataset.action;
                    
                    if (action === 'create-playlist') {
                        showPlaylistForm();
                        document.querySelectorAll('.station-dropdown').forEach(d => d.classList.remove('active'));
                    } else if (action === 'add-to-playlist') {
                        const playlistId = item.dataset.playlistId;
                        const stationId = parseInt(item.dataset.stationId);
                        addToPlaylist(playlistId, stationId);
                        document.querySelectorAll('.station-dropdown').forEach(d => d.classList.remove('active'));
                    } else if (action === 'edit-station') {
                        const stationId = parseInt(item.dataset.stationId);
                        editStation(stationId);
                        document.querySelectorAll('.station-dropdown').forEach(d => d.classList.remove('active'));
                    } else if (action === 'delete-station') {
                        const stationId = parseInt(item.dataset.stationId);
                        confirmDeleteStation(stationId);
                        document.querySelectorAll('.station-dropdown').forEach(d => d.classList.remove('active'));
                    }
                });
            });
        }
        
        // Render playlist stations
        async function renderPlaylistStations() {
            // Apply grid view class if in grid mode
            if (playlistStationViewMode === 'grid') {
                playlistStationList.classList.add('grid-view');
            } else {
                playlistStationList.classList.remove('grid-view');
            }

            if (playlistStations.length === 0) {
                playlistStationList.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üìª</div>
                        <div class="empty-state-text">No stations in this playlist yet.</div>
                    </div>
                `;
                return;
            }

            playlistStationList.innerHTML = playlistStations.map((station, index) => {
                // Handle genres as array or string
                const genresDisplay = station.genres && Array.isArray(station.genres)
                    ? station.genres.join(', ')
                    : (station.genres || 'No genres');

                // Build station details (call letters and frequency)
                const detailsParts = [];
                if (station.call_letters) {
                    detailsParts.push(station.call_letters);
                }
                if (station.frequency) {
                    detailsParts.push(station.frequency);
                }
                const detailsDisplay = detailsParts.length > 0 ? detailsParts.join(' ‚Ä¢ ') : '';

                return `
                <div class="station-item ${currentStation?.id === station.id ? 'selected' : ''}" data-id="${station.id}" data-station-index="${index}">
                    ${station.icon_url ?
                        `<img src="${station.icon_url}" class="station-icon" alt="${escapeHtml(station.name)}" onerror="this.onerror=null; this.src='icons/icon-512x512.png'">` :
                        `<div class="station-icon">üìª</div>`
                    }
                    <div class="station-info">
                        <div class="station-name">${escapeHtml(station.name)}</div>
                        ${detailsDisplay ? `<div class="station-details">${escapeHtml(detailsDisplay)}</div>` : ''}
                        <div class="station-now-playing-loading">Loading current track...</div>
                    </div>
                    <button class="station-menu-btn" data-id="${station.id}">‚ãÆ</button>
                    <div class="station-dropdown">
                        <div class="dropdown-item danger" data-action="remove-from-playlist" data-playlist-id="${currentPlaylist.id}" data-station-id="${station.id}">
                            <span>‚ûñ</span> Remove from Playlist
                        </div>
                    </div>
                </div>
            `;
            }).join('');
            
            // Add event listeners
            document.querySelectorAll('#playlistStationList .station-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    if (!e.target.closest('.station-menu-btn') && !e.target.closest('.station-dropdown')) {
                        const stationIndex = parseInt(item.dataset.stationIndex);
                        const station = playlistStations[stationIndex];
                        if (station) {
                            selectStation(station);
                            closePlaylistModal.click();
                        }
                    }
                });
            });
            
            // Add event listeners for menu buttons
            document.querySelectorAll('#playlistStationList .station-menu-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const dropdown = btn.nextElementSibling;
                    
                    // Close all other dropdowns
                    document.querySelectorAll('#playlistStationList .station-dropdown').forEach(d => {
                        if (d !== dropdown) d.classList.remove('active');
                    });
                    
                    dropdown.classList.toggle('active');
                });
            });
            
            // Add event listeners for dropdown actions
            document.querySelectorAll('#playlistStationList .dropdown-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const action = item.dataset.action;

                    if (action === 'remove-from-playlist') {
                        const playlistId = item.dataset.playlistId;
                        const stationId = parseInt(item.dataset.stationId);
                        removeFromPlaylist(playlistId, stationId);
                        document.querySelectorAll('.station-dropdown').forEach(d => d.classList.remove('active'));
                    }
                });
            });

            // Fetch metadata for each station in parallel
            playlistStations.forEach(async (station) => {
                const metadata = await fetchStationCurrentMetadata(station);

                // Update the station's metadata display
                const stationElement = playlistStationList.querySelector(`[data-id="${station.id}"]`);
                if (!stationElement) return;

                const infoDiv = stationElement.querySelector('.station-info');
                if (!infoDiv) return;

                // Remove loading message
                const loadingDiv = infoDiv.querySelector('.station-now-playing-loading');
                if (loadingDiv) {
                    loadingDiv.remove();
                }

                if (metadata && (metadata.title || metadata.artist)) {
                    // Add metadata display (replaces the genres div position)
                    const genresDiv = infoDiv.querySelector('.station-genres');
                    if (genresDiv) {
                        genresDiv.remove();
                    }

                    const metadataDiv = document.createElement('div');
                    metadataDiv.className = 'station-now-playing';
                    metadataDiv.innerHTML = `
                        <span class="now-playing-label">‚ô™</span> ${metadata.artist ? `${escapeHtml(metadata.artist)} - ` : ''}${escapeHtml(metadata.title || 'Unknown')}
                    `;
                    infoDiv.appendChild(metadataDiv);
                } else {
                    // No metadata available - show genres
                    const genresDiv = infoDiv.querySelector('.station-genres');
                    if (!genresDiv) {
                        const newGenresDiv = document.createElement('div');
                        newGenresDiv.className = 'station-genres';
                        const genresDisplay = station.genres && Array.isArray(station.genres)
                            ? station.genres.join(', ')
                            : (station.genres || 'No genres');
                        newGenresDiv.textContent = genresDisplay;
                        infoDiv.appendChild(newGenresDiv);
                    }
                }
            });
        }
        
        // Select station
        function selectStation(station) {
            currentStation = station;

            // Reset fallback attempt flag for new station
            hasFallbackAttempted = false;

            // Reset to Live mode for new station
            if (playbackMode === 'simple') {
                playbackMode = 'live';
                if (currentModeText) currentModeText.textContent = 'Live';
            }

            // Track the station click - handle both internal and external stations
            if (station.is_external) {
                trackStationClick(null, station.id); // For external stations, id is the external_station_id
            } else {
                trackStationClick(station.id);
            }
            
            // Update display - keep it visible along with buttons
            stationDisplay.style.display = 'flex';
            // Don't hide the selector buttons anymore
            // stationSelectorButtons.style.display = 'none';
            stationDisplayIcon.src = station.icon_url || '';
            stationDisplayIcon.style.display = station.icon_url ? 'block' : 'none';
            // Add error handler to fallback to StreamWave logo
            stationDisplayIcon.onerror = function() {
                this.onerror = null;
                this.src = 'icons/icon-512x512.png';
            };
            stationDisplayName.textContent = station.name;
            
            
            // Display call letters and frequency
            const detailsParts = [];
            if (station.call_letters) {
                detailsParts.push(station.call_letters);
            }
            if (station.frequency) {
                detailsParts.push(station.frequency);
            }
            const stationDisplayDetails = document.getElementById('stationDisplayDetails');
            stationDisplayDetails.textContent = detailsParts.length > 0 ? detailsParts.join(' ‚Ä¢ ') : '';
            stationDisplayDetails.style.display = detailsParts.length > 0 ? 'block' : 'none';
            
            // Update quality button availability
            updateQualityButtons(station);
            
            playPauseBtn.disabled = false;

            // Stop current stream if playing before starting new one
            if (player) {
                player.stop();
            }

            // Stop and clean up simple audio player if it's playing
            if (simpleAudioPlayer) {
                simpleAudioPlayer.pause();
                simpleAudioPlayer.src = '';
                // Remove all event listeners by cloning and replacing
                const oldPlayer = simpleAudioPlayer;
                simpleAudioPlayer = oldPlayer.cloneNode(true);
                oldPlayer.remove();
            }

            // Stop metadata-only player when switching stations
            stopMetadataOnlyPlayer();

            // Reset playing state
            isPlaying = false;
            isPaused = false;
            updatePlayPauseButton(false);

            // Close modals
            browseStationsModal.classList.remove('active');
            playlistsModal.classList.remove('active');
            playlistModal.classList.remove('active');
            
            // Re-render lists to update selected state
            renderStationList();
            if (currentPlaylist) {
                renderPlaylistStations();
            }


            // Automatically start playing the station (but not if we're casting)
            if (!castSession) {
                setTimeout(() => {
                    playPauseBtn.click();
                }, 100);
            } else {
                // If casting, restart metadata-only player for the new station
                stopMetadataOnlyPlayer();
                setTimeout(() => {
                    startMetadataOnlyPlayer();
                }, 500);
            }

            // Update Cast if currently casting
            updateCastMedia();


        }
        
        // Update quality button availability based on station URLs
        function updateQualityButtons(station) {
            const lowBtn = document.querySelector('.quality-option-modal[data-quality="low"]');
            const standardBtn = document.querySelector('.quality-option-modal[data-quality="standard"]');
            const highBtn = document.querySelector('.quality-option-modal[data-quality="high"]');

            let hasMultipleQualities = false;

            // Enable/disable based on available URLs
            if (station.url_low) {
                lowBtn.classList.remove('disabled');
                hasMultipleQualities = true;
            } else {
                lowBtn.classList.add('disabled');
                if (selectedQuality === 'low') {
                    // Switch to standard if low was selected but not available
                    selectedQuality = 'standard';
                    standardBtn.classList.add('selected');
                    lowBtn.classList.remove('selected');
                }
            }

            // Standard URL is always required, so always enabled
            standardBtn.classList.remove('disabled');

            if (station.url_high) {
                highBtn.classList.remove('disabled');
                hasMultipleQualities = true;
            } else {
                highBtn.classList.add('disabled');
                if (selectedQuality === 'high') {
                    // Switch to standard if high was selected but not available
                    selectedQuality = 'standard';
                    standardBtn.classList.add('selected');
                    highBtn.classList.remove('selected');
                }
            }

            // Update select quality button in station info modal
            const selectQualityBtn = document.getElementById('selectQualityBtn');
            if (selectQualityBtn) {
                if (hasMultipleQualities) {
                    selectQualityBtn.classList.remove('disabled');
                } else {
                    selectQualityBtn.classList.add('disabled');
                }
            }
        }
        
        // Open playlist
        function openPlaylist(id) {
            currentPlaylist = playlists.find(p => p.id === id);
            if (!currentPlaylist) return;

            lastOpenedModal = { type: 'playlist', id: id };
            playlistModalTitle.textContent = currentPlaylist.name;
            loadPlaylistStations(id);

            playlistsModal.classList.remove('active');
            playlistModal.classList.add('active');
        }
        
        // Show playlist form
        function showPlaylistForm(id = null) {
            editingPlaylistId = id;
            
            if (id) {
                const playlist = playlists.find(p => p.id === id);
                if (!playlist) return;
                
                playlistFormTitle.textContent = 'Edit Playlist';
                playlistName.value = playlist.name;
                playlistDescription.value = playlist.description || '';
            } else {
                playlistFormTitle.textContent = 'Create Playlist';
                playlistName.value = '';
                playlistDescription.value = '';
            }
            
            // Close dropdowns
            document.querySelectorAll('.playlist-dropdown, .station-dropdown').forEach(d => {
                d.classList.remove('active');
            });
            
            playlistFormModal.classList.add('active');
        }
        
        // Edit playlist
        function editPlaylist(id) {
            showPlaylistForm(id);
        }
        
        // Confirm delete playlist
        function confirmDeletePlaylist(id) {
            const playlist = playlists.find(p => p.id === id);
            if (!playlist) return;
            
            if (confirm(`Are you sure you want to delete "${playlist.name}"?`)) {
                deletePlaylist(id);
            }
        }
        
        // Add station to playlist
        function addToPlaylist(playlistId, stationId) {
            addStationToPlaylist(playlistId, stationId);
            
            // Close dropdown
            document.querySelectorAll('.station-dropdown').forEach(d => {
                d.classList.remove('active');
            });
        }
        
        // Remove station from playlist
        function removeFromPlaylist(playlistId, stationId) {
            if (confirm('Remove this station from the playlist?')) {
                removeStationFromPlaylist(playlistId, stationId);
            }
            
            // Close dropdown
            document.querySelectorAll('.station-dropdown').forEach(d => {
                d.classList.remove('active');
            });
        }
        
        // Show station form
        function showStationForm(id = null) {
            editingStationId = id;
            
            if (id) {
                const station = stations.find(s => s.id === id);
                if (!station) return;
                
                stationFormTitle.textContent = 'Edit Station';
                document.getElementById('stationFormName').value = station.name;
                document.getElementById('stationFormUrl').value = station.url;
                document.getElementById('stationFormUrlLow').value = station.url_low || '';
                document.getElementById('stationFormUrlHigh').value = station.url_high || '';
                document.getElementById('stationFormCallLetters').value = station.call_letters || '';
                document.getElementById('stationFormFrequency').value = station.frequency || '';
                document.getElementById('stationFormWebsiteUrl').value = station.website_url || '';
                document.getElementById('stationFormDescription').value = station.description || '';
                
                // Convert genres array to comma-separated string for display
                // If genres is ["News", "Talk"], display as "News, Talk"
                const genresDisplay = station.genres && Array.isArray(station.genres) 
                    ? station.genres.join(', ') 
                    : (station.genres || '');
                document.getElementById('stationFormGenres').value = genresDisplay;
                
                document.getElementById('stationFormIconUrl').value = station.icon_url || '';
            } else {
                stationFormTitle.textContent = 'Add Station';
                stationForm.reset();
                
                // Reset image preview
                stationFormIconUpload.value = '';
                iconPreview.style.display = 'none';
                uploadIconBtn.textContent = 'üì∑ Choose Image';
                uploadIconBtn.style.background = '';
            }
            
            // Close dropdowns
            document.querySelectorAll('.station-dropdown').forEach(d => {
                d.classList.remove('active');
            });
            
            stationFormModal.classList.add('active');
        }

        // Show station form pre-populated with Radio Browser data for curation
        function showStationFormForCuration(radioBrowserStation) {
            // Reset the editing ID since this is a new station
            editingStationId = null;

            // Set form title
            stationFormTitle.textContent = 'Add Station to Curated Stations';

            // Populate form with Radio Browser data
            document.getElementById('stationFormName').value = radioBrowserStation.name || '';
            document.getElementById('stationFormUrl').value = radioBrowserStation.url_resolved || radioBrowserStation.url || '';
            document.getElementById('stationFormUrlLow').value = '';
            document.getElementById('stationFormUrlHigh').value = '';
            document.getElementById('stationFormCallLetters').value = '';
            document.getElementById('stationFormFrequency').value = '';
            document.getElementById('stationFormWebsiteUrl').value = radioBrowserStation.homepage || '';
            document.getElementById('stationFormDescription').value = '';

            // Convert tags to genres (Radio Browser uses tags, we use genres)
            const tags = radioBrowserStation.tags || '';
            const genresArray = tags.split(',').map(tag => tag.trim()).filter(tag => tag.length > 0);
            document.getElementById('stationFormGenres').value = genresArray.join(', ');

            // Set icon URL
            document.getElementById('stationFormIconUrl').value = radioBrowserStation.favicon || '';

            // Reset image preview
            stationFormIconUpload.value = '';
            iconPreview.style.display = 'none';
            uploadIconBtn.textContent = 'üì∑ Choose Image';
            uploadIconBtn.style.background = '';

            // Close any dropdowns
            document.querySelectorAll('.station-dropdown').forEach(d => {
                d.classList.remove('active');
            });

            // Close Radio Browser modal and open station form modal
            radioDatabaseModal.classList.remove('active');
            stationFormModal.classList.add('active');
        }

        // Edit station
        function editStation(id) {
            showStationForm(id);
        }
        
        // Confirm delete station
        function confirmDeleteStation(id) {
            const station = stations.find(s => s.id === id);
            if (!station) return;
            
            if (confirm(`Are you sure you want to delete "${station.name}"?`)) {
                deleteStation(id);
            }
        }
        
        // Filter stations
        function filterStations(query) {
            console.log('filterStations called with query:', query);
            console.log('Total stations:', stations.length);
            const lowerQuery = query.toLowerCase();
            filteredStations = stations.filter(station => {
                // First apply genre filter
                if (currentGenreFilter) {
                    let hasGenre = false;
                    if (Array.isArray(station.genres)) {
                        hasGenre = station.genres.some(g => 
                            g.toLowerCase() === currentGenreFilter.toLowerCase()
                        );
                    } else if (typeof station.genres === 'string') {
                        hasGenre = station.genres.toLowerCase().includes(currentGenreFilter.toLowerCase());
                    }
                    if (!hasGenre) return false;
                }
                
                // Then apply search query if present
                if (!query) return true;

                // Search across all station fields
                const nameMatch = station.name && station.name.toLowerCase().includes(lowerQuery);
                const callLettersMatch = station.call_letters && station.call_letters.toLowerCase().includes(lowerQuery);
                const frequencyMatch = station.frequency && station.frequency.toLowerCase().includes(lowerQuery);
                const websiteMatch = station.website_url && station.website_url.toLowerCase().includes(lowerQuery);
                const descriptionMatch = station.description && station.description.toLowerCase().includes(lowerQuery);

                // Handle genres as array or string
                let genresMatch = false;
                if (station.genres) {
                    if (Array.isArray(station.genres)) {
                        // Search in array elements
                        genresMatch = station.genres.some(genre =>
                            genre.toLowerCase().includes(lowerQuery)
                        );
                    } else if (typeof station.genres === 'string') {
                        // Handle as string (for backward compatibility)
                        genresMatch = station.genres.toLowerCase().includes(lowerQuery);
                    }
                }

                return nameMatch || genresMatch || callLettersMatch || frequencyMatch || websiteMatch || descriptionMatch;
            });
            console.log('Filtered stations:', filteredStations.length);
            sortStations(); // Apply current sort after filtering
        }
        
        // Populate genre filter dropdown
        function populateGenreFilter() {
            const genreSet = new Set();
            const genreCounts = {};
            
            stations.forEach(station => {
                if (Array.isArray(station.genres)) {
                    station.genres.forEach(genre => {
                        if (genre && genre.trim()) {
                            genreSet.add(genre.trim());
                            genreCounts[genre.trim()] = (genreCounts[genre.trim()] || 0) + 1;
                        }
                    });
                } else if (typeof station.genres === 'string' && station.genres.trim()) {
                    // Split by comma for string genres
                    station.genres.split(',').forEach(genre => {
                        const trimmedGenre = genre.trim();
                        if (trimmedGenre) {
                            genreSet.add(trimmedGenre);
                            genreCounts[trimmedGenre] = (genreCounts[trimmedGenre] || 0) + 1;
                        }
                    });
                }
            });
            
            const sortedGenres = Array.from(genreSet).sort();
            
            // Build dropdown HTML
            let dropdownHTML = `
                <div class="filter-option active" data-genre="">
                    <span class="filter-option-icon">üéµ</span>
                    <span>All Genres</span>
                    <span class="genre-count">${stations.length}</span>
                </div>
            `;
            
            sortedGenres.forEach(genre => {
                dropdownHTML += `
                    <div class="filter-option" data-genre="${escapeHtml(genre)}">
                        <span class="filter-option-icon">üéµ</span>
                        <span>${escapeHtml(genre)}</span>
                        <span class="genre-count">${genreCounts[genre]}</span>
                    </div>
                `;
            });
            
            genreDropdown.innerHTML = dropdownHTML;
            
            // Re-attach event listeners
            genreDropdown.querySelectorAll('.filter-option').forEach(option => {
                option.addEventListener('click', (e) => {
                    e.stopPropagation();
                    
                    // Update active state
                    genreDropdown.querySelectorAll('.filter-option').forEach(opt => opt.classList.remove('active'));
                    option.classList.add('active');
                    
                    // Update genre filter
                    currentGenreFilter = option.dataset.genre;
                    
                    // Update button label
                    genreLabel.textContent = option.dataset.genre || 'All Genres';
                    
                    // Show/hide clear button
                    const clearBtn = document.getElementById('clearSearchBtn');
                    if (currentGenreFilter !== '' || stationSearch.value.trim() !== '') {
                        clearBtn.style.display = 'flex';
                    } else {
                        clearBtn.style.display = 'none';
                    }
                    
                    // Close dropdown
                    genreDropdown.classList.remove('active');
                    
                    // Apply filter
                    filterStations(stationSearch.value);
                });
            });
        }
        
        // Sort stations based on current sort method
        async function sortStations() {
            console.log('Sorting stations by:', currentSortMethod);
            
            switch(currentSortMethod) {
                case 'name-asc':
                    filteredStations.sort((a, b) => 
                        (a.name || '').localeCompare(b.name || '')
                    );
                    break;
                    
                case 'name-desc':
                    filteredStations.sort((a, b) => 
                        (b.name || '').localeCompare(a.name || '')
                    );
                    break;
                    
                case 'most-played':
                    const mostPlayed = await getMostPlayedStations(filteredStations.length);
                    const mostPlayedIds = mostPlayed.map(s => s.id);
                    filteredStations.sort((a, b) => {
                        const indexA = mostPlayedIds.indexOf(a.id);
                        const indexB = mostPlayedIds.indexOf(b.id);
                        if (indexA === -1 && indexB === -1) return 0;
                        if (indexA === -1) return 1;
                        if (indexB === -1) return -1;
                        return indexA - indexB;
                    });
                    break;
                    
                case 'recent':
                    const recentStations = await getMostRecentStations(filteredStations.length);
                    const recentIds = recentStations.map(s => s.id);
                    filteredStations.sort((a, b) => {
                        const indexA = recentIds.indexOf(a.id);
                        const indexB = recentIds.indexOf(b.id);
                        if (indexA === -1 && indexB === -1) return 0;
                        if (indexA === -1) return 1;
                        if (indexB === -1) return -1;
                        return indexA - indexB;
                    });
                    break;
            }
            
            renderStationList();
        }
        
        // Update status
        function updateStatus(message, type = 'default') {
            statusText.textContent = message;
            statusDot.className = 'status-dot';
            
            if (type === 'playing') {
                statusDot.classList.add('playing');
            } else if (type === 'error') {
                statusDot.classList.add('error');
            } else if (type === 'loading') {
                statusDot.classList.add('loading');
            }
        }
        
        // Escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // ======================
        // EVENT LISTENERS
        // ======================

        // Open overview modal from overview button
        overviewBtn.addEventListener('click', () => {
            overviewModal.classList.add('active');
            loadOverviewModal();
        });

        // Open hamburger menu modal
        hamburgerMenuBtn.addEventListener('click', () => {
            hamburgerMenuModal.classList.add('active');
        });

        // Close hamburger menu modal
        closeHamburgerMenuModal.addEventListener('click', () => {
            hamburgerMenuModal.classList.remove('active');
        });

        // Settings menu button - opens settings modal
        settingsMenuBtn.addEventListener('click', () => {
            hamburgerMenuModal.classList.remove('active');
            settingsModal.classList.add('active');
        });

        // Browse menu button - opens browse stations modal
        browseMenuBtn.addEventListener('click', () => {
            console.log('Opening browse stations modal', {
                stationsLength: stations.length,
                filteredStationsLength: filteredStations.length
            });
            hamburgerMenuModal.classList.remove('active');
            lastOpenedModal = 'browse';
            browseStationsModal.classList.add('active');
            // Ensure stations are displayed
            if (stations.length > 0) {
                if (filteredStations.length === 0) {
                    console.log('Initializing filteredStations');
                    filteredStations = [...stations];
                }
                console.log('Calling renderStationList');
                renderStationList();
            } else {
                console.log('No stations loaded yet');
            }
        });

        // Station display click - open station info modal
        stationDisplay.addEventListener('click', () => {
            stationInfoModal.classList.add('active');
        });

        // Close playlists modal
        closePlaylistsModal.addEventListener('click', () => {
            playlistsModal.classList.remove('active');
        });

        // Close browse stations modal
        closeBrowseStationsModal.addEventListener('click', () => {
            browseStationsModal.classList.remove('active');
        });

        // Close overview modal
        closeOverviewModal.addEventListener('click', () => {
            overviewModal.classList.remove('active');
        });

        // Close station info modal
        closeStationInfoModal.addEventListener('click', () => {
            stationInfoModal.classList.remove('active');
        });

        // Add current station to playlist button
        document.getElementById('addCurrentStationToPlaylistBtn').addEventListener('click', () => {
            showPlaylistSelectorForCurrentStation();
        });

        // Select quality button in station info modal
        document.getElementById('selectQualityBtn').addEventListener('click', () => {
            // Don't open modal if button is disabled
            if (document.getElementById('selectQualityBtn').classList.contains('disabled')) {
                return;
            }
            qualityModal.classList.add('active');
        });

        // Play random station button
        document.getElementById('playRandomStationBtn').addEventListener('click', () => {
            if (stations.length === 0) {
                alert('No stations available');
                return;
            }

            // Select a random station from all available stations
            const randomIndex = Math.floor(Math.random() * stations.length);
            const randomStation = stations[randomIndex];

            // Close the overview modal
            overviewModal.classList.remove('active');

            // Select and play the random station
            selectStation(randomStation);
            setTimeout(() => {
                playPauseBtn.click();
            }, 100);
        });

        // Close settings modal
        closeSettingsModal.addEventListener('click', () => {
            settingsModal.classList.remove('active');
        });

        // Close settings modal when clicking outside
        settingsModal.addEventListener('click', (e) => {
            if (e.target === settingsModal) {
                settingsModal.classList.remove('active');
            }
        });

        // Radio Database button - opens radio database modal
        radioDatabaseBtn.addEventListener('click', () => {
            hamburgerMenuModal.classList.remove('active');
            radioDatabaseModal.classList.add('active');
            // Clear input values
            radioDatabaseCountry.value = '';
            radioDatabaseLanguage.value = '';
            radioDatabaseTag.value = '';
            // Load filters if not already loaded (checking if only default option exists)
            if (radioDatabaseCountry.children.length === 1) {
                loadRadioBrowserFilters();
            }
        });

        // Close Radio Database modal
        closeRadioDatabaseModal.addEventListener('click', () => {
            radioDatabaseModal.classList.remove('active');
        });

        // Close Radio Database modal when clicking outside
        radioDatabaseModal.addEventListener('click', (e) => {
            if (e.target === radioDatabaseModal) {
                radioDatabaseModal.classList.remove('active');
            }
        });

        // Close Playlist Selector modal
        closePlaylistSelectorModal.addEventListener('click', () => {
            playlistSelectorModal.classList.remove('active');
        });

        // Close Playlist Selector modal when clicking outside
        playlistSelectorModal.addEventListener('click', (e) => {
            if (e.target === playlistSelectorModal) {
                playlistSelectorModal.classList.remove('active');
            }
        });

        // Radio Database search button
        radioDatabaseSearchBtn.addEventListener('click', () => {
            searchRadioBrowser();
        });

        // Radio Database search on Enter key
        radioDatabaseSearchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                searchRadioBrowser();
            }
        });

        // Radio Database sort change - restart search from page 1
        radioDatabaseSort.addEventListener('change', () => {
            if (radioDatabaseResults.children.length > 0 && !radioDatabaseResults.textContent.includes('Enter search criteria')) {
                searchRadioBrowser(1);
            }
        });

        // Radio Database pagination - Previous button
        radioDatabasePrevBtn.addEventListener('click', () => {
            if (radioDatabaseCurrentPage > 1) {
                searchRadioBrowser(radioDatabaseCurrentPage - 1);
            }
        });

        // Radio Database pagination - Next button
        radioDatabaseNextBtn.addEventListener('click', () => {
            searchRadioBrowser(radioDatabaseCurrentPage + 1);
        });

        // Close hamburger menu modal when clicking outside
        hamburgerMenuModal.addEventListener('click', (e) => {
            if (e.target === hamburgerMenuModal) {
                hamburgerMenuModal.classList.remove('active');
            }
        });

        // Auth button handler
        authBtn.addEventListener('click', () => {
            if (window.isAuthenticated && window.currentUser) {
                // User is signed in, call sign out
                if (window.signOut) {
                    window.signOut();
                }
            } else {
                // User is not signed in, redirect to login
                window.location.href = 'login.html';
            }
        });
        
        // Auto-fallback toggle
        const autoFallbackCheckbox = document.getElementById('autoFallback');
        autoFallbackCheckbox.addEventListener('change', (e) => {
            autoFallbackEnabled = e.target.checked;
            console.log('Auto-fallback:', autoFallbackEnabled ? 'enabled' : 'disabled');
        });
        
        // Toggle Chromecast section
        // ======================
        // GOOGLE CAST SDK INTEGRATION
        // ======================
        
        let castSession = null;
        let castPlayer = null;
        let currentMediaInfo = null;
        let castInitRetries = 0;
        const MAX_CAST_RETRIES = 10;
        
        // Initialize Cast SDK
        window['__onGCastApiAvailable'] = function(isAvailable) {
            console.log('Cast API available:', isAvailable);
            if (isAvailable) {
                // Wait a bit for SDK to fully load, then try initialization
                setTimeout(initializeCastApi, 500);
            }
        };
        
        function initializeCastApi() {
            try {
                // Check if cast object exists
                if (typeof cast === 'undefined' || typeof chrome === 'undefined' || 
                    typeof chrome.cast === 'undefined' || typeof cast.framework === 'undefined') {
                    
                    console.log('Cast SDK not fully loaded yet, retrying...', castInitRetries + 1);
                    
                    // Retry if not reached max attempts
                    if (castInitRetries < MAX_CAST_RETRIES) {
                        castInitRetries++;
                        setTimeout(initializeCastApi, 500);
                        return;
                    } else {
                        console.error('Cast SDK failed to load after', MAX_CAST_RETRIES, 'attempts');
                        return;
                    }
                }
                
                // Temporarily testing with default receiver
                const applicationID = chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID;
                // Your custom: const applicationID = '60D76D0F';
                
                console.log('Attempting to initialize Cast with App ID:', applicationID);
                
                const castContext = cast.framework.CastContext.getInstance();
                castContext.setOptions({
                    receiverApplicationId: applicationID,
                    autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED
                });
                
                console.log('Cast context options set successfully');
                
                // Add event listeners
                castContext.addEventListener(
                    cast.framework.CastContextEventType.SESSION_STATE_CHANGED,
                    onSessionStateChanged
                );
                
                castContext.addEventListener(
                    cast.framework.CastContextEventType.CAST_STATE_CHANGED,
                    onCastStateChanged
                );
                
                console.log('‚úÖ Cast SDK initialized successfully');
                
                // Check cast state
                setTimeout(() => {
                    const castState = castContext.getCastState();
                    console.log('Cast state:', castState);
                    console.log('Cast state values - NO_DEVICES:', cast.framework.CastState.NO_DEVICES_AVAILABLE, 
                                'NOT_CONNECTED:', cast.framework.CastState.NOT_CONNECTED,
                                'CONNECTING:', cast.framework.CastState.CONNECTING,
                                'CONNECTED:', cast.framework.CastState.CONNECTED);
                    
                    // Check if button exists and is visible
                    const button = document.getElementById('castButton');
                    console.log('Cast button element:', button);
                    if (button) {
                        const styles = window.getComputedStyle(button);
                        console.log('Cast button display:', styles.display);
                        console.log('Cast button visibility:', styles.visibility);
                    }
                }, 2000);
            } catch (error) {
                console.error('Error initializing Cast SDK:', error);
                
                // Retry on error
                if (castInitRetries < MAX_CAST_RETRIES) {
                    castInitRetries++;
                    setTimeout(initializeCastApi, 1000);
                }
            }
        }
        
        function onSessionStateChanged(event) {
            console.log('Cast session state changed:', event.sessionState);
            
            // Log detailed error information for failed sessions
            if (event.sessionState === cast.framework.SessionState.SESSION_START_FAILED) {
                console.error('Cast session failed to start!');
                console.error('Error code:', event.errorCode);
                console.error('Error details:', event);
                
                // Common error codes
                const errorMessages = {
                    'cancel': 'User cancelled the connection',
                    'timeout': 'Connection timed out - check if receiver URL is accessible',
                    'api_not_initialized': 'Cast API not initialized properly',
                    'invalid_parameter': 'Invalid receiver application ID or parameters',
                    'receiver_unavailable': 'Receiver application not available - check if it\'s published',
                    'session_error': 'Session error - receiver may have failed to load',
                    'channel_error': 'Communication channel error',
                    'load_media_failed': 'Failed to load media'
                };
                
                const errorMsg = errorMessages[event.errorCode] || 'Unknown error: ' + event.errorCode;
                console.error('Error explanation:', errorMsg);
                updateStatus('Cast failed: ' + errorMsg, 'error');
                return;
            }
            
            try {
                switch (event.sessionState) {
                    case cast.framework.SessionState.SESSION_STARTED:
                        castSession = cast.framework.CastContext.getInstance().getCurrentSession();
                        console.log('Cast session started');

                        // Stop local playback
                        if (player) {
                            try {
                                player.stop();
                            } catch (e) {}
                        }
                        if (simpleAudioPlayer && !simpleAudioPlayer.paused) {
                            simpleAudioPlayer.pause();
                        }

                        updateStatus('Cast connected...', 'playing');

                        // Start metadata-only player to continue receiving metadata locally
                        startMetadataOnlyPlayer();

                        // Add update listener to keep button in sync with Cast state
                        castSession.addUpdateListener((isAlive) => {
                            if (isAlive && castSession) {
                                const media = castSession.getMediaSession();
                                if (media) {
                                    const playerState = media.playerState;
                                    console.log('Cast media status changed:', playerState);
                                    if (playerState === 'PLAYING' || playerState === 'BUFFERING') {
                                        updatePlayPauseButton(true);
                                        updateStatus('Casting...', 'playing');
                                    } else if (playerState === 'PAUSED') {
                                        updatePlayPauseButton(false);
                                        updateStatus('Paused (Casting)', 'stopped');
                                    } else if (playerState === 'IDLE') {
                                        updatePlayPauseButton(false);
                                    }
                                }
                            }
                        });

                        // Wait a moment for session to fully establish before loading media
                        setTimeout(() => {
                            if (currentStation && castSession) {
                                console.log('Loading media to cast after delay');
                                loadMediaToCast();
                            }
                        }, 1000);

                        break;
                        
                    case cast.framework.SessionState.SESSION_ENDED:
                        castSession = null;
                        console.log('Cast session ended');
                        updateStatus('Not connected', '');

                        // Stop metadata-only player
                        stopMetadataOnlyPlayer();

                        // Resume local playback if desired
                        if (currentStation && isPlaying) {
                            setTimeout(() => {
                                playPauseBtn.click();
                            }, 300);
                        }
                        break;
                }
            } catch (error) {
                console.error('Error in session state change:', error);
            }
        }
        
        function onCastStateChanged(event) {
            console.log('Cast state changed:', event.castState);
        }
        
        function loadMediaToCast() {
            if (!castSession || !currentStation) {
                return;
            }
            
            try {
                // Get stream URL based on quality
                const streamUrl = selectedQuality === 'low' && currentStation.url_low ? currentStation.url_low :
                                 selectedQuality === 'high' && currentStation.url_high ? currentStation.url_high :
                                 currentStation.url;
                
                console.log('Loading media to Cast:', {
                    streamUrl,
                    stationName: currentStation.name,
                    hasIcon: !!currentStation.icon_url
                });
                
                // Create media info
                const mediaInfo = new chrome.cast.media.MediaInfo(streamUrl, 'audio/mpeg');
                
                // Set metadata
                const metadata = new chrome.cast.media.GenericMediaMetadata();
                metadata.title = currentStation.name;
                metadata.subtitle = 'Live Radio Stream';
                
                if (currentStation.icon_url) {
                    metadata.images = [new chrome.cast.Image(currentStation.icon_url)];
                }
                
                mediaInfo.metadata = metadata;
                mediaInfo.streamType = chrome.cast.media.StreamType.LIVE;
                
                // Load media
                const request = new chrome.cast.media.LoadRequest(mediaInfo);
                request.autoplay = true;
                
                console.log('Sending load request to Cast...');
                
                castSession.loadMedia(request).then(
                    () => {
                        console.log('‚úÖ Media loaded successfully to Cast');
                        currentMediaInfo = mediaInfo;
                        updateStatus('Casting...', 'playing');
                        // Enable play/pause button and set to pause state (casting is playing)
                        playPauseBtn.disabled = false;
                        updatePlayPauseButton(true);
                        isPlaying = true;
                    },
                    (errorCode) => {
                        console.error('‚ùå Failed to load media:', errorCode);
                        updateStatus('Cast error: ' + errorCode, 'error');
                    }
                );
            } catch (error) {
                console.error('‚ùå Error loading media to cast:', error);
                updateStatus('Cast error: ' + error.message, 'error');
            }
        }
        
        // Expose function to update Cast media when station changes
        function updateCastMedia() {
            if (castSession && currentStation) {
                loadMediaToCast();
            }
        }
        
        // Update Cast metadata with current track info
        function updateCastMetadata(title, artist, artworkUrl) {
            if (!castSession) {
                return;
            }

            try {
                const media = castSession.getMediaSession();
                if (!media) {
                    // Media hasn't loaded yet, retry in a moment
                    setTimeout(() => {
                        const retryMedia = castSession ? castSession.getMediaSession() : null;
                        if (retryMedia) {
                            updateCastMetadata(title, artist, artworkUrl);
                        }
                    }, 1500);
                    return;
                }

                // Create new metadata
                const metadata = new chrome.cast.media.MusicTrackMediaMetadata();
                metadata.songName = title || currentStation.name;
                metadata.artist = artist || 'Live Radio Stream';
                metadata.albumName = currentStation.name;

                // Use album art if available, otherwise station icon
                if (artworkUrl) {
                    metadata.images = [new chrome.cast.Image(artworkUrl)];
                } else if (currentStation.icon_url) {
                    metadata.images = [new chrome.cast.Image(currentStation.icon_url)];
                }

                // Update the media info
                const mediaInfo = media.media;
                mediaInfo.metadata = metadata;

                // Send the update
                const request = new chrome.cast.media.QueueUpdateItemsRequest([{
                    media: mediaInfo
                }]);

                console.log('‚úÖ Updated Cast metadata:', { title, artist, artworkUrl });

            } catch (error) {
                console.log('Could not update Cast metadata:', error);
            }
        }

        // Calculate exponential backoff delay for metadata player retries
        function getMetadataPlayerRetryDelay(retryCount) {
            // Exponential backoff: 2s, 4s, 8s, 16s, 30s (capped at 30s)
            const baseDelay = 2000; // 2 seconds
            const delay = Math.min(baseDelay * Math.pow(2, retryCount), 30000);
            return delay;
        }

        // Reset metadata player retry counter (call on successful playback)
        function resetMetadataPlayerRetries() {
            metadataOnlyPlayerRetryCount = 0;
            metadataOnlyPlayerErrorCount = 0;
            console.log('‚úÖ Metadata player retry and error counters reset');
        }

        // Clear any pending metadata player retry timeout
        function clearMetadataPlayerRetryTimeout() {
            if (metadataOnlyPlayerRetryTimeoutId) {
                clearTimeout(metadataOnlyPlayerRetryTimeoutId);
                metadataOnlyPlayerRetryTimeoutId = null;
            }
        }

        // Clear any pending metadata player waiting timeout
        function clearMetadataPlayerWaitingTimeout() {
            if (metadataOnlyPlayerWaitingTimeoutId) {
                clearTimeout(metadataOnlyPlayerWaitingTimeoutId);
                metadataOnlyPlayerWaitingTimeoutId = null;
            }
        }

        // Set a timeout to detect if metadata player is stuck waiting
        function setMetadataPlayerWaitingTimeout() {
            clearMetadataPlayerWaitingTimeout();
            metadataOnlyPlayerWaitingTimeoutId = setTimeout(() => {
                console.error('‚ùå Metadata player stuck in waiting state for too long (30s). Stopping to prevent infinite retries.');
                metadataOnlyPlayerErrorCount++;

                // Stop the player after too many consecutive timeout errors
                if (metadataOnlyPlayerErrorCount >= metadataOnlyPlayerMaxErrors) {
                    console.error(`‚ùå Metadata player reached ${metadataOnlyPlayerMaxErrors} timeout errors. Giving up.`);
                    if (metadataOnlyPlayer) {
                        metadataOnlyPlayerIntentionalStop = true; // Mark as intentional to prevent restart
                        try {
                            metadataOnlyPlayer.stop();
                        } catch (e) {
                            console.log('Error stopping metadata player:', e);
                        }
                        metadataOnlyPlayer = null;
                        metadataOnlyPlayerUrl = null;
                    }
                    metadataOnlyPlayerErrorCount = 0; // Reset for next attempt
                    clearMetadataPlayerRetryTimeout();
                } else {
                    // Try to restart the player
                    if (metadataOnlyPlayer) {
                        try {
                            metadataOnlyPlayer.stop();
                        } catch (e) {
                            console.log('Error stopping metadata player:', e);
                        }
                    }
                }
            }, metadataOnlyPlayerWaitingTimeout);
        }

        // Clear any pending metadata player refresh interval
        function clearMetadataPlayerRefreshInterval() {
            if (metadataOnlyPlayerRefreshIntervalId) {
                clearInterval(metadataOnlyPlayerRefreshIntervalId);
                metadataOnlyPlayerRefreshIntervalId = null;
                console.log('üîÑ Metadata player refresh interval cleared');
            }
        }

        // Fetch metadata once without continuous playback
        function fetchMetadataOnce() {
            if (!currentStation) {
                return;
            }

            console.log('üîÑ Fetching metadata...');

            // Get stream URL based on quality
            const rawUrl = selectedQuality === 'low' && currentStation.url_low ? currentStation.url_low :
                          selectedQuality === 'high' && currentStation.url_high ? currentStation.url_high :
                          currentStation.url;

            if (!rawUrl) {
                console.log('No stream URL available for metadata fetch');
                return;
            }

            // Skip HLS streams - they don't support Icecast metadata
            if (isHLSStream(rawUrl)) {
                console.log('HLS streams do not support Icecast metadata, skipping metadata fetch');
                return;
            }

            // Use CORS proxy for metadata fetching
            const streamUrl = corsProxies[0].url(rawUrl);

            let tempPlayer = null;
            let metadataReceived = false;

            try {
                tempPlayer = new IcecastMetadataPlayer(streamUrl, {
                    metadataTypes: ['icy', 'ogg'],
                    enableLogging: false, // Reduce logging spam

                    onMetadata: (metadata) => {
                        if (!metadataReceived) {
                            metadataReceived = true;
                            console.log('üìª Metadata received:', metadata);
                            displayMetadata(metadata);

                            // Stop the player immediately after getting metadata
                            try {
                                if (tempPlayer) {
                                    tempPlayer.stop();
                                }
                            } catch (e) {
                                console.log('Error stopping temp player:', e);
                            }
                        }
                    },

                    onError: (error) => {
                        console.log('‚ö†Ô∏è Metadata fetch error:', error);
                        // Clean up on error
                        try {
                            if (tempPlayer) {
                                tempPlayer.stop();
                            }
                        } catch (e) {
                            // Ignore cleanup errors
                        }
                    }
                });

                // Mute the audio element
                if (tempPlayer.audioElement) {
                    tempPlayer.audioElement.volume = 0;
                    tempPlayer.audioElement.muted = true;

                    // Start playing to receive metadata
                    tempPlayer.play().catch(error => {
                        console.log('‚ö†Ô∏è Failed to start metadata fetch:', error);
                    });
                } else {
                    // If audio element not immediately available, set it up when ready
                    setTimeout(() => {
                        if (tempPlayer && tempPlayer.audioElement) {
                            tempPlayer.audioElement.volume = 0;
                            tempPlayer.audioElement.muted = true;
                            tempPlayer.play().catch(error => {
                                console.log('‚ö†Ô∏è Failed to start metadata fetch (delayed):', error);
                            });
                        }
                    }, 100);
                }

                // Automatically stop after 5 seconds if no metadata received
                setTimeout(() => {
                    if (tempPlayer && !metadataReceived) {
                        console.log('‚è±Ô∏è Metadata fetch timeout');
                        try {
                            tempPlayer.stop();
                        } catch (e) {
                            // Ignore cleanup errors
                        }
                    }
                }, 5000);

            } catch (error) {
                console.log('Failed to fetch metadata:', error);
            }
        }

        // Start periodic metadata fetching
        function startMetadataPlayerRefreshInterval() {
            // Clear any existing interval
            clearMetadataPlayerRefreshInterval();

            // Fetch immediately
            fetchMetadataOnce();

            // Start periodic fetching
            metadataOnlyPlayerRefreshIntervalId = setInterval(() => {
                fetchMetadataOnce();
            }, metadataOnlyPlayerRefreshInterval);

            console.log(`üîÑ Metadata fetching started (every ${metadataOnlyPlayerRefreshInterval/1000}s)`);
        }

        // Start metadata-only player (periodic fetching for Chromecast sessions)
        function startMetadataOnlyPlayer() {
            if (!currentStation || metadataOnlyPlayerRefreshIntervalId) {
                return; // Already running or no station
            }

            console.log('Starting metadata fetching for Chromecast session...');

            // Start periodic metadata fetching
            startMetadataPlayerRefreshInterval();
        }

        // Stop metadata-only player
        function stopMetadataOnlyPlayer() {
            console.log('Stopping metadata fetching...');
            clearMetadataPlayerRefreshInterval(); // Clear refresh interval
            console.log('‚úÖ Metadata fetching stopped');
        }

        // Start metadata-only player for Simple Mode (deprecated - now uses periodic fetching)
        function startMetadataOnlyPlayerForSimpleMode(rawUrl) {
            console.log('üéµ Starting metadata fetching for Simple Mode...');
            startMetadataPlayerRefreshInterval();
        }

        // Fallback: Start metadata-only player with direct URL (deprecated - now uses periodic fetching)
        function startMetadataOnlyPlayerDirect(rawUrl) {
            console.log('üéµ Starting metadata fetching (fallback)...');
            startMetadataPlayerRefreshInterval();
        }

        // Theme Toggle Functionality
        const themeToggle = document.getElementById('themeToggle');
        const resetThemeBtn = document.getElementById('resetThemeBtn');
        const html = document.documentElement;
        
        // Function to get system theme preference
        function getSystemTheme() {
            return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        }
        
        // Function to show/hide reset button
        function updateResetButtonVisibility() {
            const hasManualTheme = localStorage.getItem('theme');
            if (hasManualTheme) {
                resetThemeBtn.style.display = 'flex';
            } else {
                resetThemeBtn.style.display = 'none';
            }
        }
        
        // Load saved theme or use system preference
        const savedTheme = localStorage.getItem('theme');
        const initialTheme = savedTheme || getSystemTheme();
        html.setAttribute('data-theme', initialTheme);
        updateThemeToggleUI(initialTheme);
        updateResetButtonVisibility();
        
        // Listen for system theme changes (only if user hasn't set a manual preference)
        const darkModeMediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
        darkModeMediaQuery.addEventListener('change', (e) => {
            // Only auto-update if user hasn't manually set a theme
            if (!localStorage.getItem('theme')) {
                const systemTheme = e.matches ? 'dark' : 'light';
                html.setAttribute('data-theme', systemTheme);
                updateThemeToggleUI(systemTheme);
            }
        });
        
        // Theme toggle click handler
        themeToggle.addEventListener('click', () => {
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            updateThemeToggleUI(newTheme);
            updateResetButtonVisibility();
        });
        
        // Reset theme button click handler
        resetThemeBtn.addEventListener('click', () => {
            localStorage.removeItem('theme');
            const systemTheme = getSystemTheme();
            html.setAttribute('data-theme', systemTheme);
            updateThemeToggleUI(systemTheme);
            updateResetButtonVisibility();
        });
        
        // Update theme toggle UI based on current theme
        function updateThemeToggleUI(theme) {
            const darkOption = themeToggle.querySelector('[data-theme="dark"]');
            const lightOption = themeToggle.querySelector('[data-theme="light"]');

            if (theme === 'dark') {
                darkOption.classList.add('active');
                lightOption.classList.remove('active');
            } else {
                darkOption.classList.remove('active');
                lightOption.classList.add('active');
            }
        }

        // ======================
        // LAYOUT TOGGLE (Portrait/Landscape)
        // ======================

        const layoutToggle = document.getElementById('layoutToggle');
        const body = document.body;

        // Helper function to lock/unlock screen orientation
        async function setScreenOrientation(layout) {
            // Check if Screen Orientation API is supported
            if ('orientation' in screen && 'lock' in screen.orientation) {
                try {
                    if (layout === 'landscape') {
                        // Lock to landscape orientation
                        await screen.orientation.lock('landscape');
                        console.log('Screen orientation locked to landscape');
                    } else {
                        // Unlock orientation for portrait mode
                        screen.orientation.unlock();
                        console.log('Screen orientation unlocked');
                    }
                } catch (error) {
                    // Orientation lock may fail if not in fullscreen or PWA
                    console.log('Screen orientation lock not available:', error.message);
                }
            } else {
                console.log('Screen Orientation API not supported');
            }
        }

        // Get saved layout or default to portrait
        const savedLayout = localStorage.getItem('layout') || 'portrait';
        body.setAttribute('data-layout', savedLayout);
        updateLayoutToggleUI(savedLayout);
        setScreenOrientation(savedLayout);

        // Layout toggle click handler
        layoutToggle.addEventListener('click', () => {
            const currentLayout = body.getAttribute('data-layout') || 'portrait';
            const newLayout = currentLayout === 'portrait' ? 'landscape' : 'portrait';

            body.setAttribute('data-layout', newLayout);
            localStorage.setItem('layout', newLayout);
            updateLayoutToggleUI(newLayout);
            setScreenOrientation(newLayout);
        });

        // Update layout toggle UI based on current layout
        function updateLayoutToggleUI(layout) {
            const portraitOption = layoutToggle.querySelector('[data-layout="portrait"]');
            const landscapeOption = layoutToggle.querySelector('[data-layout="landscape"]');

            if (layout === 'landscape') {
                landscapeOption.classList.add('active');
                portraitOption.classList.remove('active');
            } else {
                portraitOption.classList.add('active');
                landscapeOption.classList.remove('active');
            }
        }

        // Liked Tracks Modal event listeners
        closeLikedTracksModal.addEventListener('click', () => {
            likedTracksModal.classList.remove('active');
        });
        
        likedTracksModal.addEventListener('click', (e) => {
            if (e.target === likedTracksModal) {
                likedTracksModal.classList.remove('active');
            }
        });
        
        clearAllLikesBtn.addEventListener('click', clearAllLikedTracks);
        
        // Copy All Liked Tracks button
        const copyAllLikedBtn = document.getElementById('copyAllLikedBtn');
        copyAllLikedBtn.addEventListener('click', copyAllLikedTracks);
        
        // Download Liked Tracks button
        const downloadLikedBtn = document.getElementById('downloadLikedBtn');
        downloadLikedBtn.addEventListener('click', downloadLikedTracksFile);
        
        // Recent Tracks Modal
        const recentTracksModal = document.getElementById('recentTracksModal');
        const closeRecentTracksModal = document.getElementById('closeRecentTracksModal');
        const clearRecentTracksBtn = document.getElementById('clearRecentTracksBtn');

        closeRecentTracksModal.addEventListener('click', () => {
            recentTracksModal.classList.remove('active');
        });
        
        recentTracksModal.addEventListener('click', (e) => {
            if (e.target === recentTracksModal) {
                recentTracksModal.classList.remove('active');
            }
        });
        
        clearRecentTracksBtn.addEventListener('click', clearAllRecentTracks);

        // Copy All Recent Tracks button
        const copyAllRecentBtn = document.getElementById('copyAllRecentBtn');
        copyAllRecentBtn.addEventListener('click', copyAllRecentTracks);

        // Download Recent Tracks button
        const downloadRecentBtn = document.getElementById('downloadRecentBtn');
        downloadRecentBtn.addEventListener('click', downloadRecentTracksFile);

        // Modal buttons for Liked Tracks and Recent Tracks
        const modalViewLikedTracksBtn = document.getElementById('modalViewLikedTracksBtn');
        const modalViewRecentTracksBtn = document.getElementById('modalViewRecentTracksBtn');

        if (modalViewLikedTracksBtn) {
            modalViewLikedTracksBtn.addEventListener('click', () => {
                displayLikedTracks();
                nowPlayingModal.classList.remove('active');
                likedTracksModal.classList.add('active');
            });
        }

        if (modalViewRecentTracksBtn) {
            modalViewRecentTracksBtn.addEventListener('click', () => {
                displayRecentTracks();
                nowPlayingModal.classList.remove('active');
                recentTracksModal.classList.add('active');
            });
        }

        // Lyrics Modal event listeners
        const lyricsModal = document.getElementById('lyricsModal');
        const closeLyricsModalBtn = document.getElementById('closeLyricsModal');

        closeLyricsModalBtn.addEventListener('click', closeLyricsModal);

        lyricsModal.addEventListener('click', (e) => {
            if (e.target === lyricsModal) {
                closeLyricsModal();
            }
        });

        // Now Playing Modal event listeners
        const nowPlayingModal = document.getElementById('nowPlayingModal');
        const closeNowPlayingModalBtn = document.getElementById('closeNowPlayingModal');
        const metadataSection = document.getElementById('metadataSection');

        metadataSection.addEventListener('click', openNowPlayingModal);

        closeNowPlayingModalBtn.addEventListener('click', closeNowPlayingModal);

        nowPlayingModal.addEventListener('click', (e) => {
            if (e.target === nowPlayingModal) {
                closeNowPlayingModal();
            }
        });

        // Close playlist modal
        closePlaylistModal.addEventListener('click', () => {
            playlistModal.classList.remove('active');
            currentPlaylist = null;
        });
        
        // Back to stations (from playlist detail view)
        backToStations.addEventListener('click', () => {
            playlistModal.classList.remove('active');
            playlistsModal.classList.add('active');
            currentPlaylist = null;
        });
        
        // Create playlist button
        createPlaylistBtn.addEventListener('click', () => {
            showPlaylistForm();
        });

        // Create playlist menu button (from hamburger menu)
        document.getElementById('createPlaylistMenuBtn').addEventListener('click', () => {
            hamburgerMenuModal.classList.remove('active');
            showPlaylistForm();
        });

        // View playlists menu button (from hamburger menu)
        document.getElementById('viewPlaylistsBtn').addEventListener('click', () => {
            hamburgerMenuModal.classList.remove('active');
            playlistsModal.classList.add('active');
        });

        // Add station button
        document.getElementById('addStationBtn').addEventListener('click', () => {
            showStationForm();
        });
        
        // Playlist form
        playlistForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const name = playlistName.value.trim();
            const description = playlistDescription.value.trim();
            
            if (!name) return;
            
            if (editingPlaylistId) {
                await updatePlaylist(editingPlaylistId, name, description);
            } else {
                await createPlaylist(name, description);
            }
            
            playlistFormModal.classList.remove('active');
            editingPlaylistId = null;
        });
        
        // Close playlist form
        closePlaylistFormModal.addEventListener('click', () => {
            playlistFormModal.classList.remove('active');
            editingPlaylistId = null;
        });
        
        cancelPlaylistForm.addEventListener('click', () => {
            playlistFormModal.classList.remove('active');
            editingPlaylistId = null;
        });
        
        // Station form
        stationForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            // Get form values
            const name = document.getElementById('stationFormName').value.trim();
            const url = document.getElementById('stationFormUrl').value.trim();
            const url_low = document.getElementById('stationFormUrlLow').value.trim() || null;
            const url_high = document.getElementById('stationFormUrlHigh').value.trim() || null;
            const call_letters = document.getElementById('stationFormCallLetters').value.trim() || null;
            const frequency = document.getElementById('stationFormFrequency').value.trim() || null;
            const website_url = document.getElementById('stationFormWebsiteUrl').value.trim() || null;
            const genresInput = document.getElementById('stationFormGenres').value.trim();
            const description = document.getElementById('stationFormDescription').value.trim() || null;
            let icon_url = document.getElementById('stationFormIconUrl').value.trim() || null;
            
            // Validate required fields
            if (!name || !url) {
                alert('Station name and URL are required!');
                return;
            }
            
            // Check if there's an uploaded image file
            const fileInput = document.getElementById('stationFormIconUpload');
            if (fileInput.files && fileInput.files[0]) {
                try {
                    // Upload image to Supabase Storage
                    const file = fileInput.files[0];
                    const fileExt = file.name.split('.').pop();
                    const fileName = `${Date.now()}-${Math.random().toString(36).substring(2)}.${fileExt}`;
                    const filePath = `station-icons/${fileName}`;
                    
                    console.log('Uploading image to Supabase Storage:', filePath);
                    
                    const { data: uploadData, error: uploadError } = await supabase.storage
                        .from('station-images')
                        .upload(filePath, file, {
                            cacheControl: '3600',
                            upsert: false
                        });
                    
                    if (uploadError) {
                        console.error('Upload error:', uploadError);
                        alert('Failed to upload image: ' + uploadError.message);
                        return;
                    }
                    
                    // Get public URL
                    const { data: urlData } = supabase.storage
                        .from('station-images')
                        .getPublicUrl(filePath);
                    
                    icon_url = urlData.publicUrl;
                    console.log('Image uploaded successfully:', icon_url);
                    
                } catch (error) {
                    console.error('Upload error:', error);
                    alert('Failed to upload image: ' + error.message);
                    return;
                }
            }
            
            // Convert genres string to array if needed
            // If user enters "News,Talk" or "News, Talk", convert to ["News", "Talk"]
            let genres = null;
            if (genresInput) {
                // Split by comma and trim whitespace from each genre
                genres = genresInput.split(',').map(g => g.trim()).filter(g => g.length > 0);
            }
            
            const stationData = {
                name: name,
                url: url,
                url_low: url_low,
                url_high: url_high,
                call_letters: call_letters,
                frequency: frequency,
                website_url: website_url,
                genres: genres, // Now an array like ["News", "Talk"] or null
                description: description,
                icon_url: icon_url
            };
            
            console.log('Form submission - editingStationId:', editingStationId);
            console.log('Form submission - stationData:', stationData);
            
            if (editingStationId) {
                await updateStation(editingStationId, stationData);
            } else {
                await createStation(stationData);
            }
            
            stationFormModal.classList.remove('active');
            editingStationId = null;
        });
        
        // Image upload handlers
        const uploadIconBtn = document.getElementById('uploadIconBtn');
        const stationFormIconUpload = document.getElementById('stationFormIconUpload');
        const iconPreview = document.getElementById('iconPreview');
        const iconPreviewImg = document.getElementById('iconPreviewImg');
        const iconPreviewName = document.getElementById('iconPreviewName');
        const iconPreviewSize = document.getElementById('iconPreviewSize');
        const removeIconBtn = document.getElementById('removeIcon');
        
        uploadIconBtn.addEventListener('click', () => {
            stationFormIconUpload.click();
        });
        
        stationFormIconUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                // Check file size (max 5MB)
                if (file.size > 5 * 1024 * 1024) {
                    alert('Image size must be less than 5MB');
                    e.target.value = '';
                    return;
                }
                
                // Show preview
                const reader = new FileReader();
                reader.onload = (e) => {
                    iconPreviewImg.src = e.target.result;
                    iconPreviewName.textContent = file.name;
                    iconPreviewSize.textContent = `${(file.size / 1024).toFixed(1)} KB`;
                    iconPreview.style.display = 'flex';
                    uploadIconBtn.textContent = '‚úì Image Selected';
                    uploadIconBtn.style.background = 'var(--success-color, #4caf50)';
                };
                reader.readAsDataURL(file);
            }
        });
        
        removeIconBtn.addEventListener('click', () => {
            stationFormIconUpload.value = '';
            iconPreview.style.display = 'none';
            uploadIconBtn.textContent = 'üì∑ Choose Image';
            uploadIconBtn.style.background = '';
        });
        
        // Close station form
        closeStationFormModal.addEventListener('click', () => {
            stationFormModal.classList.remove('active');
            editingStationId = null;
        });
        
        cancelStationForm.addEventListener('click', () => {
            stationFormModal.classList.remove('active');
            editingStationId = null;
        });
        
        // Search stations
        // Search input handler
        stationSearch.addEventListener('input', (e) => {
            console.log('Search input event fired, value:', e.target.value);
            const clearBtn = document.getElementById('clearSearchBtn');
            
            // Show/hide clear button based on input
            if (e.target.value.trim() !== '' || currentGenreFilter !== '') {
                clearBtn.style.display = 'flex';
            } else {
                clearBtn.style.display = 'none';
            }
            
            filterStations(e.target.value);
        });
        
        // Clear search button
        const clearSearchBtn = document.getElementById('clearSearchBtn');
        clearSearchBtn.addEventListener('click', () => {
            // Clear search input
            stationSearch.value = '';
            
            // Reset genre filter to "All Genres"
            currentGenreFilter = '';
            const genreLabel = document.getElementById('genreLabel');
            genreLabel.textContent = 'All Genres';
            
            // Update active state in genre dropdown
            document.querySelectorAll('.filter-dropdown#genreDropdown .filter-option').forEach(opt => {
                if (opt.dataset.genre === '') {
                    opt.classList.add('active');
                } else {
                    opt.classList.remove('active');
                }
            });
            
            // Hide clear button
            clearSearchBtn.style.display = 'none';
            
            // Refilter stations
            filterStations('');
        });
        
        // Genre dropdown toggle
        genreBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            genreDropdown.classList.toggle('active');
            sortDropdown.classList.remove('active'); // Close sort dropdown
        });
        
        // Sort dropdown toggle
        sortBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            sortDropdown.classList.toggle('active');
            genreDropdown.classList.remove('active'); // Close genre dropdown
        });
        
        // Sort option selection
        document.querySelectorAll('.filter-dropdown#sortDropdown .filter-option').forEach(option => {
            option.addEventListener('click', async (e) => {
                e.stopPropagation();
                
                // Update active state
                document.querySelectorAll('.filter-dropdown#sortDropdown .filter-option').forEach(opt => opt.classList.remove('active'));
                option.classList.add('active');
                
                // Update sort method
                currentSortMethod = option.dataset.sort;
                
                // Update button label
                sortLabel.textContent = option.textContent.trim();
                
                // Close dropdown
                sortDropdown.classList.remove('active');
                
                // Apply sort
                await sortStations();
            });
        });
        
        // Quality modal
        // Quality button removed from main UI - now only accessible via Station Info modal
        const qualityModal = document.getElementById('qualityModal');
        const closeQualityModal = document.getElementById('closeQualityModal');

        // Playback mode modal
        const playbackModeBtn = document.getElementById('playbackModeBtn');
        const playbackModeModal = document.getElementById('playbackModeModal');
        const closePlaybackModeModal = document.getElementById('closePlaybackModeModal');
        const currentModeText = document.getElementById('currentMode');
        
        closeQualityModal.addEventListener('click', () => {
            qualityModal.classList.remove('active');
        });
        
        qualityModal.addEventListener('click', (e) => {
            if (e.target === qualityModal) {
                qualityModal.classList.remove('active');
            }
        });
        
        // Quality option selection
        qualityModal.querySelectorAll('.quality-option-modal[data-quality]').forEach(option => {
            option.addEventListener('click', () => {
                // Don't allow selecting disabled options
                if (option.classList.contains('disabled')) {
                    return;
                }
                
                // Check if this is already selected
                if (option.classList.contains('selected')) {
                    qualityModal.classList.remove('active');
                    return;
                }
                
                const wasPlaying = isPlaying;
                const newQuality = option.dataset.quality;
                
                qualityModal.querySelectorAll('.quality-option-modal[data-quality]').forEach(opt => opt.classList.remove('selected'));
                option.classList.add('selected');
                selectedQuality = newQuality;

                // Close modals
                qualityModal.classList.remove('active');
                stationInfoModal.classList.remove('active');

                // If a station is selected, start playing with new quality
                if (currentStation) {
                    console.log(`Switching to ${newQuality} quality...`);
                    updateStatus(`Switching to ${newQuality} quality...`, 'loading');

                    // Stop any current playback
                    if (player) {
                        player.stop();
                    }

                    // Stop metadata-only player so it restarts with new quality URL
                    stopMetadataOnlyPlayer();

                    // Ensure isPlaying is false so the next click will start playing
                    isPlaying = false;

                    // Wait a moment for the stop to complete, then start new stream
                    setTimeout(() => {
                        // Force play by simulating a click
                        playPauseBtn.click();
                    }, 300);
                }
            });
        });

        // Playback mode modal handlers - commented out since button is hidden
        /*
        playbackModeBtn.addEventListener('click', () => {
            playbackModeModal.classList.add('active');
        });

        closePlaybackModeModal.addEventListener('click', () => {
            playbackModeModal.classList.remove('active');
        });

        playbackModeModal.addEventListener('click', (e) => {
            if (e.target === playbackModeModal) {
                playbackModeModal.classList.remove('active');
            }
        });

        // Playback mode option selection
        const modeOptions = playbackModeModal.querySelectorAll('.quality-option-modal[data-mode]');
        console.log('Found', modeOptions.length, 'mode options');
        modeOptions.forEach(option => {
            option.addEventListener('click', () => {
                console.log('Mode option clicked:', option.dataset.mode);

                // Check if this is already selected
                if (option.classList.contains('selected')) {
                    playbackModeModal.classList.remove('active');
                    return;
                }

                const wasPlaying = isPlaying;
                const newMode = option.dataset.mode;

                // Stop current playback
                stopAllPlayers();

                modeOptions.forEach(opt => opt.classList.remove('selected'));
                option.classList.add('selected');
                playbackMode = newMode;

                // Update button text
                const modeNames = {
                    'live': 'Live',
                    'simple': 'Simple'
                };
                if (currentModeText) currentModeText.textContent = modeNames[newMode];

                // Close modal
                playbackModeModal.classList.remove('active');

                // If player was playing, restart with new mode
                if (wasPlaying && currentStation) {
                    console.log(`Switching to ${newMode} mode...`);
                    setTimeout(() => {
                        playPauseBtn.click();
                    }, 200);
                }
            });
        });
        */

        // Close modals on overlay click
        [playlistsModal, browseStationsModal, playlistModal, playlistFormModal, stationFormModal, qualityModal, playbackModeModal].forEach(modal => {
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.classList.remove('active');
                }
            });
        });
        
        // ======================
        // METADATA DISPLAY
        // ======================
        
        // Helper function to display station icon
        function displayStationIcon() {
            if (currentStation && currentStation.icon_url) {
                updateArtwork(`<img src="${escapeHtml(currentStation.icon_url)}" alt="${escapeHtml(currentStation.name)}" class="album-art" onerror="this.onerror=null; this.src='icons/icon-512x512.png'">`);
            } else {
                updateArtwork(`<img src="icons/icon-512x512.png" alt="Radio Icon" class="album-art" style="padding: 40px;">`);
            }
            // Reset last fetched track and lyrics to allow fresh fetches when metadata returns
            lastFetchedTrack = { title: null, artist: null };
            lastFetchedLyrics = { title: null, artist: null, lyrics: null, lyricsUrl: null, hasLyrics: false };
        }
        
        // Display metadata
        function displayMetadata(metadata) {
            if (!metadata || !metadata.StreamTitle) {
                metadataDiv.innerHTML = `
                    <div class="now-playing-label">NOW PLAYING</div>
                    <div class="no-metadata">No metadata available</div>
                `;
                displayStationIcon();
                // Reset current track
                currentTrack = { title: null, artist: null, album: null, artworkUrl: null, lyrics: null, lyricsUrl: null, hasLyrics: false };
                // Reset last fetched track and lyrics to allow fresh fetches when metadata returns
                lastFetchedTrack = { title: null, artist: null };
                lastFetchedLyrics = { title: null, artist: null };
                updateLikeButton();
                updateLyricsIndicator();
                // Update media session with station info when no metadata
                if (currentStation) {
                    updateMediaSession(
                        currentStation.name,
                        '',
                        '',
                        currentStation.icon_url
                    );
                }
                return;
            }
            
            const streamTitle = metadata.StreamTitle || '';
            let title = 'Unknown';
            let artist = '';
            let album = '';
            
            // Check if metadata is in structured attribute format: title="...",artist="..."
            const titleMatch = streamTitle.match(/title=["']([^"']+)["']/i);
            const artistMatch = streamTitle.match(/artist=["']([^"']+)["']/i);
            
            if (titleMatch || artistMatch) {
                // Structured format detected
                title = titleMatch ? titleMatch[1].trim() : 'Unknown';
                artist = artistMatch ? artistMatch[1].trim() : '';
            } else {
                // Helper function to clean metadata text (remove XML attributes from iHeart and similar stations)
                function cleanMetadataText(text) {
                    if (!text) return '';
                    
                    // First, check if the text starts with text="..." pattern and extract the value
                    const textMatch = text.match(/^text=["']([^"']+)["']/i);
                    if (textMatch) {
                        return textMatch[1].trim();
                    }
                    
                    // Otherwise, remove everything after common attribute patterns like text=", song_spot=", etc.
                    // This matches patterns like: text="..." or attribute="value" or attribute='value'
                    const cleaned = text.replace(/\s+(text|song_spot|spotInstanceId|length|MediaBaseId|TAID|TPID|cartcutId|amgArtworkURL|spEventID|[a-zA-Z_]+)=["'][^"']*["'].*$/i, '');
                    return cleaned.trim();
                }
                
                // Traditional format: "Artist - Title"
                if (streamTitle.includes(' - ')) {
                    const parts = streamTitle.split(' - ');
                    artist = cleanMetadataText(parts[0].trim());
                    title = cleanMetadataText(parts[1].trim());
                } else {
                    title = cleanMetadataText(streamTitle);
                }
            }
            
            // Update current track
            currentTrack.title = title;
            currentTrack.artist = artist;
            currentTrack.album = album;

            // Update media session immediately with track info (before album art loads)
            // This ensures the notification shade updates even when app is backgrounded
            updateMediaSession(title, artist, album, currentTrack.artworkUrl || null);

            // Add to recent tracks
            window.addToRecentTracks({
                title: title,
                artist: artist,
                album: album,
                artworkUrl: null, // Will be updated when album art loads
                station: currentStation ? currentStation.name : 'Unknown Station'
            });
            
            metadataDiv.innerHTML = `
                <div class="now-playing-label">NOW PLAYING</div>
                <div class="song-title">${escapeHtml(title)}</div>
                ${artist ? `<div class="artist-name">${escapeHtml(artist)}</div>` : ''}
                ${album ? `<div class="album-name">${escapeHtml(album)}</div>` : ''}
            `;
            
            // Try to fetch album art
            fetchAlbumArt(title, artist);

            // Fetch lyrics for the current track
            fetchLyricsForCurrentTrack();

            // Update Cast metadata if casting
            updateCastMetadata(title, artist, null); // Will update again with artwork when fetched
        }
        
        // Fetch album art from iTunes or MusicBrainz
        let lastFetchedTrack = { title: null, artist: null }; // Track what we last fetched to avoid duplicates

        async function fetchAlbumArt(title, artist) {
            if (!artist || !title) {
                displayStationIcon();
                return;
            }

            // Check if we've already fetched artwork for this exact song
            if (lastFetchedTrack.title === title && lastFetchedTrack.artist === artist) {
                console.log('Skipping duplicate artwork fetch for:', `"${artist}" - "${title}"`);
                return;
            }

            // Update the last fetched track
            lastFetchedTrack = { title, artist };

            const useItunes = document.getElementById('useItunesApi').checked;

            if (useItunes) {
                await fetchAlbumArtItunes(title, artist);
            } else {
                await fetchAlbumArtMusicBrainz(title, artist);
            }
        }
        
        // Fetch album art from iTunes API
        async function fetchAlbumArtItunes(title, artist) {
            try {
                // Clean up artist name - take first artist if multiple
                let cleanArtist = artist.split(/[\/&]|feat\.|ft\./i)[0].trim();
                
                console.log(`Searching iTunes for: "${cleanArtist}" - "${title}"`);
                
                const query = encodeURIComponent(`${cleanArtist} ${title}`);
                const itunesUrl = `https://itunes.apple.com/search?term=${query}&entity=song&limit=1`;
                
                const response = await fetch(itunesUrl);
                const data = await response.json();
                
                if (data.results && data.results.length > 0) {
                    const result = data.results[0];
                    // iTunes returns 100x100 by default, we can get higher res by replacing with 600x600
                    let artUrl = result.artworkUrl100;
                    if (artUrl) {
                        artUrl = artUrl.replace('100x100', '600x600');
                        
                        // Store artwork URL in current track
                        currentTrack.artworkUrl = artUrl;
                        
                        const img = new Image();
                        img.onload = () => {
                            updateArtwork(`<img src="${artUrl}" alt="Album Art" class="album-art">`);
                            updateMediaSession(title, artist, result.collectionName || '', artUrl);
                            // Update Cast with album art
                            updateCastMetadata(title, artist, artUrl);
                            // Update recent tracks with artwork
                            if (currentTrack.title && currentTrack.artist) {
                                window.addToRecentTracks({
                                    title: currentTrack.title,
                                    artist: currentTrack.artist,
                                    album: currentTrack.album,
                                    artworkUrl: artUrl,
                                    station: currentStation ? currentStation.name : 'Unknown Station'
                                });
                            }
                        };
                        img.onerror = () => {
                            displayStationIcon();
                        };
                        img.src = artUrl;
                        return;
                    }
                }
            } catch (error) {
                console.error('Error fetching album art from iTunes:', error);
            }
            
            currentTrack.artworkUrl = null;
            displayStationIcon();
            updateMediaSession(title, artist, '', null);
        }
        
        // Fetch album art from MusicBrainz/Cover Art Archive
        async function fetchAlbumArtMusicBrainz(title, artist) {
            try {
                // Clean up artist name - take first artist if multiple (separated by /, feat., &, etc.)
                let cleanArtist = artist.split(/[\/&]|feat\.|ft\./i)[0].trim();
                
                // Log what we're searching for (helps with debugging)
                console.log(`Searching MusicBrainz for: "${cleanArtist}" - "${title}"`);
                
                const query = encodeURIComponent(`${cleanArtist} ${title}`);
                const mbUrl = `https://musicbrainz.org/ws/2/recording/?query=${query}&fmt=json&limit=1`;
                
                const mbResponse = await fetch(mbUrl);
                const mbData = await mbResponse.json();
                
                if (mbData.recordings && mbData.recordings.length > 0) {
                    const recording = mbData.recordings[0];
                    if (recording.releases && recording.releases.length > 0) {
                        const releaseId = recording.releases[0].id;
                        const artUrl = `https://coverartarchive.org/release/${releaseId}/front-500`;
                        
                        const img = new Image();
                        img.onload = () => {
                            updateArtwork(`<img src="${artUrl}" alt="Album Art" class="album-art">`);
                            updateMediaSession(title, artist, '', artUrl);
                            // Update Cast with album art
                            updateCastMetadata(title, artist, artUrl);
                            // Update recent tracks with artwork
                            if (currentTrack.title && currentTrack.artist) {
                                window.addToRecentTracks({
                                    title: currentTrack.title,
                                    artist: currentTrack.artist,
                                    album: currentTrack.album,
                                    artworkUrl: artUrl,
                                    station: currentStation ? currentStation.name : 'Unknown Station'
                                });
                            }
                        };
                        img.onerror = () => {
                            displayStationIcon();
                        };
                        img.src = artUrl;
                        return;
                    }
                }
            } catch (error) {
                console.error('Error fetching album art from MusicBrainz:', error);
            }
            
            displayStationIcon();
            updateMediaSession(title, artist, '', null);
        }

        // ======================
        // LRCLIB LYRICS API
        // ======================

        // Fetch lyrics using LrcLib API
        async function fetchLrcLibLyrics(title, artist) {
            if (!title || !artist) {
                return null;
            }

            try {
                const params = new URLSearchParams({
                    artist_name: artist,
                    track_name: title
                });

                const url = `https://lrclib.net/api/get?${params}`;
                console.log(`Fetching lyrics from LrcLib: "${artist}" - "${title}"`);

                const response = await fetch(url);

                if (!response.ok) {
                    if (response.status === 404) {
                        console.log('No lyrics found on LrcLib');
                    } else {
                        console.error('LrcLib API request failed:', response.status);
                    }
                    return null;
                }

                const data = await response.json();

                // LrcLib returns plainLyrics and syncedLyrics
                // We'll use plainLyrics for radio streams since we can't sync
                if (data.plainLyrics) {
                    return {
                        lyrics: data.plainLyrics,
                        trackName: data.trackName,
                        artistName: data.artistName,
                        albumName: data.albumName
                    };
                }

                return null;
            } catch (error) {
                console.error('Error fetching LrcLib lyrics:', error);
                return null;
            }
        }

        // Fetch and display lyrics for current track
        let lastFetchedLyrics = { title: null, artist: null, lyrics: null, lyricsUrl: null, hasLyrics: false }; // Track what we last fetched to avoid duplicates

        async function fetchLyricsForCurrentTrack() {
            if (!currentTrack.title || !currentTrack.artist) {
                return;
            }

            // Check if we've already fetched lyrics for this exact song
            if (lastFetchedLyrics.title === currentTrack.title && lastFetchedLyrics.artist === currentTrack.artist) {
                console.log('Skipping duplicate lyrics fetch for:', `"${currentTrack.artist}" - "${currentTrack.title}"`);
                // Restore previously fetched lyrics data
                currentTrack.lyrics = lastFetchedLyrics.lyrics;
                currentTrack.lyricsUrl = lastFetchedLyrics.lyricsUrl;
                currentTrack.hasLyrics = lastFetchedLyrics.hasLyrics;
                // Update the lyrics indicator to show the button
                updateLyricsIndicator();
                return;
            }

            try {
                // Fetch lyrics from LrcLib
                const result = await fetchLrcLibLyrics(currentTrack.title, currentTrack.artist);

                if (result && result.lyrics) {
                    currentTrack.lyrics = result.lyrics;
                    currentTrack.lyricsUrl = 'https://lrclib.net'; // Link to LrcLib homepage
                    currentTrack.hasLyrics = true;
                    console.log('Lyrics fetched successfully from LrcLib');
                } else {
                    currentTrack.hasLyrics = false;
                    currentTrack.lyrics = null;
                    currentTrack.lyricsUrl = null;
                }

                // Store the fetched lyrics data to avoid duplicate fetches
                lastFetchedLyrics = {
                    title: currentTrack.title,
                    artist: currentTrack.artist,
                    lyrics: currentTrack.lyrics,
                    lyricsUrl: currentTrack.lyricsUrl,
                    hasLyrics: currentTrack.hasLyrics
                };

                // Update artwork to show lyrics indicator
                updateLyricsIndicator();
            } catch (error) {
                console.error('Error fetching lyrics:', error);
                currentTrack.hasLyrics = false;
                currentTrack.lyrics = null;
                currentTrack.lyricsUrl = null;

                // Store the failed fetch result
                lastFetchedLyrics = {
                    title: currentTrack.title,
                    artist: currentTrack.artist,
                    lyrics: null,
                    lyricsUrl: null,
                    hasLyrics: false
                };

                updateLyricsIndicator();
            }
        }

        // Update lyrics button in metadata section
        function updateLyricsIndicator() {
            // Lyrics button is now in the Now Playing modal, so just remove any old buttons
            const existingButtons = document.querySelectorAll('.lyrics-btn');
            existingButtons.forEach(button => button.remove());
        }

        // Show lyrics modal
        function showLyricsModal() {
            if (!currentTrack.hasLyrics) {
                return;
            }

            // Close Now Playing modal if it's open
            closeNowPlayingModal();

            const modal = document.getElementById('lyricsModal');
            const modalTitle = document.getElementById('lyricsModalTitle');
            const lyricsContent = document.getElementById('lyricsContent');

            // Set modal title
            modalTitle.textContent = `${currentTrack.title} - ${currentTrack.artist}`;

            if (currentTrack.lyrics) {
                // Display lyrics
                lyricsContent.innerHTML = `<pre class="lyrics-text">${escapeHtml(currentTrack.lyrics)}</pre>`;

                // Add attribution link
                if (currentTrack.lyricsUrl) {
                    lyricsContent.innerHTML += `<div class="lyrics-attribution">Lyrics from <a href="${currentTrack.lyricsUrl}" target="_blank" rel="noopener noreferrer">LrcLib</a></div>`;
                }
            } else {
                lyricsContent.innerHTML = '<div class="lyrics-error">Lyrics not available for this track.</div>';
            }

            modal.classList.add('active');
            lastOpenedModal = 'lyricsModal';
        }

        // Close lyrics modal
        function closeLyricsModal() {
            const modal = document.getElementById('lyricsModal');
            modal.classList.remove('active');
        }

        // Open now playing modal
        function openNowPlayingModal() {
            // Only open if there's metadata to show
            if (!currentTrack.title) {
                return;
            }

            const modal = document.getElementById('nowPlayingModal');

            // Update modal content
            document.getElementById('modalSongTitle').textContent = currentTrack.title || '-';
            document.getElementById('modalArtistName').textContent = currentTrack.artist || '-';
            document.getElementById('modalAlbumName').textContent = currentTrack.album || '-';

            // Update like button state
            const modalLikeBtn = document.getElementById('modalLikeBtn');
            const isLiked = isTrackLiked(currentTrack);
            if (isLiked) {
                modalLikeBtn.classList.add('liked');
                modalLikeBtn.querySelector('.action-icon').textContent = '‚ô•';
            } else {
                modalLikeBtn.classList.remove('liked');
                modalLikeBtn.querySelector('.action-icon').textContent = '‚ô°';
            }

            // Update lyrics button state
            const modalLyricsBtn = document.getElementById('modalLyricsBtn');
            if (currentTrack.hasLyrics) {
                modalLyricsBtn.classList.remove('disabled');
            } else {
                modalLyricsBtn.classList.add('disabled');
            }

            modal.classList.add('active');
        }

        // Close now playing modal
        function closeNowPlayingModal() {
            const modal = document.getElementById('nowPlayingModal');
            modal.classList.remove('active');
        }

        // Update Media Session API
        function updateMediaSession(title, artist, album, artworkUrl) {
            if ('mediaSession' in navigator) {
                navigator.mediaSession.metadata = new MediaMetadata({
                    title: title || 'Unknown Track',
                    artist: artist || (currentStation ? currentStation.name : 'Radio Stream'),
                    album: album || '',
                    artwork: artworkUrl ? [
                        { src: artworkUrl, sizes: '600x600', type: 'image/jpeg' }
                    ] : (currentStation && currentStation.icon_url ? [
                        { src: currentStation.icon_url, sizes: '512x512', type: 'image/png' }
                    ] : [])
                });
            }
        }
        
        // Setup Media Session handlers
        function setupMediaSessionHandlers() {
            if ('mediaSession' in navigator) {
                navigator.mediaSession.setActionHandler('play', () => {
                    // Always trigger play/pause button when play is pressed
                    // This handles both starting from stopped and resuming from paused
                    if (!isPlaying || isPaused) {
                        playPauseBtn.click();
                    }
                });
                
                navigator.mediaSession.setActionHandler('pause', () => {
                    if (isPlaying && !isPaused) {
                        playPauseBtn.click();
                    }
                });
                
                navigator.mediaSession.setActionHandler('stop', () => {
                    if (isPlaying || isPaused) {
                        isPaused = false;
                        stopAllPlayers();
                        isPlaying = false;
                        updateStatus('Stopped', 'stopped');
                        updatePlayPauseButton(false);
                    }
                });
                
                navigator.mediaSession.setActionHandler('nexttrack', () => {
                    if (stations.length > 0 && currentStation) {
                        const currentIndex = stations.findIndex(s => s.id === currentStation.id);
                        const nextIndex = (currentIndex + 1) % stations.length;
                        selectStation(stations[nextIndex]);
                        setTimeout(() => playPauseBtn.click(), 500);
                    }
                });
                
                navigator.mediaSession.setActionHandler('previoustrack', () => {
                    if (stations.length > 0 && currentStation) {
                        const currentIndex = stations.findIndex(s => s.id === currentStation.id);
                        const prevIndex = currentIndex > 0 ? currentIndex - 1 : stations.length - 1;
                        selectStation(stations[prevIndex]);
                        setTimeout(() => playPauseBtn.click(), 500);
                    }
                });
            }
        }
        
        // ======================
        // PLAYER CONTROLS
        // ======================
        
        // Helper function to detect if URL is HLS stream
        function isHLSStream(url) {
            return url && (url.includes('.m3u8') || url.includes('m3u8'));
        }
        
        // Helper function to stop all players
        function stopAllPlayers() {
            isPaused = false; // Reset pause state when actually stopping
            if (player) {
                try {
                    player.stop();
                } catch (e) {
                    console.error('Error stopping Icecast player:', e);
                }
                player = null;
            }
            
            if (hlsPlayer) {
                try {
                    hlsPlayer.destroy();
                } catch (e) {
                    console.error('Error destroying HLS player:', e);
                }
                hlsPlayer = null;
            }
            
            if (audioElement) {
                try {
                    audioElement.pause();
                    audioElement.src = '';
                } catch (e) {
                    console.error('Error stopping audio element:', e);
                }
            }
            
            if (simpleAudioPlayer) {
                try {
                    simpleAudioPlayer.pause();
                    simpleAudioPlayer.src = '';
                } catch (e) {
                    console.error('Error stopping simple audio player:', e);
                }
            }
        }

        // Helper function to parse ID3 frames from HLS metadata
        function parseID3Frames(data) {
            const frames = {};

            try {
                // ID3 tags in HLS are typically in ID3v2 format
                const view = new DataView(data.buffer || data);
                let offset = 0;

                // Check for ID3 header
                if (view.byteLength < 10) return frames;

                const header = String.fromCharCode(view.getUint8(0), view.getUint8(1), view.getUint8(2));
                if (header !== 'ID3') return frames;

                // Skip version and flags
                offset = 10;

                // Parse frames
                while (offset < view.byteLength - 10) {
                    // Get frame ID (4 bytes)
                    const frameId = String.fromCharCode(
                        view.getUint8(offset),
                        view.getUint8(offset + 1),
                        view.getUint8(offset + 2),
                        view.getUint8(offset + 3)
                    );

                    if (frameId === '\0\0\0\0') break;

                    // Get frame size (4 bytes, synchsafe integer)
                    const size = (view.getUint8(offset + 4) << 21) |
                                (view.getUint8(offset + 5) << 14) |
                                (view.getUint8(offset + 6) << 7) |
                                view.getUint8(offset + 7);

                    // Skip frame flags (2 bytes)
                    offset += 10;

                    if (size === 0 || offset + size > view.byteLength) break;

                    // Extract frame data (skip encoding byte)
                    const encoding = view.getUint8(offset);
                    let text = '';

                    try {
                        // Skip encoding byte and extract text
                        const textData = new Uint8Array(view.buffer, offset + 1, size - 1);
                        const decoder = new TextDecoder(encoding === 1 ? 'utf-16' : 'utf-8');
                        text = decoder.decode(textData).replace(/\0/g, '').trim();
                    } catch (e) {
                        console.warn('Error decoding ID3 text:', e);
                    }

                    if (text && (frameId === 'TIT2' || frameId === 'TPE1' || frameId === 'TALB' || frameId === 'TCON')) {
                        frames[frameId] = text;
                        console.log(`ID3 ${frameId}:`, text);
                    }

                    offset += size;
                }
            } catch (error) {
                console.error('Error parsing ID3 frames:', error);
            }

            return frames;
        }

        // Helper function to play HLS stream
        async function playHLSStream(streamUrl) {
            return new Promise((resolve, reject) => {
                // Handle mixed content: HTTP streams on HTTPS pages
                if (window.location.protocol === 'https:' && streamUrl.startsWith('http://')) {
                    // Try to upgrade to HTTPS first (works for domains with SSL)
                    // But for IP addresses, we'll need CORS proxy (handled in retry logic)
                    const httpsUrl = streamUrl.replace('http://', 'https://');
                    console.log('üîí Attempting to upgrade HTTP stream to HTTPS:', streamUrl, '‚Üí', httpsUrl);
                    console.log('Note: If this fails (e.g., IP address), fallback methods will use CORS proxy');
                    streamUrl = httpsUrl;
                }
                
                console.log('üéµ Starting HLS stream:', streamUrl);
                
                // Create audio element if it doesn't exist
                if (!audioElement) {
                    audioElement = new Audio();
                    audioElement.crossOrigin = 'anonymous';
                    
                    // Set volume from saved settings
                    const savedVolume = localStorage.getItem('volume');
                    audioElement.volume = savedVolume ? parseFloat(savedVolume) : 0.7;
                    
                    console.log('Created new audio element with volume:', audioElement.volume);
                }
                
                // Stop any existing HLS player
                if (hlsPlayer) {
                    try {
                        hlsPlayer.destroy();
                    } catch (e) {
                        console.warn('Error destroying previous HLS player:', e);
                    }
                    hlsPlayer = null;
                }
                
                if (Hls.isSupported()) {
                    console.log('‚úÖ HLS.js is supported, initializing...');
                    
                    hlsPlayer = new Hls({
                        enableWorker: true,
                        lowLatencyMode: true,
                        backBufferLength: 90,
                        maxBufferLength: 30,
                        maxMaxBufferLength: 60,
                        debug: false
                    });
                    
                    hlsPlayer.on(Hls.Events.MANIFEST_PARSED, () => {
                        console.log('‚úÖ HLS manifest parsed, starting playback...');
                        audioElement.play()
                            .then(() => {
                                console.log('‚úÖ HLS playback started successfully');
                                isPlaying = true;
                                updateStatus('Playing (HLS Stream)', 'playing');
                                
                                // Display station icon as artwork for HLS streams
                                if (currentStation && currentStation.icon_url) {
                                    updateArtwork(`<img src="${escapeHtml(currentStation.icon_url)}" alt="${escapeHtml(currentStation.name)}" class="album-art" onerror="this.onerror=null; this.src='icons/icon-512x512.png'">`);
                                } else {
                                    updateArtwork(`<img src="icons/icon-512x512.png" alt="Radio Icon" class="album-art" style="padding: 40px;">`);
                                }
                                
                                metadataDiv.innerHTML = `
                                    <div class="now-playing-label">NOW PLAYING</div>
                                    <div class="song-title">${escapeHtml(currentStation ? currentStation.name : 'HLS Stream')}</div>
                                    <div class="artist-name">Live Stream</div>
                                `;
                                
                                // Update media session with station info for HLS streams
                                if (currentStation) {
                                    updateMediaSession(
                                        currentStation.name,
                                        'Live Stream',
                                        '',
                                        currentStation.icon_url
                                    );
                                }
                                updatePlayPauseButton(true);
                                playPauseBtn.disabled = false;
                                resolve();
                            })
                            .catch((error) => {
                                console.error('‚ùå HLS play() failed:', error);
                                reject(error);
                            });
                    });
                    
                    hlsPlayer.on(Hls.Events.ERROR, (event, data) => {
                        console.error('HLS Error:', data.type, data.details, data);
                        
                        if (data.fatal) {
                            console.error('‚ùå HLS fatal error:', data.type);
                            
                            // Check for mixed content error
                            if (data.details === 'manifestLoadError' && window.location.protocol === 'https:') {
                                console.error('‚ö†Ô∏è Possible mixed content error - HTTP stream on HTTPS page');
                                reject(new Error('Mixed Content: Cannot load HTTP stream on HTTPS page. Try using an HTTPS stream URL.'));
                                return;
                            }
                            
                            switch (data.type) {
                                case Hls.ErrorTypes.NETWORK_ERROR:
                                    console.error('Network error - attempting to recover...');
                                    hlsPlayer.startLoad();
                                    break;
                                case Hls.ErrorTypes.MEDIA_ERROR:
                                    console.error('Media error - attempting to recover...');
                                    hlsPlayer.recoverMediaError();
                                    break;
                                default:
                                    console.error('Unrecoverable error');
                                    reject(new Error(`HLS Error: ${data.type} - ${data.details}`));
                                    break;
                            }
                        }
                    });
                    
                    hlsPlayer.on(Hls.Events.MEDIA_ATTACHED, () => {
                        console.log('‚úÖ HLS media attached to audio element');
                    });

                    // Listen for ID3 metadata from HLS stream
                    hlsPlayer.on(Hls.Events.FRAG_PARSING_METADATA, (event, data) => {
                        console.log('üìª HLS metadata received:', data);

                        if (data.samples && data.samples.length > 0) {
                            data.samples.forEach(sample => {
                                try {
                                    // Parse ID3 frames
                                    const frames = parseID3Frames(sample.data);

                                    if (frames.TIT2 || frames.TPE1) {
                                        const title = frames.TIT2 || 'Unknown Track';
                                        const artist = frames.TPE1 || '';
                                        const album = frames.TALB || '';

                                        console.log('üéµ HLS Track Info:', { title, artist, album });

                                        // Update the metadata display
                                        metadataDiv.innerHTML = `
                                            <div class="now-playing-label">NOW PLAYING</div>
                                            <div class="song-title">${escapeHtml(title)}</div>
                                            ${artist ? `<div class="artist-name">${escapeHtml(artist)}</div>` : ''}
                                            ${album ? `<div class="album-name">${escapeHtml(album)}</div>` : ''}
                                            <button class="like-btn" id="likeBtn" onclick="toggleLikeTrack()">‚ô°</button>
                                        `;

                                        // Update current track info
                                        currentTrack = {
                                            title: title,
                                            artist: artist,
                                            album: album,
                                            artworkUrl: null,
                                            lyrics: null,
                                            lyricsUrl: null,
                                            hasLyrics: false
                                        };

                                        // Update like button
                                        updateLikeButton();

                                        // Fetch album art
                                        fetchAlbumArt(title, artist);

                                        // Fetch lyrics
                                        fetchLyricsForCurrentTrack();

                                        // Update media session
                                        updateMediaSession(title, artist, album, null);

                                        // Track the song play
                                        trackSongPlay(title, artist);
                                    }
                                } catch (error) {
                                    console.error('Error parsing HLS ID3 metadata:', error);
                                }
                            });
                        }
                    });

                    console.log('Loading HLS source...');
                    hlsPlayer.loadSource(streamUrl);
                    hlsPlayer.attachMedia(audioElement);
                    
                } else if (audioElement.canPlayType('application/vnd.apple.mpegurl')) {
                    console.log('‚úÖ Native HLS support detected (Safari)');
                    // Native HLS support (Safari)
                    audioElement.src = streamUrl;

                    // Listen for metadata tracks (Safari native HLS)
                    audioElement.textTracks.addEventListener('addtrack', (e) => {
                        const track = e.track;
                        if (track.kind === 'metadata') {
                            console.log('üìª Metadata track added (native HLS)');
                            track.mode = 'hidden';

                            track.addEventListener('cuechange', () => {
                                if (track.activeCues && track.activeCues.length > 0) {
                                    const cue = track.activeCues[0];
                                    console.log('üìª Native HLS metadata cue:', cue);

                                    if (cue.value) {
                                        try {
                                            // Parse metadata from cue
                                            const value = cue.value;
                                            let title, artist, album;

                                            // Check for common metadata formats
                                            if (value.data) {
                                                const frames = parseID3Frames(value.data);
                                                title = frames.TIT2;
                                                artist = frames.TPE1;
                                                album = frames.TALB;
                                            } else if (value.info) {
                                                // Alternative format
                                                title = value.info;
                                            }

                                            if (title || artist) {
                                                console.log('üéµ Native HLS Track Info:', { title, artist, album });

                                                // Update metadata display
                                                metadataDiv.innerHTML = `
                                                    <div class="now-playing-label">NOW PLAYING</div>
                                                    <div class="song-title">${escapeHtml(title || 'Unknown Track')}</div>
                                                    ${artist ? `<div class="artist-name">${escapeHtml(artist)}</div>` : ''}
                                                    ${album ? `<div class="album-name">${escapeHtml(album)}</div>` : ''}
                                                    <button class="like-btn" id="likeBtn" onclick="toggleLikeTrack()">‚ô°</button>
                                                `;

                                                // Update current track
                                                currentTrack = {
                                                    title: title || 'Unknown Track',
                                                    artist: artist || '',
                                                    album: album || '',
                                                    artworkUrl: null,
                                                    lyrics: null,
                                                    lyricsUrl: null,
                                                    hasLyrics: false
                                                };

                                                // Update like button
                                                updateLikeButton();

                                                // Fetch album art
                                                fetchAlbumArt(title || 'Unknown Track', artist || '');

                                                // Fetch lyrics
                                                fetchLyricsForCurrentTrack();

                                                // Update media session
                                                updateMediaSession(title || 'Unknown Track', artist || '', album || '', null);

                                                // Track the song play
                                                trackSongPlay(title || 'Unknown Track', artist || '');
                                            }
                                        } catch (error) {
                                            console.error('Error parsing native HLS metadata:', error);
                                        }
                                    }
                                }
                            });
                        }
                    });

                    audioElement.play()
                        .then(() => {
                            console.log('‚úÖ Native HLS playback started');
                            isPlaying = true;
                            updateStatus('Playing (HLS Stream)', 'playing');

                            // Display station icon as artwork for HLS streams
                            if (currentStation && currentStation.icon_url) {
                                updateArtwork(`<img src="${escapeHtml(currentStation.icon_url)}" alt="${escapeHtml(currentStation.name)}" class="album-art">`);
                            } else {
                                updateArtwork(`<img src="icons/icon-512x512.png" alt="Radio Icon" class="album-art" style="padding: 40px;">`);
                            }

                            metadataDiv.innerHTML = `
                                <div class="now-playing-label">NOW PLAYING</div>
                                <div class="song-title">${escapeHtml(currentStation ? currentStation.name : 'HLS Stream')}</div>
                                <div class="artist-name">Live Stream</div>
                            `;

                            // Update media session with station info for HLS streams
                            if (currentStation) {
                                updateMediaSession(
                                    currentStation.name,
                                    'Live Stream',
                                    '',
                                    currentStation.icon_url
                                );
                            }
                            updatePlayPauseButton(true);
                            playPauseBtn.disabled = false;
                            resolve();
                        })
                        .catch((error) => {
                            console.error('‚ùå Native HLS play() failed:', error);
                            reject(error);
                        });
                } else {
                    console.error('‚ùå HLS not supported in this browser');
                    reject(new Error('HLS not supported in this browser'));
                }
            });
        }
        
        // Function to update button state
        function updatePlayPauseButton(playing) {
            if (playing) {
                playPauseBtn.classList.remove('btn-play');
                playPauseBtn.classList.add('btn-pause');
                playIcon.style.display = 'none';
                pauseIcon.style.display = 'block';
            } else {
                playPauseBtn.classList.remove('btn-pause');
                playPauseBtn.classList.add('btn-play');
                playIcon.style.display = 'block';
                pauseIcon.style.display = 'none';
            }
        }
        
        // Play/Pause button handler
        playPauseBtn.addEventListener('click', async () => {
            // If we're casting, control the Cast media session instead of local playback
            if (castSession) {
                const media = castSession.getMediaSession();
                if (media) {
                    const playerState = media.playerState;
                    console.log('Cast player state:', playerState);

                    if (playerState === 'PLAYING' || playerState === 'BUFFERING') {
                        // Pause the cast
                        console.log('Pausing Cast playback...');
                        media.pause(new chrome.cast.media.PauseRequest()).then(() => {
                            console.log('‚úÖ Cast paused');
                            updatePlayPauseButton(false);
                            updateStatus('Paused (Casting)', 'stopped');
                        }).catch(error => {
                            console.error('Failed to pause Cast:', error);
                        });
                    } else if (playerState === 'PAUSED') {
                        // Resume the cast
                        console.log('Resuming Cast playback...');
                        media.play(new chrome.cast.media.PlayRequest()).then(() => {
                            console.log('‚úÖ Cast resumed');
                            updatePlayPauseButton(true);
                            updateStatus('Casting...', 'playing');
                        }).catch(error => {
                            console.error('Failed to resume Cast:', error);
                        });
                    } else {
                        console.log('Cast player in unknown state:', playerState);
                    }
                } else {
                    console.log('No active Cast media session');
                }
                return;
            }
            
            // SIMPLE MODE - Stop instead of pause (radio is live content)
            if (playbackMode === 'simple') {
                // If playing, stop both audio and metadata players
                if (isPlaying && simpleAudioPlayer && !simpleAudioPlayer.paused) {
                    console.log('‚èπÔ∏è Stopping audio player and metadata player');
                    simpleAudioPlayer.pause();
                    simpleAudioPlayer.removeAttribute('src'); // Remove source to fully stop
                    simpleAudioPlayer.load(); // Reset the media element
                    stopMetadataOnlyPlayer(); // Stop metadata player to keep in sync
                    isPlaying = false;
                    isPaused = false; // Not paused, fully stopped
                    updateStatus('Stopped', 'stopped');
                    updatePlayPauseButton(false);
                    return;
                }

                // If stopped/paused, start fresh from live stream
                if (!isPlaying) {
                    console.log('‚ñ∂Ô∏è Starting fresh playback from live stream');
                    // Fall through to load new stream below
                }
                
                // Start new playback in simple mode
                const rawUrl = currentStation 
                    ? (selectedQuality === 'low' && currentStation.url_low ? currentStation.url_low : 
                       selectedQuality === 'high' && currentStation.url_high ? currentStation.url_high : currentStation.url)
                    : null;
                
                if (!rawUrl) {
                    updateStatus('Please select a station', 'error');
                    return;
                }
                
                // Check if CORS proxy should be used
                const useCorsProxy = document.getElementById('globalCorsProxy').checked;

                // Force CORS proxy for HTTP URLs on HTTPS pages (mixed content fix)
                const needsCorsForMixedContent = window.location.protocol === 'https:' && rawUrl.startsWith('http://');

                const streamUrl = (useCorsProxy || needsCorsForMixedContent)
                    ? `https://corsproxy.io/?${encodeURIComponent(rawUrl)}`
                    : rawUrl;

                if (needsCorsForMixedContent && !useCorsProxy) {
                    console.log('üîí Mixed content detected: forcing CORS proxy for HTTP stream on HTTPS page');
                }
                
                playPauseBtn.disabled = true;
                updateStatus('Connecting...', 'loading');
                displayStationIcon();
                metadataDiv.innerHTML = `
                    <div class="now-playing-label">NOW PLAYING</div>
                    <div class="track-info">
                        <div class="track-title">${escapeHtml(currentStation.name)}</div>
                    </div>
                `;
                
                // Create or update simple audio player
                if (!simpleAudioPlayer) {
                    simpleAudioPlayer = new Audio();
                    simpleAudioPlayer.addEventListener('play', () => {
                        isPlaying = true;
                        updateStatus('Playing', 'playing');
                        updatePlayPauseButton(true);
                        playPauseBtn.disabled = false;
                    });
                    simpleAudioPlayer.addEventListener('pause', () => {
                        if (isPlaying) {
                            isPlaying = false;
                            updateStatus('Paused', 'stopped');
                            updatePlayPauseButton(false);
                        }
                    });
                    simpleAudioPlayer.addEventListener('error', (e) => {
                        // Ignore errors if we're intentionally reloading
                        if (simplePlayerReloading) {
                            console.log('Ignoring error during reload');
                            return;
                        }
                        
                        console.error('Simple player error:', e);
                        console.error('Audio element error code:', simpleAudioPlayer.error?.code);
                        console.error('Audio element error message:', simpleAudioPlayer.error?.message);
                        
                        let errorMsg = 'Error: Unable to play stream';
                        if (simpleAudioPlayer.error) {
                            switch(simpleAudioPlayer.error.code) {
                                case 1: errorMsg += ' (Aborted)'; break;
                                case 2: errorMsg += ' (Network error)'; break;
                                case 3: errorMsg += ' (Decode error)'; break;
                                case 4: errorMsg += ' (Format not supported)'; break;
                            }
                        }
                        
                        if (useCorsProxy) {
                            errorMsg += '. Try disabling CORS proxy in settings.';
                        } else {
                            errorMsg += '. Try enabling CORS proxy in settings.';
                        }
                        
                        updateStatus(errorMsg, 'error');
                        isPlaying = false;
                        updatePlayPauseButton(false);
                        playPauseBtn.disabled = false;
                    });
                }
                
                // Set reloading flag to suppress errors from old source
                simplePlayerReloading = true;
                
                simpleAudioPlayer.src = streamUrl;
                simpleAudioPlayer.load();
                
                // Clear reloading flag after a short delay
                setTimeout(() => {
                    simplePlayerReloading = false;
                }, 500);
                
                // Update Media Session for notification shade
                updateMediaSession(
                    currentStation.name,
                    '',
                    'Simple Mode - No Metadata',
                    currentStation.icon_url
                );

                // Start metadata-only player in background to get live metadata
                startMetadataOnlyPlayerForSimpleMode(rawUrl);

                // Try to play and handle the promise
                simpleAudioPlayer.play().catch(error => {
                    console.error('Play failed:', error);
                    updateStatus('Error: Unable to play stream', 'error');
                    playPauseBtn.disabled = false;
                    simplePlayerReloading = false;
                });
                return;
            }
            
            // LIVE MODE - Original IcecastMetadataPlayer behavior
            // If playing, pause (not stop)
            if (isPlaying && !isPaused) {
                isPaused = true;
                if (audioElement) {
                    audioElement.pause();
                } else if (player && player.audioElement) {
                    player.audioElement.pause();
                }
                isPlaying = false;
                updateStatus('Paused', 'stopped');
                updatePlayPauseButton(false);
                return;
            }
            
            // If paused, resume
            if (isPaused) {
                isPaused = false;
                if (audioElement && audioElement.src) {
                    audioElement.play();
                    isPlaying = true;
                    updateStatus('Playing', 'playing');
                    updatePlayPauseButton(true);
                    return;
                } else if (player && player.audioElement && player.audioElement.src) {
                    player.audioElement.play();
                    isPlaying = true;
                    updateStatus('Playing', 'playing');
                    updatePlayPauseButton(true);
                    return;
                }
            }
            
            // If not playing and not paused, start playing
            const rawUrl = currentStation 
                ? (selectedQuality === 'low' && currentStation.url_low ? currentStation.url_low : 
                   selectedQuality === 'high' && currentStation.url_high ? currentStation.url_high : currentStation.url)
                : null;
            
            if (!rawUrl) {
                updateStatus('Please select a station', 'error');
                return;
            }
            
            // Stop any existing players (reset pause state)
            isPaused = false;
            stopAllPlayers();

            // Cancel any ongoing connection attempts from previous station
            if (currentPlaybackAbortController) {
                currentPlaybackAbortController.abort();
                console.log('Cancelled previous connection attempts');
            }
            currentPlaybackAbortController = new AbortController();

            playPauseBtn.disabled = true;
            updateStatus('Connecting...', 'loading');
            updateArtwork(`<div class="album-art-placeholder">üîÑ</div>`);
            metadataDiv.innerHTML = `
                <div class="now-playing-label">NOW PLAYING</div>
                <div class="no-metadata">Loading stream...</div>
            `;
            
            // Check if it's an HLS stream
            if (isHLSStream(rawUrl)) {
                try {
                    console.log('Detected HLS stream (.m3u8), using HLS player');
                    await playHLSStream(rawUrl);
                    return;
                } catch (error) {
                    console.error('HLS playback failed:', error);
                    updateStatus('Error: Unable to play HLS stream', 'error');
                    playPauseBtn.disabled = false;
                    updatePlayPauseButton(false);
                    return;
                }
            }
            
            // Regular Icecast/Shoutcast stream handling
            const useCorsProxy = document.getElementById('globalCorsProxy').checked;

            // Define multiple CORS proxy services for fallback
            // ‚ö†Ô∏è IMPORTANT: Public CORS proxies are unreliable and often blocked/rate-limited
            //
            // For production use, consider:
            // 1. Prefer HTTPS radio streams (use Radio Browser search with üîí badge)
            // 2. Self-host a CORS proxy (see: cors-proxy/README.md in this repository)
            // 3. Deploy your own simple proxy on Cloudflare Workers, Vercel, or similar
            //
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // SELF-HOSTED PROXY SETUP (Recommended for reliability!)
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // This repository includes a ready-to-deploy CORS proxy in /cors-proxy
            //
            // Quick Setup:
            // 1. cd cors-proxy && npm install
            // 2. Deploy to Heroku/Railway/Render (see cors-proxy/README.md)
            // 3. Add your proxy URL below as the FIRST item (highest priority)
            //
            // Example after deploying to https://my-proxy.herokuapp.com:
            // const corsProxies = [
            //     { name: 'my-proxy', url: (streamUrl) => `https://my-proxy.herokuapp.com/${streamUrl}` },
            //     ...rest of proxies below as fallbacks
            // ];
            //
            // NOTE: corsProxies is now defined globally (see line ~962) and shared between
            // the main audio player and metadata player to ensure consistency.
            // Using the global definition here.

            // Prioritize Simple Mode for fastest, most reliable playback
            // Metadata will be fetched separately in the background
            const needsMixedContentFix = window.location.protocol === 'https:' && rawUrl.startsWith('http://');

            // Limit to just 3-4 attempts - if a station doesn't work after the first few tries, it won't work
            let attempts = [
                { url: rawUrl, cors: false, metadata: [], description: 'Simple Mode (Direct)' },
                { url: rawUrl, cors: true, corsProxyIndex: 0, metadata: ['icy', 'ogg'], description: 'CORS Proxy + Full Metadata' },
                { url: rawUrl, cors: false, metadata: ['icy', 'ogg'], description: 'Direct + Full Metadata' }
            ];

            // If mixed content fix is needed, try one alternative CORS proxy as a fallback
            if (needsMixedContentFix && corsProxies.length > 1) {
                attempts.push(
                    { url: rawUrl, cors: true, corsProxyIndex: 1, metadata: ['icy', 'ogg'], description: `${corsProxies[1].name} + Full Metadata` }
                );
            }

            if (!useCorsProxy) {
                // If CORS proxy is disabled, prioritize Simple Mode for fastest playback
                attempts = [
                    { url: rawUrl, cors: false, metadata: [], description: 'Simple Mode (Direct)' },
                    { url: rawUrl, cors: false, metadata: ['icy', 'ogg'], description: 'Direct + Full Metadata' },
                    { url: rawUrl, cors: true, corsProxyIndex: 0, metadata: ['icy', 'ogg'], description: 'CORS Proxy + Full Metadata' }
                ];

                // Even with CORS proxy disabled, try one fallback if mixed content fix is needed
                if (needsMixedContentFix && corsProxies.length > 1) {
                    attempts.push(
                        { url: rawUrl, cors: true, corsProxyIndex: 1, metadata: ['icy', 'ogg'], description: `${corsProxies[1].name} + Full Metadata` }
                    );
                }
            }
            
            let lastError = null;
            
            for (let i = 0; i < attempts.length; i++) {
                const attempt = attempts[i];

                // Check if we should abort (user switched to a different station)
                if (currentPlaybackAbortController.signal.aborted) {
                    console.log('Connection attempts aborted - user switched stations');
                    return;
                }

                // Special handling for Simple Mode attempt
                if (attempt.description.startsWith('Simple Mode')) {
                    console.log(`Attempting connection ${i + 1}/${attempts.length} - ${attempt.description}`);

                    // Update metadata area with current attempt
                    metadataDiv.innerHTML = `
                        <div class="now-playing-label">CONNECTING</div>
                        <div class="track-info">
                            <div class="track-title" style="font-size: 14px;">Attempt ${i + 1} of ${attempts.length}</div>
                            <div class="track-artist" style="font-size: 12px; opacity: 0.8;">${attempt.description}...</div>
                            <div class="track-artist" style="font-size: 11px; opacity: 0.6; margin-top: 4px;">Testing HTML5 audio compatibility</div>
                        </div>
                    `;

                    try {
                        updateStatus(`Attempting ${i + 1}/${attempts.length}: ${attempt.description}`, 'loading');
                        displayStationIcon();

                        // Create HTML5 audio player directly
                        const testAudio = new Audio();

                        // Use CORS proxy for HTTP URLs when on HTTPS page (mixed content fix)
                        let simpleUrl = rawUrl;
                        if (window.location.protocol === 'https:' && rawUrl.startsWith('http://')) {
                            const proxyIndex = attempt.corsProxyIndex !== undefined ? attempt.corsProxyIndex : 0;
                            const proxy = corsProxies[proxyIndex];
                            console.log(`üîí Mixed content detected: using ${proxy.name} for HTTP stream on HTTPS page`);
                            simpleUrl = proxy.url(rawUrl);
                        }

                        testAudio.src = simpleUrl;
                        testAudio.preload = 'auto';
                        
                        // Wait for it to load and play
                        await new Promise((resolve, reject) => {
                            const timeoutTimer = setTimeout(() => {
                                testAudio.pause();
                                testAudio.src = '';
                                reject(new Error('Simple mode timeout'));
                            }, 10000);
                            
                            testAudio.addEventListener('canplay', () => {
                                clearTimeout(timeoutTimer);
                                console.log(`Attempt ${i + 1} succeeded with Simple Mode!`);
                                
                                // Now officially switch to Simple mode
                                playbackMode = 'simple';
                                if (currentModeText) currentModeText.textContent = 'Simple';
                                
                                // Set up the real simple audio player
                                if (simpleAudioPlayer) {
                                    simpleAudioPlayer.pause();
                                }
                                simpleAudioPlayer = testAudio;
                                
                                // Add event listeners
                                simpleAudioPlayer.addEventListener('play', () => {
                                    isPlaying = true;
                                    updateStatus('Playing', 'playing');
                                    updatePlayPauseButton(true);
                                    playPauseBtn.disabled = false;
                                });
                                simpleAudioPlayer.addEventListener('pause', () => {
                                    if (isPlaying) {
                                        isPlaying = false;
                                        updateStatus('Paused', 'stopped');
                                        updatePlayPauseButton(false);
                                    }
                                });
                                simpleAudioPlayer.addEventListener('error', (e) => {
                                    if (simplePlayerReloading) {
                                        console.log('Ignoring error during reload');
                                        return;
                                    }
                                    console.error('Simple player error:', e);
                                    updateStatus('Error: Unable to play stream', 'error');
                                    isPlaying = false;
                                    updatePlayPauseButton(false);
                                    playPauseBtn.disabled = false;
                                });
                                
                                // Start playing
                                simpleAudioPlayer.play().then(() => {
                                    metadataDiv.innerHTML = `
                                        <div class="now-playing-label">NOW PLAYING</div>
                                        <div class="track-info">
                                            <div class="track-title">${escapeHtml(currentStation.name)}</div>
                                            <div class="track-artist" style="font-size: 12px; opacity: 0.6;">Fetching metadata...</div>
                                        </div>
                                    `;
                                    isPlaying = true;
                                    updatePlayPauseButton(true);
                                    playPauseBtn.disabled = false;

                                    // Update Media Session for notification shade
                                    updateMediaSession(
                                        currentStation.name,
                                        '',
                                        'Simple Mode',
                                        currentStation.icon_url
                                    );

                                    // Start metadata-only player in background to get live metadata
                                    startMetadataOnlyPlayerForSimpleMode(rawUrl);

                                    resolve();
                                }).catch(reject);
                            }, { once: true });
                            
                            testAudio.addEventListener('error', (e) => {
                                clearTimeout(timeoutTimer);
                                const audioError = testAudio.error;
                                let errorMsg = 'Simple mode failed to load';

                                if (audioError) {
                                    const errorTypes = {
                                        1: 'MEDIA_ERR_ABORTED - Loading was aborted',
                                        2: 'MEDIA_ERR_NETWORK - Network error occurred',
                                        3: 'MEDIA_ERR_DECODE - Decoding error occurred',
                                        4: 'MEDIA_ERR_SRC_NOT_SUPPORTED - Source not supported'
                                    };
                                    errorMsg += ` (${errorTypes[audioError.code] || 'Unknown error code: ' + audioError.code})`;
                                    if (audioError.message) {
                                        errorMsg += `: ${audioError.message}`;
                                    }
                                }

                                console.error('Simple mode error details:', errorMsg);
                                console.error('Stream URL:', simpleUrl);

                                testAudio.pause();
                                testAudio.src = '';
                                reject(new Error(errorMsg));
                            }, { once: true });
                            
                            // Start loading
                            testAudio.load();
                        });
                        
                        console.log(`Attempt ${i + 1} succeeded!`);
                        return; // Success!
                        
                    } catch (error) {
                        console.error(`Attempt ${i + 1}/${attempts.length} failed:`, error.message);
                        
                        if (i < attempts.length - 1) {
                            continue;
                        }
                        lastError = error;
                    }
                    continue;
                }
                
                // Regular IcecastMetadataPlayer attempts
                // Force CORS proxy for HTTP URLs on HTTPS pages to avoid mixed content errors
                let streamUrl;
                const proxyIndex = attempt.corsProxyIndex !== undefined ? attempt.corsProxyIndex : 0;
                const proxy = corsProxies[proxyIndex];

                if (attempt.cors) {
                    streamUrl = proxy.url(attempt.url);
                    console.log(`Using ${proxy.name} for stream`);
                } else if (window.location.protocol === 'https:' && attempt.url.startsWith('http://')) {
                    console.log(`üîí Mixed content detected: forcing ${proxy.name} for HTTP stream on HTTPS page`);
                    streamUrl = proxy.url(attempt.url);
                } else {
                    streamUrl = attempt.url;
                }
                
                console.log(`Attempting connection ${i + 1}/${attempts.length} - ${attempt.description}`);
                
                // Update metadata area with current attempt
                metadataDiv.innerHTML = `
                    <div class="now-playing-label">CONNECTING</div>
                    <div class="track-info">
                        <div class="track-title" style="font-size: 14px;">Attempt ${i + 1} of ${attempts.length}</div>
                        <div class="track-artist" style="font-size: 12px; opacity: 0.8;">${attempt.description}...</div>
                        <div class="track-artist" style="font-size: 11px; opacity: 0.6; margin-top: 4px;">Please wait, trying to connect</div>
                    </div>
                `;
                
                try {
                    if (i > 0) {
                        updateStatus(`Attempting ${i + 1}/${attempts.length}: ${attempt.description}`, 'loading');
                    }
                    
                    player = new IcecastMetadataPlayer(streamUrl, {
                        metadataTypes: attempt.metadata,
                        enableLogging: false,
                        
                        onMetadata: (metadata) => {
                            displayMetadata(metadata);
                        },
                        
                        onPlay: () => {
                            isPlaying = true;
                            const statusMsg = attempt.metadata.length === 0 
                                ? 'Playing (no metadata available)'
                                : 'Playing';
                            updateStatus(statusMsg, 'playing');
                            updatePlayPauseButton(true);
                            playPauseBtn.disabled = false;
                            // Update media session with station info when starting stream
                            if (currentStation && attempt.metadata.length === 0) {
                                updateMediaSession(
                                    currentStation.name,
                                    '',
                                    '',
                                    currentStation.icon_url
                                );
                            }
                        },
                        
                        onStop: () => {
                            // Don't update UI if we're just pausing
                            if (isPaused) {
                                return;
                            }
                            isPlaying = false;
                            updateStatus('Stopped', 'stopped');
                            playPauseBtn.disabled = false;
                            updatePlayPauseButton(false);
                            displayStationIcon();
                            metadataDiv.innerHTML = `
                                <div class="now-playing-label">NOW PLAYING</div>
                                <div class="no-metadata">Select a station to start streaming</div>
                            `;
                        },
                        
                        onError: (error) => {
                            console.error(`Player error on attempt ${i + 1}:`, error);
                        },
                        
                        bufferLength: 3,
                        retryTimeout: 5,
                        retryDelayRate: 0.5,
                        retryDelayMin: 1,
                        retryDelayMax: 10
                    });
                    
                    // Add timeout to prevent hanging on failed attempts (reduced to 8 seconds)
                    const playPromise = player.play();
                    const timeoutPromise = new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Connection timeout')), 8000)
                    );
                    
                    await Promise.race([playPromise, timeoutPromise]);
                    
                    console.log(`Attempt ${i + 1} succeeded!`);
                    return;
                    
                } catch (error) {
                    console.error(`Attempt ${i + 1}/${attempts.length} failed:`, error.message);
                    lastError = error;
                    
                    if (player) {
                        try {
                            player.stop();
                        } catch (e) {}
                    }
                    
                    if (i < attempts.length - 1) {
                        continue;
                    }
                }
            }
            
            console.error('All connection attempts failed');
            console.log('Fallback check - autoFallbackEnabled:', autoFallbackEnabled, 'hasFallbackAttempted:', hasFallbackAttempted, 'playbackMode:', playbackMode);
            
            // Show final error - all attempts including simple mode have failed
            console.log('All attempts (including Simple mode) failed - showing error');
            isPlaying = false;
            
            metadataDiv.innerHTML = `
                <div class="now-playing-label">CONNECTION FAILED</div>
                <div class="track-info">
                    <div class="track-title" style="font-size: 14px;">All ${attempts.length} attempts failed</div>
                    <div class="track-artist" style="font-size: 12px; opacity: 0.8;">Try a different station or check settings</div>
                </div>
            `;
            
            updateStatus('Error: Unable to connect after all attempts', 'error');
            playPauseBtn.disabled = false;
            updatePlayPauseButton(false);
        });
        
        // Allow Enter key to search
        stationSearch.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && filteredStations.length === 1) {
                selectStation(filteredStations[0]);
            }
        });
        
        // ======================
        // VIEW TOGGLE FUNCTIONS
        // ======================
        
        // Toggle station view mode
        function toggleStationView() {
            stationViewMode = stationViewMode === 'list' ? 'grid' : 'list';
            updateStationViewUI();
            renderStationList();
        }
        
        // Update station view toggle UI
        function updateStationViewUI() {
            if (stationViewMode === 'list') {
                stationViewIcon.textContent = '‚äû';
                stationViewText.textContent = 'Grid';
            } else {
                stationViewIcon.textContent = '‚ò∞';
                stationViewText.textContent = 'List';
            }
        }
        
        // Toggle playlist view mode
        function togglePlaylistView() {
            playlistViewMode = playlistViewMode === 'list' ? 'grid' : 'list';
            updatePlaylistViewUI();
            renderPlaylistsList();
        }
        
        // Update playlist view toggle UI
        function updatePlaylistViewUI() {
            if (playlistViewMode === 'list') {
                playlistViewIcon.textContent = '‚äû';
                playlistViewText.textContent = 'Grid';
            } else {
                playlistViewIcon.textContent = '‚ò∞';
                playlistViewText.textContent = 'List';
            }
        }
        
        // Toggle playlist station view mode (for Most Recent, Most Played, and custom playlists)
        function togglePlaylistStationView() {
            playlistStationViewMode = playlistStationViewMode === 'list' ? 'grid' : 'list';
            updatePlaylistStationViewUI();
            renderPlaylistStations();
        }
        
        // Update playlist station view toggle UI
        function updatePlaylistStationViewUI() {
            if (playlistStationViewMode === 'list') {
                playlistStationViewIcon.textContent = '‚äû';
                playlistStationViewText.textContent = 'Grid';
            } else {
                playlistStationViewIcon.textContent = '‚ò∞';
                playlistStationViewText.textContent = 'List';
            }
        }
        
        // Add event listeners for view toggle buttons
        if (stationViewToggle) {
            stationViewToggle.addEventListener('click', toggleStationView);
        }
        if (playlistViewToggle) {
            playlistViewToggle.addEventListener('click', togglePlaylistView);
        }
        if (playlistStationViewToggle) {
            playlistStationViewToggle.addEventListener('click', togglePlaylistStationView);
        }
        
        // ======================
        // INITIALIZATION
        // ======================

        (async () => {
            console.log('=== INITIALIZATION STARTING ===');
            console.log('Supabase initialized:', !!supabase);

            // Check authentication status
            await checkAuth();

            // Initialize quality modal options
            qualityModal.querySelectorAll('.quality-option-modal[data-quality]').forEach(option => {
                if (option.dataset.quality !== 'standard') {
                    option.classList.add('disabled');
                }
            });

            console.log('About to call loadStations()');

            // Load saved settings from localStorage
            const savedPlaybackMode = localStorage.getItem('playbackMode');
            if (savedPlaybackMode) {
                playbackMode = savedPlaybackMode;
                const currentModeElement = document.getElementById('currentMode');
                if (currentModeElement) currentModeElement.textContent = playbackMode === 'live' ? 'Live' : 'Simple';
            }

            const savedQuality = localStorage.getItem('quality');
            if (savedQuality) {
                quality = savedQuality;
                selectedQuality = savedQuality;
            }

            const savedAutoFallback = localStorage.getItem('autoFallback');
            if (savedAutoFallback !== null) {
                autoFallbackEnabled = savedAutoFallback === 'true';
                const checkbox = document.getElementById('autoFallback');
                if (checkbox) checkbox.checked = autoFallbackEnabled;
            }

            // Load stations from Supabase on startup
            loadStations();
            loadPlaylists();

            console.log('loadStations() and loadPlaylists() called');

            // Setup Media Session handlers
            setupMediaSessionHandlers();

            // Setup Page Visibility API to handle background/foreground transitions
            document.addEventListener('visibilitychange', () => {
                if (!document.hidden && isPlaying && !isPaused) {
                    // App became visible and is playing - fetch metadata immediately to update notification
                    console.log('üîÑ App became visible, refreshing metadata...');
                    fetchMetadataOnce();
                }
            });
        })();

        // Close dropdowns when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.station-menu-btn') && 
                !e.target.closest('.station-dropdown') &&
                !e.target.closest('.playlist-menu-btn') &&
                !e.target.closest('.playlist-dropdown') &&
                !e.target.closest('.filter-btn') &&
                !e.target.closest('.filter-dropdown')) {
                document.querySelectorAll('.station-dropdown, .playlist-dropdown, .filter-dropdown').forEach(dropdown => {
                    dropdown.classList.remove('active');
                });
                // Also close any open submenus
                document.querySelectorAll('.dropdown-submenu').forEach(submenu => {
                    submenu.classList.remove('active');
                });
            }
        });
    </script>
    
    <!-- Service Worker Registration -->
    <script>
        // Register service worker for PWA functionality
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // Use relative path for GitHub Pages subdirectory support
                navigator.serviceWorker.register('./sw.js')
                    .then((registration) => {
                        console.log('ServiceWorker registered:', registration.scope);
                        
                        // Listen for messages from the service worker
                        navigator.serviceWorker.addEventListener('message', (event) => {
                            if (event.data && event.data.type === 'CACHE_CLEARED') {
                                console.log('Service worker cache cleared successfully');
                            }
                        });
                        
                        // Check for updates
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    // New service worker available, prompt user to refresh
                                    if (confirm('New version available! Reload to update?')) {
                                        newWorker.postMessage({ type: 'SKIP_WAITING' });
                                        window.location.reload();
                                    }
                                }
                            });
                        });
                    })
                    .catch((error) => {
                        console.log('ServiceWorker registration failed:', error);
                    });
                
                // Handle service worker updates
                let refreshing;
                navigator.serviceWorker.addEventListener('controllerchange', () => {
                    if (refreshing) return;
                    refreshing = true;
                    window.location.reload();
                });
            });
        }
        
        // Install prompt handling
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            // Prevent the mini-infobar from appearing
            e.preventDefault();
            deferredPrompt = e;
            
            // Optionally, show an install button
            console.log('App can be installed');
        });
        
        window.addEventListener('appinstalled', () => {
            console.log('PWA was installed');
            deferredPrompt = null;
        });
    </script>
</body>
</html>
